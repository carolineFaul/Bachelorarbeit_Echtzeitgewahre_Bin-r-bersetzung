ca65 V2.18 - Ubuntu 2.19-1
Main file   : 6502_functional_test.ca65
Current file: 6502_functional_test.ca65

000000r 1               ;
000000r 1               ; 6 5 0 2   F U N C T I O N A L   T E S T
000000r 1               ;
000000r 1               ; Copyright (C) 2012-2020  Klaus Dormann
000000r 1               ;
000000r 1               ; This program is free software: you can redistribute it and/or modify
000000r 1               ; it under the terms of the GNU General Public License as published by
000000r 1               ; the Free Software Foundation, either version 3 of the License, or
000000r 1               ; (at your option) any later version.
000000r 1               ;
000000r 1               ; This program is distributed in the hope that it will be useful,
000000r 1               ; but WITHOUT ANY WARRANTY; without even the implied warranty of
000000r 1               ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
000000r 1               ; GNU General Public License for more details.
000000r 1               ;
000000r 1               ; You should have received a copy of the GNU General Public License
000000r 1               ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
000000r 1               
000000r 1               
000000r 1               ; This program is designed to test all opcodes of a 6502 emulator using all
000000r 1               ; addressing modes with focus on propper setting of the processor status
000000r 1               ; register bits.
000000r 1               ;
000000r 1               ; version 05-jan-2020
000000r 1               ; contact info at http://2m5.de or email K@2m5.de
000000r 1               ;
000000r 1               ; assembled with CA65, linked with LD65 (cc65.github.io):
000000r 1               ;  ca65 -l 6502_functional_test.lst 6502_functional_test.ca65
000000r 1               ;  ld65 6502_functional_test.o -o 6502_functional_test.bin \
000000r 1               ;   -m 6502_functional_test.map -C example.cfg
000000r 1               ; example linker config (example.cfg):
000000r 1               ;  MEMORY {
000000r 1               ;  RAM: start = $0000, size=$8000, type = rw, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM: start = $8000, size=$7FFA, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  ROM_VECTORS: start = $FFFA, size=6, type = ro, fill = yes, \
000000r 1               ;   fillval = $FF, file = %O;
000000r 1               ;  }
000000r 1               ;  SEGMENTS {
000000r 1               ;  ZEROPAGE: load=RAM, type=rw;
000000r 1               ;  DATA: load=RAM, type=rw, offset=$0200;
000000r 1               ;  CODE: load=RAM, type=rw, offset=$0400;
000000r 1               ;  VECTORS: load=ROM_VECTORS, type=ro;
000000r 1               ;  }
000000r 1               ;
000000r 1               ; No IO - should be run from a monitor with access to registers.
000000r 1               ; To run load intel hex image with a load command, than alter PC to 400 hex
000000r 1               ; (code_segment) and enter a go command.
000000r 1               ; Loop on program counter determines error or successful completion of test.
000000r 1               ; Check listing for relevant traps (jump/branch *).
000000r 1               ; Please note that in early tests some instructions will have to be used before
000000r 1               ; they are actually tested!
000000r 1               ;
000000r 1               ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
000000r 1               ; Tests documented behavior of the original NMOS 6502 only! No unofficial
000000r 1               ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
000000r 1               ; not be tested. Decimal ops will only be tested with valid BCD operands and
000000r 1               ; N V Z flags will be ignored.
000000r 1               ;
000000r 1               ; Debugging hints:
000000r 1               ;     Most of the code is written sequentially. if you hit a trap, check the
000000r 1               ;   immediately preceeding code for the instruction to be tested. Results are
000000r 1               ;   tested first, flags are checked second by pushing them onto the stack and
000000r 1               ;   pulling them to the accumulator after the result was checked. The "real"
000000r 1               ;   flags are no longer valid for the tested instruction at this time!
000000r 1               ;     If the tested instruction was indexed, the relevant index (X or Y) must
000000r 1               ;   also be checked. Opposed to the flags, X and Y registers are still valid.
000000r 1               ;
000000r 1               ; versions:
000000r 1               ;   28-jul-2012  1st version distributed for testing
000000r 1               ;   29-jul-2012  fixed references to location 0, now #0
000000r 1               ;                added license - GPLv3
000000r 1               ;   30-jul-2012  added configuration options
000000r 1               ;   01-aug-2012  added trap macro to allow user to change error handling
000000r 1               ;   01-dec-2012  fixed trap in branch field must be a branch
000000r 1               ;   02-mar-2013  fixed PLA flags not tested
000000r 1               ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
000000r 1               ;                added test sequence check to detect if tests jump their fence
000000r 1               ;   23-jul-2013  added RAM integrity check option
000000r 1               ;   16-aug-2013  added error report to standard output option
000000r 1               ;   13-dec-2014  added binary/decimal opcode table switch test
000000r 1               ;   14-dec-2014  improved relative address test
000000r 1               ;   23-aug-2015  added option to disable self modifying tests
000000r 1               ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
000000r 1               ;                added small branch offset pretest
000000r 1               ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
000000r 1               ;   04-dec-2017  fixed BRK only tested with interrupts enabled
000000r 1               ;                added option to skip the remainder of a failing test
000000r 1               ;                in report.i65
000000r 1               ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
000000r 1               ;                is shifted out
000000r 1               
000000r 1               ; C O N F I G U R A T I O N
000000r 1               
000000r 1               ;ROM_vectors writable (0=no, 1=yes)
000000r 1               ;if ROM vectors can not be used interrupts will not be trapped
000000r 1               ;as a consequence BRK can not be tested but will be emulated to test RTI
000000r 1               ROM_vectors = 1
000000r 1               
000000r 1               ;load_data_direct (0=move from code segment, 1=load directly)
000000r 1               ;loading directly is preferred but may not be supported by your platform
000000r 1               ;0 produces only consecutive object code, 1 is not suitable for a binary image
000000r 1               load_data_direct = 1
000000r 1               
000000r 1               ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
000000r 1               ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
000000r 1               ;tested if you allow changing the interrupt status (I_flag = 3)
000000r 1               I_flag = 3
000000r 1               
000000r 1               ;configure memory - try to stay away from memory used by the system
000000r 1               ;zero_page memory start address, $52 (82) consecutive Bytes required
000000r 1               ;                                add 2 if I_flag = 2
000000r 1               zero_page = $a
000000r 1               
000000r 1               ;data_segment memory start address, $7B (123) consecutive Bytes required
000000r 1               ; check that this matches the linker configuration file
000000r 1               data_segment = $200
000000r 1                   .if (data_segment & $ff) <> 0
000000r 1                       .error "low byte of data_segment MUST be $00 !!"
000000r 1                   .endif
000000r 1               
000000r 1               ;code_segment memory start address, 13.1kB of consecutive space required
000000r 1               ;                                   add 2.5 kB if I_flag = 2
000000r 1               ; check that this matches the linker configuration file
000000r 1               code_segment = $400
000000r 1               
000000r 1               ;self modifying code may be disabled to allow running in ROM
000000r 1               ;0=part of the code is self modifying and must reside in RAM
000000r 1               ;1=tests disabled: branch range
000000r 1               disable_selfmod = 1
000000r 1               
000000r 1               ;report errors through I/O channel (0=use standard self trap loops, 1=include
000000r 1               ;report.i65 as I/O channel, add 3.5 kB)
000000r 1               report = 1
000000r 1               
000000r 1               ;RAM integrity test option. Checks for undesired RAM writes.
000000r 1               ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
000000r 1               ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
000000r 1               ram_top = -1
000000r 1               
000000r 1               ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
000000r 1               ;2=disable including decimal flag in processor status
000000r 1               disable_decimal = 0
000000r 1               
000000r 1               ;macros for error & success traps to allow user modification
000000r 1               ;example:
000000r 1               ;        .macro  trap
000000r 1               ;        jsr my_error_handler
000000r 1               ;        .endmacro
000000r 1               ;        .macro  trap_eq
000000r 1               ;        bne :+
000000r 1               ;        trap           ;failed equal (zero)
000000r 1               ;:
000000r 1               ;        .endmacro
000000r 1               ;
000000r 1               ; my_error_handler should pop the calling address from the stack and report it.
000000r 1               ; putting larger portions of code (more than 3 bytes) inside the trap macro
000000r 1               ; may lead to branch range problems for some tests.
000000r 1                   .if report = 0
000000r 1                       .macro  trap
000000r 1                       jmp *           ;failed anyway
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       beq *           ;failed equal (zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       bne *           ;failed not equal (non zero)
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcs *           ;failed carry set
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcc *           ;failed carry clear
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bmi *           ;failed minus (bit 7 set)
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bpl *           ;failed plus (bit 7 clear)
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvs *           ;failed overflow set
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvc *           ;failed overflow clear
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jmp *           ;test passed, no errors
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1                   .if report = 1
000000r 1                       .macro  trap
000000r 1                       jsr report_error
000000r 1                       .endmacro
000000r 1                       .macro  trap_eq
000000r 1                       bne :+
000000r 1                       trap           ;failed equal (zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_ne
000000r 1                       beq :+
000000r 1                       trap            ;failed not equal (non zero)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cs
000000r 1                       bcc :+
000000r 1                       trap            ;failed carry set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_cc
000000r 1                       bcs :+
000000r 1                       trap            ;failed carry clear
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_mi
000000r 1                       bpl :+
000000r 1                       trap            ;failed minus (bit 7 set)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_pl
000000r 1                       bmi :+
000000r 1                       trap            ;failed plus (bit 7 clear)
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vs
000000r 1                       bvc :+
000000r 1                       trap            ;failed overflow set
000000r 1               :
000000r 1                       .endmacro
000000r 1                       .macro  trap_vc
000000r 1                       bvs :+
000000r 1                       trap            ;failed overflow clear
000000r 1               :
000000r 1                       .endmacro
000000r 1               ; please observe that during the test the stack gets invalidated
000000r 1               ; therefore a RTS inside the success macro is not possible
000000r 1                       .macro  success
000000r 1                       jsr report_success
000000r 1                       .endmacro
000000r 1                   .endif
000000r 1               
000000r 1                   .define equ =
000000r 1               
000000r 1               carry   equ %00000001   ;flag bits in status
000000r 1               zero    equ %00000010
000000r 1               intdis  equ %00000100
000000r 1               decmode equ %00001000
000000r 1               break   equ %00010000
000000r 1               reserv  equ %00100000
000000r 1               overfl  equ %01000000
000000r 1               minus   equ %10000000
000000r 1               
000000r 1               fc      equ carry
000000r 1               fz      equ zero
000000r 1               fzc     equ carry+zero
000000r 1               fv      equ overfl
000000r 1               fvz     equ overfl+zero
000000r 1               fn      equ minus
000000r 1               fnc     equ minus+carry
000000r 1               fnz     equ minus+zero
000000r 1               fnzc    equ minus+zero+carry
000000r 1               fnv     equ minus+overfl
000000r 1               
000000r 1               fao     equ break+reserv    ;bits always on after PHP, BRK
000000r 1               fai     equ fao+intdis      ;+ forced interrupt disable
000000r 1               faod    equ fao+decmode     ;+ ignore decimal
000000r 1               faid    equ fai+decmode     ;+ ignore decimal
000000r 1               m8      equ $ff             ;8 bit mask
000000r 1               m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
000000r 1               
000000r 1               ;macros to allow masking of status bits.
000000r 1               ;masking test of decimal bit
000000r 1               ;masking of interrupt enable/disable on load and compare
000000r 1               ;masking of always on bits after PHP or BRK (unused & break) on compare
000000r 1                   .if disable_decimal < 2
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i          ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8i   ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fai)&m8    ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #(p1|fai)       ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           cmp #(p1|fao)&m8i   ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           eor #(p1&m8i|fao)   ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           cmp #(p1|fao)&m8    ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor #p1|fao         ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .else
000000r 1                       .if I_flag = 0
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1&m8i         ;force enable interrupts (mask I)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;I_flag is always enabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 1
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1|intdis      ;force disable interrupts
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faid)&m8   ;I_flag is always disabled + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1|faid)      ;invert expected flags + always on bits + I
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 2
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1
000000r 1                           ora flag_I_on       ;restore I-flag
000000r 1                           and flag_I_off
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8i  ;expected flags + always on bits, mask I
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           eor flag_I_on       ;I_flag is never changed
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #(p1&m8i|faod)  ;mask I, invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                       .if I_flag = 3
000000r 1                           .macro  load_flag   p1
000000r 1                           lda #p1             ;allow test to change I-flag (no mask)
000000r 1                           .endmacro
000000r 1                           .macro  cmp_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           cmp #(p1|faod)&m8   ;expected flags + always on bits
000000r 1                           .endmacro
000000r 1                           .macro  eor_flag    p1
000000r 1                           ora #decmode        ;ignore decimal mode bit
000000r 1                           eor #p1|faod        ;invert expected flags + always on bits
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1                   .endif
000000r 1               
000000r 1               ;macros to set (register|memory|zeropage) & status
000000r 1                           .macro      set_stat    p1          ;setting flags in the processor status register
000000r 1                           load_flag p1
000000r 1                           pha         ;use stack to load status
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_a       p1,p2       ;precharging accu & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda #p1     ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_x       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldx #p1     ;precharge index x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_y       p1,p2       ;precharging index & status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           ldy #p1     ;precharge index y
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ax      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_ay      p1,p2       ;precharging indexed accu & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,y    ;precharge accu
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_z       p1,p2       ;precharging indexed zp & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to zeropage
000000r 1                           sta zpt
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_zx      p1,p2       ;precharging zp,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed zeropage
000000r 1                           sta zpt,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_abs     p1,p2       ;precharging indexed memory & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to memory
000000r 1                           sta abst
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      set_absx    p1,p2       ;precharging abs,x & immediate status
000000r 1                           load_flag p2
000000r 1                           pha         ;use stack to load status
000000r 1                           lda p1,x    ;load to indexed memory
000000r 1                           sta abst,x
000000r 1                           plp
000000r 1                           .endmacro
000000r 1               
000000r 1               ;macros to test (register|memory|zeropage) & status & (mask)
000000r 1                           .macro      tst_stat    p1          ;testing flags in the processor status register
000000r 1                           php         ;save status
000000r 1                           pla         ;use stack to retrieve status
000000r 1                           pha
000000r 1                           cmp_flag p1
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_a       p1,p2        ;testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_x       p1,p2       ;testing result in x index & flags
000000r 1                           php         ;save flags
000000r 1                           cpx #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_y       p1,p2       ;testing result in y index & flags
000000r 1                           php         ;save flags
000000r 1                           cpy #p1     ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           pha
000000r 1                           cmp_flag p2
000000r 1                           trap_ne
000000r 1                           plp         ;restore status
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ax      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne     ;
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_ay      p1,p2,p3    ;indexed testing result in accu & flags
000000r 1                           php         ;save flags
000000r 1                           cmp p1,y    ;test result
000000r 1                           trap_ne     ;
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,y    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_z       p1,p2,p3    ;indexed testing result in zp & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_zx      p1,p2,p3    ;testing result in zp,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda zpt,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_abs     p1,p2,p3    ;indexed testing result in memory & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1                           .macro      tst_absx    p1,p2,p3    ;testing result in abs,x & flags
000000r 1                           php         ;save flags
000000r 1                           lda abst,x
000000r 1                           cmp p1,x    ;test result
000000r 1                           trap_ne
000000r 1                           pla         ;load status
000000r 1                           eor_flag p3
000000r 1                           cmp p2,x    ;test flags
000000r 1                           trap_ne
000000r 1                           .endmacro
000000r 1               
000000r 1               ; RAM integrity test
000000r 1               ;   verifies that none of the previous tests has altered RAM outside of the
000000r 1               ;   designated write areas.
000000r 1               ;   uses zpt word as indirect pointer, zpt+2 word as checksum
000000r 1                       .if ram_top > -1
000000r 1               check_ram   macro
000000r 1                           cld
000000r 1                           lda #0
000000r 1                           sta zpt         ;set low byte of indirect pointer
000000r 1                           sta zpt+3       ;checksum high byte
000000r 1                         .if disable_selfmod = 0
000000r 1                           sta range_adr   ;reset self modifying code
000000r 1                         .endif
000000r 1                           clc
000000r 1                           ldx #zp_bss-zero_page ;zeropage - write test area
000000r 1               ccs3:       adc zero_page,x
000000r 1                           bcc ccs2
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs2:       inx
000000r 1                           bne ccs3
000000r 1                           ldx #hi(abs1)   ;set high byte of indirect pointer
000000r 1                           stx zpt+1
000000r 1                           ldy #lo(abs1)   ;data after write & execute test area
000000r 1               ccs5:       adc (zpt),y
000000r 1                           bcc ccs4
000000r 1                           inc zpt+3       ;carry to high byte
000000r 1                           clc
000000r 1               ccs4:       iny
000000r 1                           bne ccs5
000000r 1                           inx             ;advance RAM high address
000000r 1                           stx zpt+1
000000r 1                           cpx #ram_top
000000r 1                           bne ccs5
000000r 1                           sta zpt+2       ;checksum low is
000000r 1                           cmp ram_chksm   ;checksum low expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           lda zpt+3       ;checksum high is
000000r 1                           cmp ram_chksm+1 ;checksum high expected
000000r 1                           trap_ne         ;checksum mismatch
000000r 1                           .endmacro
000000r 1                       .else
000000r 1                           .macro  check_ram
000000r 1                           ;RAM check disabled - RAM size not set
000000r 1                           .endmacro
000000r 1                       .endif
000000r 1               
000000r 1                           .macro  next_test   ;make sure, tests don't jump the fence
000000r 1                           lda test_case   ;previous test
000000r 1                           cmp #test_num
000000r 1                           trap_ne         ;test is out of sequence
000000r 1               test_num .set test_num + 1
000000r 1                           lda #test_num   ;*** next tests' number
000000r 1                           sta test_case
000000r 1                           ;check_ram       ;uncomment to find altered RAM after each test
000000r 1                           .endmacro
000000r 1               
000000r 1                       .ZEROPAGE
000000r 1  00 00 00 00  		.res zero_page, 0
000004r 1  00 00 00 00  
000008r 1  00 00        
00000Ar 1                       .org zero_page
00000A  1               
00000A  1               ;break test interrupt save
00000A  1  00           irq_a:  .res    1,0             ;a register
00000B  1  00           irq_x:  .res    1,0             ;x register
00000C  1                   .if I_flag = 2
00000C  1               ;masking for I bit in status
00000C  1               flag_I_on:  .res    1,0         ;or mask to load flags
00000C  1               flag_I_off: .res    1,0         ;and mask to load flags
00000C  1                   .endif
00000C  1               zpt:                        ;6 bytes store/modify test area
00000C  1               ;add/subtract operand generation and result/flag prediction
00000C  1  00           adfc:   .res    1,0             ;carry flag before op
00000D  1  00           ad1:    .res    1,0             ;operand 1 - accumulator
00000E  1  00           ad2:    .res    1,0             ;operand 2 - memory / immediate
00000F  1  00           adrl:   .res    1,0             ;expected result bits 0-7
000010  1  00           adrh:   .res    1,0             ;expected result bit 8 (carry)
000011  1  00           adrf:   .res    1,0             ;expected flags NV0000ZC (only binary mode)
000012  1  00           sb2:    .res    1,0             ;operand 2 complemented for subtract
000013  1               zp_bss:
000013  1  80 01        zps:    .byte   $80,1           ;additional shift pattern to test zero result & flag
000015  1  C3 82 41 00  zp1:    .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
000019  1  7F           zp7f:   .byte   $7f             ;test pattern for compare
00001A  1               ;logical zeropage operands
00001A  1  00 1F 71 80  zpOR:   .byte   0,$1f,$71,$80   ;test pattern for OR
00001E  1  0F FF 7F 80  zpAN:   .byte   $0f,$ff,$7f,$80 ;test pattern for AND
000022  1  FF 0F 8F 8F  zpEO:   .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
000026  1               ;indirect addressing pointers
000026  1  18 02        ind1:   .word   abs1            ;indirect pointer to pattern in absolute memory
000028  1  19 02                .word   abs1+1
00002A  1  1A 02                .word   abs1+2
00002C  1  1B 02                .word   abs1+3
00002E  1  1C 02                .word   abs7f
000030  1  20 01        inw1:   .word   abs1-$f8        ;indirect pointer for wrap-test pattern
000032  1  03 02        indt:   .word   abst            ;indirect pointer to store area in absolute memory
000034  1  04 02                .word   abst+1
000036  1  05 02                .word   abst+2
000038  1  06 02                .word   abst+3
00003A  1  0B 01        inwt:   .word   abst-$f8        ;indirect pointer for wrap-test store
00003C  1  5F 02        indAN:  .word   absAN           ;indirect pointer to AND pattern in absolute memory
00003E  1  60 02                .word   absAN+1
000040  1  61 02                .word   absAN+2
000042  1  62 02                .word   absAN+3
000044  1  63 02        indEO:  .word   absEO           ;indirect pointer to EOR pattern in absolute memory
000046  1  64 02                .word   absEO+1
000048  1  65 02                .word   absEO+2
00004A  1  66 02                .word   absEO+3
00004C  1  5B 02        indOR:  .word   absOR           ;indirect pointer to OR pattern in absolute memory
00004E  1  5C 02                .word   absOR+1
000050  1  5D 02                .word   absOR+2
000052  1  5E 02                .word   absOR+3
000054  1               ;add/subtract indirect pointers
000054  1  03 02        adi2:   .word   ada2            ;indirect pointer to operand 2 in absolute memory
000056  1  04 02        sbi2:   .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
000058  1  04 01        adiy2:  .word   ada2-$ff        ;with offset for indirect indexed
00005A  1  05 01        sbiy2:  .word   sba2-$ff
00005C  1               zp_bss_end:
00005C  1               
00005C  1                       .DATA
00005C  1                       .org data_segment
000200  1               
000200  1  00           test_case:  .res    1,0         ;current test number
000201  1  00 00        ram_chksm:  .res    2,0         ;checksum for RAM integrity test
000203  1               ;add/subtract operand copy - abs tests write area
000203  1               abst:                           ;6 bytes store/modify test area
000203  1  00           ada2:   .res    1,0             ;operand 2
000204  1  00           sba2:   .res    1,0             ;operand 2 complemented for subtract
000205  1  00 00 00 00          .res    4,0             ;fill remaining bytes
000209  1               data_bss:
000209  1                   .if load_data_direct = 1
000209  1  29 00        ex_andi:and #0              ;execute immediate opcodes
00020B  1  60                   rts
00020C  1  49 00        ex_eori:eor #0              ;execute immediate opcodes
00020E  1  60                   rts
00020F  1  09 00        ex_orai:ora #0              ;execute immediate opcodes
000211  1  60                   rts
000212  1  69 00        ex_adci:adc #0              ;execute immediate opcodes
000214  1  60                   rts
000215  1  E9 00        ex_sbci:sbc #0              ;execute immediate opcodes
000217  1  60                   rts
000218  1                   .else
000218  1               ex_andi:.res    3
000218  1               ex_eori:.res    3
000218  1               ex_orai:.res    3
000218  1               ex_adci:.res    3
000218  1               ex_sbci:.res    3
000218  1                   .endif
000218  1               ;zps    .byte   $80,1           ;additional shift patterns test zero result & flag
000218  1  C3 82 41 00  abs1:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
00021C  1  7F           abs7f:  .byte   $7f             ;test pattern for compare
00021D  1               ;loads
00021D  1  80 80 00 02  fLDx:   .byte   fn,fn,0,fz              ;expected flags for load
000221  1               ;shifts
000221  1               rASL:                                   ;expected result ASL & ROL -carry
000221  1  00 02 86 04  rROL:   .byte   0,2,$86,$04,$82,0
000225  1  82 00        
000227  1  01 03 87 05  rROLc:  .byte   1,3,$87,$05,$83,1       ;expected result ROL +carry
00022B  1  83 01        
00022D  1               rLSR:                                   ;expected result LSR & ROR -carry
00022D  1  40 00 61 41  rROR:   .byte   $40,0,$61,$41,$20,0
000231  1  20 00        
000233  1  C0 80 E1 C1  rRORc:  .byte   $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
000237  1  A0 80        
000239  1               fASL:                                   ;expected flags for shifts
000239  1  03 00 81 01  fROL:   .byte   fzc,0,fnc,fc,fn,fz      ;no carry in
00023D  1  80 02        
00023F  1  01 00 81 01  fROLc:  .byte   fc,0,fnc,fc,fn,0        ;carry in
000243  1  80 00        
000245  1               fLSR:
000245  1  00 03 01 00  fROR:   .byte   0,fzc,fc,0,fc,fz        ;no carry in
000249  1  01 02        
00024B  1  80 81 81 80  fRORc:  .byte   fn,fnc,fnc,fn,fnc,fn    ;carry in
00024F  1  81 80        
000251  1               ;increments (decrements)
000251  1  7F 80 FF 00  rINC:   .byte   $7f,$80,$ff,0,1         ;expected result for INC/DEC
000255  1  01           
000256  1  00 80 80 02  fINC:   .byte   0,fn,fn,fz,0            ;expected flags for INC/DEC
00025A  1  00           
00025B  1               ;logical memory operand
00025B  1  00 1F 71 80  absOR:  .byte   0,$1f,$71,$80           ;test pattern for OR
00025F  1  0F FF 7F 80  absAN:  .byte   $0f,$ff,$7f,$80         ;test pattern for AND
000263  1  FF 0F 8F 8F  absEO:  .byte   $ff,$0f,$8f,$8f         ;test pattern for EOR
000267  1               ;logical accu operand
000267  1  00 F1 1F 00  absORa: .byte   0,$f1,$1f,0             ;test pattern for OR
00026B  1  F0 FF FF FF  absANa: .byte   $f0,$ff,$ff,$ff         ;test pattern for AND
00026F  1  FF F0 F0 0F  absEOa: .byte   $ff,$f0,$f0,$0f         ;test pattern for EOR
000273  1               ;logical results
000273  1  00 FF 7F 80  absrlo: .byte   0,$ff,$7f,$80
000277  1  02 80 00 80  absflo: .byte   fz,fn,0,fn
00027B  1               data_bss_end:
00027B  1               
00027B  1               
00027B  1                       .CODE
00027B  1                       .org code_segment
000400  1                       .P02            ; disable 65SC02, 65C02 and 65816 instructions
000400  1  D8           start:  cld
000401  1  A2 FF                ldx #$ff
000403  1  9A                   txs
000404  1  A9 00                lda #0          ;*** test 0 = initialize
000406  1  8D 00 02             sta test_case
000409  1               test_num .set 0
000409  1               
000409  1               ;stop interrupts before initializing BSS
000409  1                   .if I_flag = 1
000409  1                       sei
000409  1                   .endif
000409  1               
000409  1               ;initialize I/O for report channel
000409  1                   .if report = 1
000409  1  20 F0 42             jsr report_init
00040C  1                   .endif
00040C  1               
00040C  1               ;pretest small branch offset
00040C  1  A2 05                ldx #5
00040E  1  4C 36 04             jmp psb_test
000411  1               psb_bwok:
000411  1  A0 05                ldy #5
000413  1  D0 08                bne psb_forw
000415  1  20 FF 42             trap        ;branch should be taken
000418  1  88                   dey         ;forward landing zone
000419  1  88                   dey
00041A  1  88                   dey
00041B  1  88                   dey
00041C  1  88                   dey
00041D  1               psb_forw:
00041D  1  88                   dey
00041E  1  88                   dey
00041F  1  88                   dey
000420  1  88                   dey
000421  1  88                   dey
000422  1  F0 17                beq psb_fwok
000424  1  20 FF 42             trap        ;forward offset
000427  1               
000427  1  CA                   dex         ;backward landing zone
000428  1  CA                   dex
000429  1  CA                   dex
00042A  1  CA                   dex
00042B  1  CA                   dex
00042C  1               psb_back:
00042C  1  CA                   dex
00042D  1  CA                   dex
00042E  1  CA                   dex
00042F  1  CA                   dex
000430  1  CA                   dex
000431  1  F0 DE                beq psb_bwok
000433  1  20 FF 42             trap        ;backward offset
000436  1               psb_test:
000436  1  D0 F4                bne psb_back
000438  1  20 FF 42             trap        ;branch should be taken
00043B  1               psb_fwok:
00043B  1               
00043B  1               ;initialize BSS segment
00043B  1                   .if load_data_direct <> 1
00043B  1                       ldx #zp_end-zp_init-1
00043B  1               ld_zp:  lda zp_init,x
00043B  1                       sta zp_bss,x
00043B  1                       dex
00043B  1                       bpl ld_zp
00043B  1                       ldx #data_end-data_init-1
00043B  1               ld_data:lda data_init,x
00043B  1                       sta data_bss,x
00043B  1                       dex
00043B  1                       bpl ld_data
00043B  1                     .if ROM_vectors = 1
00043B  1                       ldx #5
00043B  1               ld_vect:lda vec_init,x
00043B  1                       sta vec_bss,x
00043B  1                       dex
00043B  1                       bpl ld_vect
00043B  1                     .endif
00043B  1                   .endif
00043B  1               
00043B  1               ;retain status of interrupt flag
00043B  1                   .if I_flag = 2
00043B  1                       php
00043B  1                       pla
00043B  1                       and #4          ;isolate flag
00043B  1                       sta flag_I_on   ;or mask
00043B  1                       eor #lo(~4)     ;reverse
00043B  1                       sta flag_I_off  ;and mask
00043B  1                   .endif
00043B  1               
00043B  1               ;generate checksum for RAM integrity test
00043B  1                   .if ram_top > -1
00043B  1                       lda #0
00043B  1                       sta zpt         ;set low byte of indirect pointer
00043B  1                       sta ram_chksm+1 ;checksum high byte
00043B  1                     .if disable_selfmod = 0
00043B  1                       sta range_adr   ;reset self modifying code
00043B  1                     .endif
00043B  1                       clc
00043B  1                       ldx #zp_bss-zero_page ;zeropage - write test area
00043B  1               gcs3:   adc zero_page,x
00043B  1                       bcc gcs2
00043B  1                       inc ram_chksm+1 ;carry to high byte
00043B  1                       clc
00043B  1               gcs2:   inx
00043B  1                       bne gcs3
00043B  1                       ldx #hi(abs1)   ;set high byte of indirect pointer
00043B  1                       stx zpt+1
00043B  1                       ldy #lo(abs1)   ;data after write & execute test area
00043B  1               gcs5:   adc (zpt),y
00043B  1                       bcc gcs4
00043B  1                       inc ram_chksm+1 ;carry to high byte
00043B  1                       clc
00043B  1               gcs4:   iny
00043B  1                       bne gcs5
00043B  1                       inx             ;advance RAM high address
00043B  1                       stx zpt+1
00043B  1                       cpx #ram_top
00043B  1                       bne gcs5
00043B  1                       sta ram_chksm   ;checksum complete
00043B  1                   .endif
00043B  1  AD 00 02 C9          next_test
00043F  1  00 F0 03 20  
000443  1  FF 42 A9 01  
00044A  1               
00044A  1                   .if disable_selfmod = 0
00044A  1               ;testing relative addressing with BEQ
00044A  1                       ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
00044A  1               range_loop:
00044A  1                       dey             ;next relative address
00044A  1                       tya
00044A  1                       tax             ;precharge count to end of loop
00044A  1                       bpl range_fw    ;calculate relative address
00044A  1                       clc             ;avoid branch self or to relative address of branch
00044A  1                       adc #2
00044A  1                       nop             ;offset landing zone - tolerate +/-5 offset to branch
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1               range_fw:
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       eor #$7f        ;complement except sign
00044A  1                       sta range_adr   ;load into test target
00044A  1                       lda #0          ;should set zero flag in status register
00044A  1                       jmp range_op
00044A  1               
00044A  1                       dex             ; offset landing zone - backward branch too far
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       ;relative address target field with branch under test in the middle
00044A  1                       dex             ;-128 - max backward
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-120
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-110
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-100
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-90
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-80
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-70
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-60
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-50
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-40
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-30
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-20
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-10
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;-3
00044A  1               range_op:               ;test target with zero flag=0, z=1 if previous dex
00044A  1               range_adr   = *+1       ;modifiable relative address
00044A  1                       beq *+64        ;+64 if called without modification
00044A  1                       dex             ;+0
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+10
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+20
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+30
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+40
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+50
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+60
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+70
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+80
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+90
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+100
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+110
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex             ;+120
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       dex
00044A  1                       nop             ;offset landing zone - forward branch too far
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       beq range_ok    ;+127 - max forward
00044A  1                       trap            ; bad range
00044A  1                       nop             ;offset landing zone - tolerate +/-5 offset to branch
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1               range_ok:
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       nop
00044A  1                       cpy #0
00044A  1                       beq range_end
00044A  1                       jmp range_loop
00044A  1               range_end:              ;range test successful
00044A  1                   .endif
00044A  1  AD 00 02 C9          next_test
00044E  1  01 F0 03 20  
000452  1  FF 42 A9 02  
000459  1               
000459  1               ;partial test BNE & CMP, CPX, CPY immediate
000459  1  C0 01                cpy #1          ;testing BNE true
00045B  1  D0 03                bne test_bne
00045D  1  20 FF 42             trap
000460  1               test_bne:
000460  1  A9 00                lda #0
000462  1  C9 00                cmp #0          ;test compare immediate
000464  1  F0 03 20 FF          trap_ne
000468  1  42           
000469  1  B0 03 20 FF          trap_cc
00046D  1  42           
00046E  1  10 03 20 FF          trap_mi
000472  1  42           
000473  1  C9 01                cmp #1
000475  1  D0 03 20 FF          trap_eq
000479  1  42           
00047A  1  90 03 20 FF          trap_cs
00047E  1  42           
00047F  1  30 03 20 FF          trap_pl
000483  1  42           
000484  1  AA                   tax
000485  1  E0 00                cpx #0          ;test compare x immediate
000487  1  F0 03 20 FF          trap_ne
00048B  1  42           
00048C  1  B0 03 20 FF          trap_cc
000490  1  42           
000491  1  10 03 20 FF          trap_mi
000495  1  42           
000496  1  E0 01                cpx #1
000498  1  D0 03 20 FF          trap_eq
00049C  1  42           
00049D  1  90 03 20 FF          trap_cs
0004A1  1  42           
0004A2  1  30 03 20 FF          trap_pl
0004A6  1  42           
0004A7  1  A8                   tay
0004A8  1  C0 00                cpy #0          ;test compare y immediate
0004AA  1  F0 03 20 FF          trap_ne
0004AE  1  42           
0004AF  1  B0 03 20 FF          trap_cc
0004B3  1  42           
0004B4  1  10 03 20 FF          trap_mi
0004B8  1  42           
0004B9  1  C0 01                cpy #1
0004BB  1  D0 03 20 FF          trap_eq
0004BF  1  42           
0004C0  1  90 03 20 FF          trap_cs
0004C4  1  42           
0004C5  1  30 03 20 FF          trap_pl
0004C9  1  42           
0004CA  1  AD 00 02 C9          next_test
0004CE  1  02 F0 03 20  
0004D2  1  FF 42 A9 03  
0004D9  1               ;testing stack operations PHA PHP PLA PLP
0004D9  1               
0004D9  1  A2 FF                ldx #$ff        ;initialize stack
0004DB  1  9A                   txs
0004DC  1  A9 55                lda #$55
0004DE  1  48                   pha
0004DF  1  A9 AA                lda #$aa
0004E1  1  48                   pha
0004E2  1  CD FE 01             cmp $1fe        ;on stack ?
0004E5  1  F0 03 20 FF          trap_ne
0004E9  1  42           
0004EA  1  BA                   tsx
0004EB  1  8A                   txa             ;overwrite accu
0004EC  1  C9 FD                cmp #$fd        ;sp decremented?
0004EE  1  F0 03 20 FF          trap_ne
0004F2  1  42           
0004F3  1  68                   pla
0004F4  1  C9 AA                cmp #$aa        ;successful retreived from stack?
0004F6  1  F0 03 20 FF          trap_ne
0004FA  1  42           
0004FB  1  68                   pla
0004FC  1  C9 55                cmp #$55
0004FE  1  F0 03 20 FF          trap_ne
000502  1  42           
000503  1  CD FF 01             cmp $1ff        ;remains on stack?
000506  1  F0 03 20 FF          trap_ne
00050A  1  42           
00050B  1  BA                   tsx
00050C  1  E0 FF                cpx #$ff        ;sp incremented?
00050E  1  F0 03 20 FF          trap_ne
000512  1  42           
000513  1  AD 00 02 C9          next_test
000517  1  03 F0 03 20  
00051B  1  FF 42 A9 04  
000522  1               
000522  1               ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
000522  1  A9 FF 48 28          set_stat $ff    ;all on
000526  1  10 1A                bpl nbr1        ;branches should not be taken
000528  1  50 1B                bvc nbr2
00052A  1  90 1C                bcc nbr3
00052C  1  D0 1D                bne nbr4
00052E  1  30 03                bmi br1         ;branches should be taken
000530  1  20 FF 42             trap
000533  1  70 03        br1:    bvs br2
000535  1  20 FF 42             trap
000538  1  B0 03        br2:    bcs br3
00053A  1  20 FF 42             trap
00053D  1  F0 0F        br3:    beq br4
00053F  1  20 FF 42             trap
000542  1               nbr1:
000542  1  20 FF 42             trap            ;previous bpl taken
000545  1               nbr2:
000545  1  20 FF 42             trap            ;previous bvc taken
000548  1               nbr3:
000548  1  20 FF 42             trap            ;previous bcc taken
00054B  1               nbr4:
00054B  1  20 FF 42             trap            ;previous bne taken
00054E  1  08           br4:    php
00054F  1  BA                   tsx
000550  1  E0 FE                cpx #$fe        ;sp after php?
000552  1  F0 03 20 FF          trap_ne
000556  1  42           
000557  1  68                   pla
000558  1  C9 FF                cmp_flag $ff    ;returned all flags on?
00055A  1  F0 03 20 FF          trap_ne
00055E  1  42           
00055F  1  BA                   tsx
000560  1  E0 FF                cpx #$ff        ;sp after php?
000562  1  F0 03 20 FF          trap_ne
000566  1  42           
000567  1  A9 00 48 28          set_stat 0      ;all off
00056B  1  30 1A                bmi nbr11       ;branches should not be taken
00056D  1  70 1B                bvs nbr12
00056F  1  B0 1C                bcs nbr13
000571  1  F0 1D                beq nbr14
000573  1  10 03                bpl br11        ;branches should be taken
000575  1  20 FF 42             trap
000578  1  50 03        br11:   bvc br12
00057A  1  20 FF 42             trap
00057D  1  90 03        br12:   bcc br13
00057F  1  20 FF 42             trap
000582  1  D0 0F        br13:   bne br14
000584  1  20 FF 42             trap
000587  1               nbr11:
000587  1  20 FF 42             trap            ;previous bmi taken
00058A  1               nbr12:
00058A  1  20 FF 42             trap            ;previous bvs taken
00058D  1               nbr13:
00058D  1  20 FF 42             trap            ;previous bcs taken
000590  1               nbr14:
000590  1  20 FF 42             trap            ;previous beq taken
000593  1  08           br14:   php
000594  1  68                   pla
000595  1  C9 30                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
000597  1  F0 03 20 FF          trap_ne
00059B  1  42           
00059C  1                       ;crosscheck flags
00059C  1  A9 02 48 28          set_stat zero	; processor status = 00000000
0005A0  1  D0 02                bne brzs1	; not taken
0005A2  1  F0 03                beq brzs2	; taken
0005A4  1               brzs1:
0005A4  1  20 FF 42             trap            ;branch zero/non zero
0005A7  1  B0 02        brzs2:  bcs brzs3	; not taken
0005A9  1  90 03                bcc brzs4	; taken
0005AB  1               brzs3:
0005AB  1  20 FF 42             trap            ;branch carry/no carry
0005AE  1  30 02        brzs4:  bmi brzs5	; not taken
0005B0  1  10 03                bpl brzs6	; taken
0005B2  1               brzs5:
0005B2  1  20 FF 42             trap            ;branch minus/plus
0005B5  1  70 02        brzs6:  bvs brzs7	; not taken
0005B7  1  50 03                bvc brzs8	; taken
0005B9  1               brzs7:
0005B9  1  20 FF 42             trap            ;branch overflow/no overflow
0005BC  1               brzs8:
0005BC  1  A9 01 48 28          set_stat carry	; processor status = 00000001
0005C0  1  F0 02                beq brcs1	; not taken
0005C2  1  D0 03                bne brcs2	; taken
0005C4  1               brcs1:
0005C4  1  20 FF 42             trap            ;branch zero/non zero
0005C7  1  90 02        brcs2:  bcc brcs3	; not taken
0005C9  1  B0 03                bcs brcs4	; taken
0005CB  1               brcs3:
0005CB  1  20 FF 42             trap            ;branch carry/no carry
0005CE  1  30 02        brcs4:  bmi brcs5	; not taken
0005D0  1  10 03                bpl brcs6	; taken
0005D2  1               brcs5:
0005D2  1  20 FF 42             trap            ;branch minus/plus
0005D5  1  70 02        brcs6:  bvs brcs7	; not taken
0005D7  1  50 03                bvc brcs8	; taken
0005D9  1               brcs7:
0005D9  1  20 FF 42             trap            ;branch overflow/no overflow
0005DC  1               
0005DC  1               brcs8:
0005DC  1  A9 80 48 28          set_stat minus	; processor status = 10000000
0005E0  1  F0 02                beq brmi1	; not taken
0005E2  1  D0 03                bne brmi2	; taken
0005E4  1               brmi1:
0005E4  1  20 FF 42             trap            ;branch zero/non zero
0005E7  1  B0 02        brmi2:  bcs brmi3	; not taken
0005E9  1  90 03                bcc brmi4	; taken
0005EB  1               brmi3:
0005EB  1  20 FF 42             trap            ;branch carry/no carry
0005EE  1  10 02        brmi4:  bpl brmi5	; not taken
0005F0  1  30 03                bmi brmi6	; taken
0005F2  1               brmi5:
0005F2  1  20 FF 42             trap            ;branch minus/plus
0005F5  1  70 02        brmi6:  bvs brmi7	; not taken
0005F7  1  50 03                bvc brmi8	; taken
0005F9  1               brmi7:
0005F9  1  20 FF 42             trap            ;branch overflow/no overflow
0005FC  1               brmi8:
0005FC  1  A9 40 48 28          set_stat overfl	; processor status = 01000000
000600  1  F0 02                beq brvs1	; not taken
000602  1  D0 03                bne brvs2	; taken
000604  1               brvs1:
000604  1  20 FF 42             trap            ;branch zero/non zero
000607  1  B0 02        brvs2:  bcs brvs3	; not taken
000609  1  90 03                bcc brvs4	; taken
00060B  1               brvs3:
00060B  1  20 FF 42             trap            ;branch carry/no carry
00060E  1  30 02        brvs4:  bmi brvs5	; not taken
000610  1  10 03                bpl brvs6	; taken
000612  1               brvs5:
000612  1  20 FF 42             trap            ;branch minus/plus
000615  1  50 02        brvs6:  bvc brvs7	; not taken
000617  1  70 03                bvs brvs8	; taken
000619  1               brvs7:
000619  1  20 FF 42             trap            ;branch overflow/no overflow
00061C  1               brvs8:
00061C  1  A9 FD 48 28          set_stat $ff-zero ;processor status = 11111101
000620  1  F0 02                beq brzc1	; not taken
000622  1  D0 03                bne brzc2	; taken
000624  1               brzc1:
000624  1  20 FF 42             trap            ;branch zero/non zero
000627  1  90 02        brzc2:  bcc brzc3	; not taken
000629  1  B0 03                bcs brzc4	; taken
00062B  1               brzc3:
00062B  1  20 FF 42             trap            ;branch carry/no carry
00062E  1  10 02        brzc4:  bpl brzc5
000630  1  30 03                bmi brzc6
000632  1               brzc5:
000632  1  20 FF 42             trap            ;branch minus/plus
000635  1  50 02        brzc6:  bvc brzc7
000637  1  70 03                bvs brzc8
000639  1               brzc7:
000639  1  20 FF 42             trap            ;branch overflow/no overflow
00063C  1               brzc8:
00063C  1  A9 FE 48 28          set_stat $ff-carry ; processor status = 11111110
000640  1  D0 02                bne brcc1
000642  1  F0 03                beq brcc2
000644  1               brcc1:
000644  1  20 FF 42             trap            ;branch zero/non zero
000647  1  B0 02        brcc2:  bcs brcc3
000649  1  90 03                bcc brcc4
00064B  1               brcc3:
00064B  1  20 FF 42             trap            ;branch carry/no carry
00064E  1  10 02        brcc4:  bpl brcc5
000650  1  30 03                bmi brcc6
000652  1               brcc5:
000652  1  20 FF 42             trap            ;branch minus/plus
000655  1  50 02        brcc6:  bvc brcc7
000657  1  70 03                bvs brcc8
000659  1               brcc7:
000659  1  20 FF 42             trap            ;branch overflow/no overflow
00065C  1               brcc8:
00065C  1  A9 7F 48 28          set_stat $ff-minus ; processor status = 01111111
000660  1  D0 02                bne brpl1
000662  1  F0 03                beq brpl2
000664  1               brpl1:
000664  1  20 FF 42             trap            ;branch zero/non zero
000667  1  90 02        brpl2:  bcc brpl3
000669  1  B0 03                bcs brpl4
00066B  1               brpl3:
00066B  1  20 FF 42             trap            ;branch carry/no carry
00066E  1  30 02        brpl4:  bmi brpl5
000670  1  10 03                bpl brpl6
000672  1               brpl5:
000672  1  20 FF 42             trap            ;branch minus/plus
000675  1  50 02        brpl6:  bvc brpl7
000677  1  70 03                bvs brpl8
000679  1               brpl7:
000679  1  20 FF 42             trap            ;branch overflow/no overflow
00067C  1               brpl8:
00067C  1  A9 BF 48 28          set_stat $ff-overfl ; processor status = 10111111
000680  1  D0 02                bne brvc1
000682  1  F0 03                beq brvc2
000684  1               brvc1:
000684  1  20 FF 42             trap            ;branch zero/non zero
000687  1  90 02        brvc2:  bcc brvc3
000689  1  B0 03                bcs brvc4
00068B  1               brvc3:
00068B  1  20 FF 42             trap            ;branch carry/no carry
00068E  1  10 02        brvc4:  bpl brvc5
000690  1  30 03                bmi brvc6
000692  1               brvc5:
000692  1  20 FF 42             trap            ;branch minus/plus
000695  1  70 02        brvc6:  bvs brvc7
000697  1  50 03                bvc brvc8
000699  1               brvc7:
000699  1  20 FF 42             trap            ;branch overflow/no overflow
00069C  1               brvc8:
00069C  1  AD 00 02 C9          next_test
0006A0  1  04 F0 03 20  
0006A4  1  FF 42 A9 05  
0006AB  1               
0006AB  1               ; test PHA does not alter flags or accumulator but PLA does
0006AB  1  A2 55                ldx #$55        ;x & y protected
0006AD  1  A0 AA                ldy #$aa
0006AF  1  A9 FF 48 A9          set_a 1,$ff     ;push
0006B3  1  01 28        
0006B5  1  48                   pha
0006B6  1  08 C9 01 F0          tst_a 1,$ff
0006BA  1  03 20 FF 42  
0006BE  1  68 48 C9 FF  
0006C8  1  A9 00 48 A9          set_a 0,0
0006CC  1  00 28        
0006CE  1  48                   pha
0006CF  1  08 C9 00 F0          tst_a 0,0
0006D3  1  03 20 FF 42  
0006D7  1  68 48 C9 30  
0006E1  1  A9 FF 48 A9          set_a $ff,$ff
0006E5  1  FF 28        
0006E7  1  48                   pha
0006E8  1  08 C9 FF F0          tst_a $ff,$ff
0006EC  1  03 20 FF 42  
0006F0  1  68 48 C9 FF  
0006FA  1  A9 00 48 A9          set_a 1,0
0006FE  1  01 28        
000700  1  48                   pha
000701  1  08 C9 01 F0          tst_a 1,0
000705  1  03 20 FF 42  
000709  1  68 48 C9 30  
000713  1  A9 FF 48 A9          set_a 0,$ff
000717  1  00 28        
000719  1  48                   pha
00071A  1  08 C9 00 F0          tst_a 0,$ff
00071E  1  03 20 FF 42  
000722  1  68 48 C9 FF  
00072C  1  A9 00 48 A9          set_a $ff,0
000730  1  FF 28        
000732  1  48                   pha
000733  1  08 C9 FF F0          tst_a $ff,0
000737  1  03 20 FF 42  
00073B  1  68 48 C9 30  
000745  1  A9 FF 48 A9          set_a 0,$ff     ;pull
000749  1  00 28        
00074B  1  68                   pla
00074C  1  08 C9 FF F0          tst_a $ff,$ff-zero
000750  1  03 20 FF 42  
000754  1  68 48 C9 FD  
00075E  1  A9 00 48 A9          set_a $ff,0
000762  1  FF 28        
000764  1  68                   pla
000765  1  08 C9 00 F0          tst_a 0,zero
000769  1  03 20 FF 42  
00076D  1  68 48 C9 32  
000777  1  A9 FF 48 A9          set_a $fe,$ff
00077B  1  FE 28        
00077D  1  68                   pla
00077E  1  08 C9 01 F0          tst_a 1,$ff-zero-minus
000782  1  03 20 FF 42  
000786  1  68 48 C9 7D  
000790  1  A9 00 48 A9          set_a 0,0
000794  1  00 28        
000796  1  68                   pla
000797  1  08 C9 FF F0          tst_a $ff,minus
00079B  1  03 20 FF 42  
00079F  1  68 48 C9 B0  
0007A9  1  A9 FF 48 A9          set_a $ff,$ff
0007AD  1  FF 28        
0007AF  1  68                   pla
0007B0  1  08 C9 00 F0          tst_a 0,$ff-minus
0007B4  1  03 20 FF 42  
0007B8  1  68 48 C9 7F  
0007C2  1  A9 00 48 A9          set_a $fe,0
0007C6  1  FE 28        
0007C8  1  68                   pla
0007C9  1  08 C9 01 F0          tst_a 1,0
0007CD  1  03 20 FF 42  
0007D1  1  68 48 C9 30  
0007DB  1  E0 55                cpx #$55        ;x & y unchanged?
0007DD  1  F0 03 20 FF          trap_ne
0007E1  1  42           
0007E2  1  C0 AA                cpy #$aa
0007E4  1  F0 03 20 FF          trap_ne
0007E8  1  42           
0007E9  1  AD 00 02 C9          next_test
0007ED  1  05 F0 03 20  
0007F1  1  FF 42 A9 06  
0007F8  1               
0007F8  1               ; partial pretest EOR #
0007F8  1  A9 00 48 A9          set_a $3c,0
0007FC  1  3C 28        
0007FE  1  49 C3                eor #$c3
000800  1  08 C9 FF F0          tst_a $ff,fn
000804  1  03 20 FF 42  
000808  1  68 48 C9 B0  
000812  1  A9 00 48 A9          set_a $c3,0
000816  1  C3 28        
000818  1  49 C3                eor #$c3
00081A  1  08 C9 00 F0          tst_a 0,fz
00081E  1  03 20 FF 42  
000822  1  68 48 C9 32  
00082C  1  AD 00 02 C9          next_test
000830  1  06 F0 03 20  
000834  1  FF 42 A9 07  
00083B  1               
00083B  1               ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
00083B  1               ; testing NOP
00083B  1  A2 24                ldx #$24
00083D  1  A0 42                ldy #$42
00083F  1  A9 00 48 A9          set_a $18,0
000843  1  18 28        
000845  1  EA                   nop
000846  1  08 C9 18 F0          tst_a $18,0
00084A  1  03 20 FF 42  
00084E  1  68 48 C9 30  
000858  1  E0 24                cpx #$24
00085A  1  F0 03 20 FF          trap_ne
00085E  1  42           
00085F  1  C0 42                cpy #$42
000861  1  F0 03 20 FF          trap_ne
000865  1  42           
000866  1  A2 DB                ldx #$db
000868  1  A0 BD                ldy #$bd
00086A  1  A9 FF 48 A9          set_a $e7,$ff
00086E  1  E7 28        
000870  1  EA                   nop
000871  1  08 C9 E7 F0          tst_a $e7,$ff
000875  1  03 20 FF 42  
000879  1  68 48 C9 FF  
000883  1  E0 DB                cpx #$db
000885  1  F0 03 20 FF          trap_ne
000889  1  42           
00088A  1  C0 BD                cpy #$bd
00088C  1  F0 03 20 FF          trap_ne
000890  1  42           
000891  1  AD 00 02 C9          next_test
000895  1  07 F0 03 20  
000899  1  FF 42 A9 08  
0008A0  1               
0008A0  1               ; jump absolute
0008A0  1  A9 00 48 28          set_stat $0
0008A4  1  A9 46                lda #'F'
0008A6  1  A2 41                ldx #'A'
0008A8  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
0008AA  1  4C 3B 41             jmp test_far
0008AD  1  EA                   nop
0008AE  1  EA                   nop
0008AF  1  F0 03 20 FF          trap_ne         ;runover protection
0008B3  1  42           
0008B4  1  E8                   inx
0008B5  1  E8                   inx
0008B6  1               far_ret:
0008B6  1  D0 03 20 FF          trap_eq         ;returned flags OK?
0008BA  1  42           
0008BB  1  30 03 20 FF          trap_pl
0008BF  1  42           
0008C0  1  B0 03 20 FF          trap_cc
0008C4  1  42           
0008C5  1  70 03 20 FF          trap_vc
0008C9  1  42           
0008CA  1  C9 EC                cmp #('F'^$aa)  ;returned registers OK?
0008CC  1  F0 03 20 FF          trap_ne
0008D0  1  42           
0008D1  1  E0 42                cpx #('A'+1)
0008D3  1  F0 03 20 FF          trap_ne
0008D7  1  42           
0008D8  1  C0 4F                cpy #('R'-3)
0008DA  1  F0 03 20 FF          trap_ne
0008DE  1  42           
0008DF  1  CA                   dex
0008E0  1  C8                   iny
0008E1  1  C8                   iny
0008E2  1  C8                   iny
0008E3  1  49 AA                eor #$aa        ;N=0, V=1, Z=0, C=1
0008E5  1  4C F1 08             jmp test_near
0008E8  1  EA                   nop
0008E9  1  EA                   nop
0008EA  1  F0 03 20 FF          trap_ne         ;runover protection
0008EE  1  42           
0008EF  1  E8                   inx
0008F0  1  E8                   inx
0008F1  1               test_near:
0008F1  1  D0 03 20 FF          trap_eq         ;passed flags OK?
0008F5  1  42           
0008F6  1  10 03 20 FF          trap_mi
0008FA  1  42           
0008FB  1  B0 03 20 FF          trap_cc
0008FF  1  42           
000900  1  70 03 20 FF          trap_vc
000904  1  42           
000905  1  C9 46                cmp #'F'        ;passed registers OK?
000907  1  F0 03 20 FF          trap_ne
00090B  1  42           
00090C  1  E0 41                cpx #'A'
00090E  1  F0 03 20 FF          trap_ne
000912  1  42           
000913  1  C0 52                cpy #'R'
000915  1  F0 03 20 FF          trap_ne
000919  1  42           
00091A  1  AD 00 02 C9          next_test
00091E  1  08 F0 03 20  
000922  1  FF 42 A9 09  
000929  1               
000929  1               ; jump indirect
000929  1  A9 00 48 28          set_stat 0
00092D  1  A9 49                lda #'I'	; $92d
00092F  1  A2 4E                ldx #'N'
000931  1  A0 44                ldy #'D'        ;N=0, V=0, Z=0, C=0
000933  1  6C 82 41             jmp (ptr_tst_ind)
000936  1  EA                   nop
000937  1  F0 03 20 FF          trap_ne         ;runover protection
00093B  1  42           
00093C  1  88                   dey
00093D  1  88                   dey
00093E  1               ind_ret:
00093E  1  08                   php             ;either SP or Y count will fail, if we do not hit
00093F  1  88                   dey
000940  1  88                   dey
000941  1  88                   dey
000942  1  28                   plp
000943  1  D0 03 20 FF          trap_eq         ;returned flags OK?
000947  1  42           
000948  1  30 03 20 FF          trap_pl
00094C  1  42           
00094D  1  B0 03 20 FF          trap_cc
000951  1  42           
000952  1  70 03 20 FF          trap_vc
000956  1  42           
000957  1  C9 E3                cmp #('I'^$aa)  ;returned registers OK?
000959  1  F0 03 20 FF          trap_ne
00095D  1  42           
00095E  1  E0 4F                cpx #('N'+1)
000960  1  F0 03 20 FF          trap_ne
000964  1  42           
000965  1  C0 3E                cpy #('D'-6)
000967  1  F0 03 20 FF          trap_ne
00096B  1  42           
00096C  1  BA                   tsx             ;SP check
00096D  1  E0 FF                cpx #$ff
00096F  1  F0 03 20 FF          trap_ne
000973  1  42           
000974  1  AD 00 02 C9          next_test
000978  1  09 F0 03 20  
00097C  1  FF 42 A9 0A  
000983  1               
000983  1               ; jump subroutine & return from subroutine
000983  1  A9 00 48 28          set_stat 0
000987  1  A9 4A                lda #'J'	; $987
000989  1  A2 53                ldx #'S'
00098B  1  A0 52                ldy #'R'        ;N=0, V=0, Z=0, C=0
00098D  1  20 D9 41             jsr test_jsr
000990  1               jsr_ret = *-1           ;last address of jsr = return address
000990  1  08                   php             ;either SP or Y count will fail, if we do not hit
000991  1  88                   dey
000992  1  88                   dey
000993  1  88                   dey
000994  1  28                   plp
000995  1  D0 03 20 FF          trap_eq         ;returned flags OK?
000999  1  42           
00099A  1  30 03 20 FF          trap_pl
00099E  1  42           
00099F  1  B0 03 20 FF          trap_cc
0009A3  1  42           
0009A4  1  70 03 20 FF          trap_vc
0009A8  1  42           
0009A9  1  C9 E0                cmp #('J'^$aa)  ;returned registers OK?
0009AB  1  F0 03 20 FF          trap_ne
0009AF  1  42           
0009B0  1  E0 54                cpx #('S'+1)
0009B2  1  F0 03 20 FF          trap_ne
0009B6  1  42           
0009B7  1  C0 4C                cpy #('R'-6)
0009B9  1  F0 03 20 FF          trap_ne
0009BD  1  42           
0009BE  1  BA                   tsx             ;sp?
0009BF  1  E0 FF                cpx #$ff
0009C1  1  F0 03 20 FF          trap_ne
0009C5  1  42           
0009C6  1  AD 00 02 C9          next_test
0009CA  1  0A F0 03 20  
0009CE  1  FF 42 A9 0B  
0009D5  1               
0009D5  1               ; break & return from interrupt
0009D5  1                   .if ROM_vectors = 1
0009D5  1  A9 00                load_flag 0     ;with interrupts enabled if allowed!
0009D7  1  48                   pha		; $9d7
0009D8  1  A9 42                lda #'B'
0009DA  1  A2 52                ldx #'R'
0009DC  1  A0 4B                ldy #'K'
0009DE  1  28                   plp             ;N=0, V=0, Z=0, C=0
0009DF  1  00                   brk
0009E0  1                   .else
0009E0  1                       lda #>brk_ret0 ;emulated break
0009E0  1                       pha
0009E0  1                       lda #<brk_ret0
0009E0  1                       pha
0009E0  1                       load_flag fao    ;set break & unused on stack
0009E0  1                       pha
0009E0  1                       load_flag intdis ;during interrupt
0009E0  1                       pha
0009E0  1                       lda #'B'
0009E0  1                       ldx #'R'
0009E0  1                       ldy #'K'
0009E0  1                       plp             ;N=0, V=0, Z=0, C=0
0009E0  1                       jmp irq_trap
0009E0  1                   .endif
0009E0  1  88                   dey             ;should not be executed
0009E1  1               brk_ret0:               ;address of break return
0009E1  1  08                   php             ;either SP or Y count will fail, if we do not hit
0009E2  1  88                   dey		; $9e2
0009E3  1  88                   dey		; $9e3
0009E4  1  88                   dey		; $9e4
0009E5  1  C9 E8                cmp #'B'^$aa    ;returned registers OK?
0009E7  1                       ;the IRQ vector was never executed if A & X stay unmodified
0009E7  1  F0 03 20 FF          trap_ne
0009EB  1  42           
0009EC  1  E0 53                cpx #'R'+1
0009EE  1  F0 03 20 FF          trap_ne
0009F2  1  42           
0009F3  1  C0 45                cpy #'K'-6
0009F5  1  F0 03 20 FF          trap_ne
0009F9  1  42           
0009FA  1  68                   pla             ;returned flags OK (unchanged)?
0009FB  1  C9 30                cmp_flag 0
0009FD  1  F0 03 20 FF          trap_ne
000A01  1  42           
000A02  1  BA                   tsx             ;sp?
000A03  1  E0 FF                cpx #$ff
000A05  1  F0 03 20 FF          trap_ne
000A09  1  42           
000A0A  1                   .if ROM_vectors = 1
000A0A  1  A9 FF                load_flag $ff   ;with interrupts disabled if allowed!
000A0C  1  48                   pha
000A0D  1  A9 BD                lda #$ff-'B'
000A0F  1  A2 AD                ldx #$ff-'R'
000A11  1  A0 B4                ldy #$ff-'K'
000A13  1  28                   plp             ;N=1, V=1, Z=1, C=1
000A14  1  00                   brk
000A15  1                   .else
000A15  1                       lda #>brk_ret1 ;emulated break
000A15  1                       pha
000A15  1                       lda #<brk_ret1
000A15  1                       pha
000A15  1                       load_flag $ff
000A15  1                       pha             ;set break & unused on stack
000A15  1                       pha             ;actual flags
000A15  1                       lda #$ff-'B'
000A15  1                       ldx #$ff-'R'
000A15  1                       ldy #$ff-'K'
000A15  1                       plp             ;N=1, V=1, Z=1, C=1
000A15  1                       jmp irq_trap
000A15  1                   .endif
000A15  1  88                   dey             ;should not be executed
000A16  1               brk_ret1:               ;address of break return
000A16  1  08                   php             ;either SP or Y count will fail, if we do not hit
000A17  1  88                   dey		; $a17
000A18  1  88                   dey		; $a18
000A19  1  88                   dey		; $a19
000A1A  1  C9 17                cmp #($ff-'B')^$aa  ;returned registers OK? (0x17)
000A1C  1                       ;the IRQ vector was never executed if A & X stay unmodified
000A1C  1  F0 03 20 FF          trap_ne
000A20  1  42           
000A21  1  E0 AE                cpx #$ff-'R'+1
000A23  1  F0 03 20 FF          trap_ne
000A27  1  42           
000A28  1  C0 AE                cpy #$ff-'K'-6
000A2A  1  F0 03 20 FF          trap_ne
000A2E  1  42           
000A2F  1  68                   pla             ;returned flags OK (unchanged)?
000A30  1  C9 FF                cmp_flag $ff
000A32  1  F0 03 20 FF          trap_ne
000A36  1  42           
000A37  1  BA                   tsx             ;sp?
000A38  1  E0 FF                cpx #$ff
000A3A  1  F0 03 20 FF          trap_ne
000A3E  1  42           
000A3F  1  AD 00 02 C9          next_test
000A43  1  0B F0 03 20  
000A47  1  FF 42 A9 0C  
000A4E  1               
000A4E  1               ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
000A4E  1  A9 FF 48 28          set_stat $ff
000A52  1  18                   clc
000A53  1  08 68 48 C9          tst_stat $ff-carry
000A57  1  FE F0 03 20  
000A5B  1  FF 42 28     
000A5E  1  38                   sec
000A5F  1  08 68 48 C9          tst_stat $ff
000A63  1  FF F0 03 20  
000A67  1  FF 42 28     
000A6A  1                   .if I_flag = 3
000A6A  1  58                   cli
000A6B  1  08 68 48 C9          tst_stat $ff-intdis
000A6F  1  FB F0 03 20  
000A73  1  FF 42 28     
000A76  1  78                   sei
000A77  1  08 68 48 C9          tst_stat $ff
000A7B  1  FF F0 03 20  
000A7F  1  FF 42 28     
000A82  1                   .endif
000A82  1  D8                   cld
000A83  1  08 68 48 C9          tst_stat $ff-decmode
000A87  1  F7 F0 03 20  
000A8B  1  FF 42 28     
000A8E  1  F8                   sed
000A8F  1  08 68 48 C9          tst_stat $ff
000A93  1  FF F0 03 20  
000A97  1  FF 42 28     
000A9A  1  B8                   clv
000A9B  1  08 68 48 C9          tst_stat $ff-overfl
000A9F  1  BF F0 03 20  
000AA3  1  FF 42 28     
000AA6  1  A9 00 48 28          set_stat 0
000AAA  1  08 68 48 C9          tst_stat 0
000AAE  1  30 F0 03 20  
000AB2  1  FF 42 28     
000AB5  1  38                   sec
000AB6  1  08 68 48 C9          tst_stat carry
000ABA  1  31 F0 03 20  
000ABE  1  FF 42 28     
000AC1  1  18                   clc
000AC2  1  08 68 48 C9          tst_stat 0
000AC6  1  30 F0 03 20  
000ACA  1  FF 42 28     
000ACD  1                   .if I_flag = 3
000ACD  1  78                   sei
000ACE  1  08 68 48 C9          tst_stat intdis
000AD2  1  34 F0 03 20  
000AD6  1  FF 42 28     
000AD9  1  58                   cli
000ADA  1  08 68 48 C9          tst_stat 0
000ADE  1  30 F0 03 20  
000AE2  1  FF 42 28     
000AE5  1                   .endif
000AE5  1  F8                   sed
000AE6  1  08 68 48 C9          tst_stat decmode
000AEA  1  38 F0 03 20  
000AEE  1  FF 42 28     
000AF1  1  D8                   cld
000AF2  1  08 68 48 C9          tst_stat 0
000AF6  1  30 F0 03 20  
000AFA  1  FF 42 28     
000AFD  1  A9 40 48 28          set_stat overfl
000B01  1  08 68 48 C9          tst_stat overfl
000B05  1  70 F0 03 20  
000B09  1  FF 42 28     
000B0C  1  B8                   clv
000B0D  1  08 68 48 C9          tst_stat 0
000B11  1  30 F0 03 20  
000B15  1  FF 42 28     
000B18  1  AD 00 02 C9          next_test
000B1C  1  0C F0 03 20  
000B20  1  FF 42 A9 0D  
000B27  1               ; testing index register increment/decrement and transfer
000B27  1               ; INX INY DEX DEY TAX TXA TAY TYA
000B27  1  A2 FE                ldx #$fe		; $b27
000B29  1  A9 FF 48 28          set_stat $ff
000B2D  1  E8                   inx             ;ff
000B2E  1  08 E0 FF F0          tst_x $ff,$ff-zero
000B32  1  03 20 FF 42  
000B36  1  68 48 C9 FD  
000B40  1  E8                   inx             ;00
000B41  1  08 E0 00 F0          tst_x 0,$ff-minus
000B45  1  03 20 FF 42  
000B49  1  68 48 C9 7F  
000B53  1  E8                   inx             ;01
000B54  1  08 E0 01 F0          tst_x 1,$ff-minus-zero
000B58  1  03 20 FF 42  
000B5C  1  68 48 C9 7D  
000B66  1  CA                   dex             ;00
000B67  1  08 E0 00 F0          tst_x 0,$ff-minus
000B6B  1  03 20 FF 42  
000B6F  1  68 48 C9 7F  
000B79  1  CA                   dex             ;ff
000B7A  1  08 E0 FF F0          tst_x $ff,$ff-zero
000B7E  1  03 20 FF 42  
000B82  1  68 48 C9 FD  
000B8C  1  CA                   dex             ;fe
000B8D  1  A9 00 48 28          set_stat 0
000B91  1  E8                   inx             ;ff
000B92  1  08 E0 FF F0          tst_x $ff,minus
000B96  1  03 20 FF 42  
000B9A  1  68 48 C9 B0  
000BA4  1  E8                   inx             ;00
000BA5  1  08 E0 00 F0          tst_x 0,zero
000BA9  1  03 20 FF 42  
000BAD  1  68 48 C9 32  
000BB7  1  E8                   inx             ;01
000BB8  1  08 E0 01 F0          tst_x 1,0
000BBC  1  03 20 FF 42  
000BC0  1  68 48 C9 30  
000BCA  1  CA                   dex             ;00
000BCB  1  08 E0 00 F0          tst_x 0,zero
000BCF  1  03 20 FF 42  
000BD3  1  68 48 C9 32  
000BDD  1  CA                   dex             ;ff
000BDE  1  08 E0 FF F0          tst_x $ff,minus
000BE2  1  03 20 FF 42  
000BE6  1  68 48 C9 B0  
000BF0  1               
000BF0  1  A0 FE                ldy #$fe
000BF2  1  A9 FF 48 28          set_stat $ff
000BF6  1  C8                   iny             ;ff
000BF7  1  08 C0 FF F0          tst_y $ff,$ff-zero
000BFB  1  03 20 FF 42  
000BFF  1  68 48 C9 FD  
000C09  1  C8                   iny             ;00
000C0A  1  08 C0 00 F0          tst_y 0,$ff-minus
000C0E  1  03 20 FF 42  
000C12  1  68 48 C9 7F  
000C1C  1  C8                   iny             ;01
000C1D  1  08 C0 01 F0          tst_y 1,$ff-minus-zero
000C21  1  03 20 FF 42  
000C25  1  68 48 C9 7D  
000C2F  1  88                   dey             ;00
000C30  1  08 C0 00 F0          tst_y 0,$ff-minus
000C34  1  03 20 FF 42  
000C38  1  68 48 C9 7F  
000C42  1  88                   dey             ;ff
000C43  1  08 C0 FF F0          tst_y $ff,$ff-zero
000C47  1  03 20 FF 42  
000C4B  1  68 48 C9 FD  
000C55  1  88                   dey             ;fe
000C56  1  A9 00 48 28          set_stat 0
000C5A  1  C8                   iny             ;ff
000C5B  1  08 C0 FF F0          tst_y $ff,0+minus
000C5F  1  03 20 FF 42  
000C63  1  68 48 C9 B0  
000C6D  1  C8                   iny             ;00
000C6E  1  08 C0 00 F0          tst_y 0,zero
000C72  1  03 20 FF 42  
000C76  1  68 48 C9 32  
000C80  1  C8                   iny             ;01
000C81  1  08 C0 01 F0          tst_y 1,0
000C85  1  03 20 FF 42  
000C89  1  68 48 C9 30  
000C93  1  88                   dey             ;00
000C94  1  08 C0 00 F0          tst_y 0,zero
000C98  1  03 20 FF 42  
000C9C  1  68 48 C9 32  
000CA6  1  88                   dey             ;ff
000CA7  1  08 C0 FF F0          tst_y $ff,minus
000CAB  1  03 20 FF 42  
000CAF  1  68 48 C9 B0  
000CB9  1               
000CB9  1  A2 FF                ldx #$ff
000CBB  1  A9 FF 48 28          set_stat $ff
000CBF  1  8A                   txa
000CC0  1  08 C9 FF F0          tst_a $ff,$ff-zero
000CC4  1  03 20 FF 42  
000CC8  1  68 48 C9 FD  
000CD2  1  08                   php
000CD3  1  E8                   inx             ;00
000CD4  1  28                   plp
000CD5  1  8A                   txa
000CD6  1  08 C9 00 F0          tst_a 0,$ff-minus
000CDA  1  03 20 FF 42  
000CDE  1  68 48 C9 7F  
000CE8  1  08                   php
000CE9  1  E8                   inx             ;01
000CEA  1  28                   plp
000CEB  1  8A                   txa
000CEC  1  08 C9 01 F0          tst_a 1,$ff-minus-zero
000CF0  1  03 20 FF 42  
000CF4  1  68 48 C9 7D  
000CFE  1  A9 00 48 28          set_stat 0	; $cfe
000D02  1  8A                   txa
000D03  1  08 C9 01 F0          tst_a 1,0
000D07  1  03 20 FF 42  
000D0B  1  68 48 C9 30  
000D15  1  08                   php
000D16  1  CA                   dex             ;00
000D17  1  28                   plp
000D18  1  8A                   txa
000D19  1  08 C9 00 F0          tst_a 0,zero
000D1D  1  03 20 FF 42  
000D21  1  68 48 C9 32  
000D2B  1  08                   php
000D2C  1  CA                   dex             ;ff
000D2D  1  28                   plp
000D2E  1  8A                   txa
000D2F  1  08 C9 FF F0          tst_a $ff,minus
000D33  1  03 20 FF 42  
000D37  1  68 48 C9 B0  
000D41  1               
000D41  1  A0 FF                ldy #$ff	; $d41
000D43  1  A9 FF 48 28          set_stat $ff
000D47  1  98                   tya
000D48  1  08 C9 FF F0          tst_a $ff,$ff-zero
000D4C  1  03 20 FF 42  
000D50  1  68 48 C9 FD  
000D5A  1  08                   php
000D5B  1  C8                   iny             ;00
000D5C  1  28                   plp
000D5D  1  98                   tya
000D5E  1  08 C9 00 F0          tst_a 0,$ff-minus
000D62  1  03 20 FF 42  
000D66  1  68 48 C9 7F  
000D70  1  08                   php
000D71  1  C8                   iny             ;01
000D72  1  28                   plp
000D73  1  98                   tya
000D74  1  08 C9 01 F0          tst_a 1,$ff-minus-zero
000D78  1  03 20 FF 42  
000D7C  1  68 48 C9 7D  
000D86  1  A9 00 48 28          set_stat 0
000D8A  1  98                   tya
000D8B  1  08 C9 01 F0          tst_a 1,0
000D8F  1  03 20 FF 42  
000D93  1  68 48 C9 30  
000D9D  1  08                   php
000D9E  1  88                   dey             ;00
000D9F  1  28                   plp
000DA0  1  98                   tya
000DA1  1  08 C9 00 F0          tst_a 0,zero
000DA5  1  03 20 FF 42  
000DA9  1  68 48 C9 32  
000DB3  1  08                   php
000DB4  1  88                   dey             ;ff
000DB5  1  28                   plp
000DB6  1  98                   tya
000DB7  1  08 C9 FF F0          tst_a $ff,minus
000DBB  1  03 20 FF 42  
000DBF  1  68 48 C9 B0  
000DC9  1               
000DC9  1  A9 FF                load_flag $ff
000DCB  1  48                   pha
000DCC  1  A2 FF                ldx #$ff        ;ff
000DCE  1  8A                   txa
000DCF  1  28                   plp
000DD0  1  A8                   tay
000DD1  1  08 C0 FF F0          tst_y $ff,$ff-zero
000DD5  1  03 20 FF 42  
000DD9  1  68 48 C9 FD  
000DE3  1  08                   php
000DE4  1  E8                   inx             ;00
000DE5  1  8A                   txa
000DE6  1  28                   plp
000DE7  1  A8                   tay
000DE8  1  08 C0 00 F0          tst_y 0,$ff-minus
000DEC  1  03 20 FF 42  
000DF0  1  68 48 C9 7F  
000DFA  1  08                   php
000DFB  1  E8                   inx             ;01
000DFC  1  8A                   txa
000DFD  1  28                   plp
000DFE  1  A8                   tay
000DFF  1  08 C0 01 F0          tst_y 1,$ff-minus-zero
000E03  1  03 20 FF 42  
000E07  1  68 48 C9 7D  
000E11  1  A9 00                load_flag 0
000E13  1  48                   pha
000E14  1  A9 00                lda #0
000E16  1  8A                   txa
000E17  1  28                   plp
000E18  1  A8                   tay
000E19  1  08 C0 01 F0          tst_y 1,0
000E1D  1  03 20 FF 42  
000E21  1  68 48 C9 30  
000E2B  1  08                   php
000E2C  1  CA                   dex             ;00
000E2D  1  8A                   txa
000E2E  1  28                   plp
000E2F  1  A8                   tay
000E30  1  08 C0 00 F0          tst_y 0,zero
000E34  1  03 20 FF 42  
000E38  1  68 48 C9 32  
000E42  1  08                   php
000E43  1  CA                   dex             ;ff
000E44  1  8A                   txa
000E45  1  28                   plp
000E46  1  A8                   tay
000E47  1  08 C0 FF F0          tst_y $ff,minus
000E4B  1  03 20 FF 42  
000E4F  1  68 48 C9 B0  
000E59  1               
000E59  1               
000E59  1  A9 FF                load_flag $ff		; $e59
000E5B  1  48                   pha
000E5C  1  A0 FF                ldy #$ff        ;ff
000E5E  1  98                   tya
000E5F  1  28                   plp
000E60  1  AA                   tax
000E61  1  08 E0 FF F0          tst_x $ff,$ff-zero
000E65  1  03 20 FF 42  
000E69  1  68 48 C9 FD  
000E73  1  08                   php
000E74  1  C8                   iny             ;00
000E75  1  98                   tya
000E76  1  28                   plp
000E77  1  AA                   tax
000E78  1  08 E0 00 F0          tst_x 0,$ff-minus
000E7C  1  03 20 FF 42  
000E80  1  68 48 C9 7F  
000E8A  1  08                   php
000E8B  1  C8                   iny             ;01
000E8C  1  98                   tya
000E8D  1  28                   plp
000E8E  1  AA                   tax
000E8F  1  08 E0 01 F0          tst_x 1,$ff-minus-zero
000E93  1  03 20 FF 42  
000E97  1  68 48 C9 7D  
000EA1  1  A9 00                load_flag 0
000EA3  1  48                   pha
000EA4  1  A9 00                lda #0          ;preset status
000EA6  1  98                   tya
000EA7  1  28                   plp
000EA8  1  AA                   tax
000EA9  1  08 E0 01 F0          tst_x 1,0
000EAD  1  03 20 FF 42  
000EB1  1  68 48 C9 30  
000EBB  1  08                   php
000EBC  1  88                   dey             ;00
000EBD  1  98                   tya
000EBE  1  28                   plp
000EBF  1  AA                   tax
000EC0  1  08 E0 00 F0          tst_x 0,zero
000EC4  1  03 20 FF 42  
000EC8  1  68 48 C9 32  
000ED2  1  08                   php
000ED3  1  88                   dey             ;ff
000ED4  1  98                   tya
000ED5  1  28                   plp
000ED6  1  AA                   tax
000ED7  1  08 E0 FF F0          tst_x $ff,minus
000EDB  1  03 20 FF 42  
000EDF  1  68 48 C9 B0  
000EE9  1  AD 00 02 C9          next_test
000EED  1  0D F0 03 20  
000EF1  1  FF 42 A9 0E  
000EF8  1               
000EF8  1               ;TSX sets NZ - TXS does not
000EF8  1               ;  This section also tests for proper stack wrap around.
000EF8  1  A2 01                ldx #1          ;01 $ef8
000EFA  1  A9 FF 48 28          set_stat $ff
000EFE  1  9A                   txs
000EFF  1  08                   php
000F00  1  AD 01 01             lda $101
000F03  1  C9 FF                cmp_flag $ff
000F05  1  F0 03 20 FF          trap_ne
000F09  1  42           
000F0A  1  A9 00 48 28          set_stat 0
000F0E  1  9A                   txs
000F0F  1  08                   php
000F10  1  AD 01 01             lda $101
000F13  1  C9 30                cmp_flag 0
000F15  1  F0 03 20 FF          trap_ne
000F19  1  42           
000F1A  1  CA                   dex             ;00
000F1B  1  A9 FF 48 28          set_stat $ff
000F1F  1  9A                   txs
000F20  1  08                   php
000F21  1  AD 00 01             lda $100
000F24  1  C9 FF                cmp_flag $ff
000F26  1  F0 03 20 FF          trap_ne
000F2A  1  42           
000F2B  1  A9 00 48 28          set_stat 0
000F2F  1  9A                   txs
000F30  1  08                   php
000F31  1  AD 00 01             lda $100
000F34  1  C9 30                cmp_flag 0
000F36  1  F0 03 20 FF          trap_ne
000F3A  1  42           
000F3B  1  CA                   dex             ;ff
000F3C  1  A9 FF 48 28          set_stat $ff
000F40  1  9A                   txs
000F41  1  08                   php
000F42  1  AD FF 01             lda $1ff
000F45  1  C9 FF                cmp_flag $ff
000F47  1  F0 03 20 FF          trap_ne
000F4B  1  42           
000F4C  1  A9 00 48 28          set_stat 0
000F50  1  9A                   txs
000F51  1  08                   php
000F52  1  AD FF 01             lda $1ff
000F55  1  C9 30                cmp_flag 0
000F57  1               
000F57  1  A2 01                ldx #1
000F59  1  9A                   txs             ;sp=01
000F5A  1  A9 FF 48 28          set_stat $ff
000F5E  1  BA                   tsx             ;clears Z, N
000F5F  1  08                   php             ;sp=00
000F60  1  E0 01                cpx #1
000F62  1  F0 03 20 FF          trap_ne
000F66  1  42           
000F67  1  AD 01 01             lda $101
000F6A  1  C9 7D                cmp_flag $ff-minus-zero
000F6C  1  F0 03 20 FF          trap_ne
000F70  1  42           
000F71  1  A9 FF 48 28          set_stat $ff
000F75  1  BA                   tsx             ;clears N, sets Z
000F76  1  08                   php             ;sp=ff
000F77  1  E0 00                cpx #0
000F79  1  F0 03 20 FF          trap_ne
000F7D  1  42           
000F7E  1  AD 00 01             lda $100
000F81  1  C9 7F                cmp_flag $ff-minus
000F83  1  F0 03 20 FF          trap_ne
000F87  1  42           
000F88  1  A9 FF 48 28          set_stat $ff
000F8C  1  BA                   tsx             ;clears N, sets Z
000F8D  1  08                   php             ;sp=fe
000F8E  1  E0 FF                cpx #$ff
000F90  1  F0 03 20 FF          trap_ne
000F94  1  42           
000F95  1  AD FF 01             lda $1ff
000F98  1  C9 FD                cmp_flag $ff-zero
000F9A  1  F0 03 20 FF          trap_ne
000F9E  1  42           
000F9F  1               
000F9F  1  A2 01                ldx #1
000FA1  1  9A                   txs             ;sp=01
000FA2  1  A9 00 48 28          set_stat 0
000FA6  1  BA                   tsx             ;clears Z, N
000FA7  1  08                   php             ;sp=00
000FA8  1  E0 01                cpx #1
000FAA  1  F0 03 20 FF          trap_ne
000FAE  1  42           
000FAF  1  AD 01 01             lda $101
000FB2  1  C9 30                cmp_flag 0
000FB4  1  F0 03 20 FF          trap_ne
000FB8  1  42           
000FB9  1  A9 00 48 28          set_stat 0
000FBD  1  BA                   tsx             ;clears N, sets Z
000FBE  1  08                   php             ;sp=ff
000FBF  1  E0 00                cpx #0
000FC1  1  F0 03 20 FF          trap_ne
000FC5  1  42           
000FC6  1  AD 00 01             lda $100
000FC9  1  C9 32                cmp_flag zero
000FCB  1  F0 03 20 FF          trap_ne
000FCF  1  42           
000FD0  1  A9 00 48 28          set_stat 0
000FD4  1  BA                   tsx             ;clears N, sets Z
000FD5  1  08                   php             ;sp=fe
000FD6  1  E0 FF                cpx #$ff
000FD8  1  F0 03 20 FF          trap_ne
000FDC  1  42           
000FDD  1  AD FF 01             lda $1ff
000FE0  1  C9 B0                cmp_flag minus
000FE2  1  F0 03 20 FF          trap_ne
000FE6  1  42           
000FE7  1  68                   pla             ;sp=ff
000FE8  1  AD 00 02 C9          next_test
000FEC  1  0E F0 03 20  
000FF0  1  FF 42 A9 0F  
000FF7  1               
000FF7  1               ; testing index register load & store LDY LDX STY STX all addressing modes
000FF7  1               ; LDX / STX - zp,y / abs,y
000FF7  1  A0 03                ldy #3		; $ff7
000FF9  1               tldx:
000FF9  1  A9 00 48 28          set_stat 0
000FFD  1  B6 15                ldx zp1,y
000FFF  1  08                   php         ;test stores do not alter flags
001000  1  8A                   txa
001001  1  49 C3                eor #$c3
001003  1  28                   plp
001004  1  99 03 02             sta abst,y
001007  1  08                   php         ;flags after load/store sequence
001008  1  49 C3                eor #$c3
00100A  1  D9 18 02             cmp abs1,y  ;test result
00100D  1  F0 03 20 FF          trap_ne
001011  1  42           
001012  1  68                   pla         ;load status
001013  1  49 30                eor_flag 0
001015  1  D9 1D 02             cmp fLDx,y  ;test flags
001018  1  F0 03 20 FF          trap_ne		; X add without carry?
00101C  1  42           
00101D  1  88                   dey
00101E  1  10 D9                bpl tldx
001020  1               
001020  1  A0 03                ldy #3		; $1016 (mit X)
001022  1               tldx1:
001022  1  A9 FF 48 28          set_stat $ff
001026  1  B6 15                ldx zp1,y
001028  1  08                   php         ;test stores do not alter flags
001029  1  8A                   txa
00102A  1  49 C3                eor #$c3
00102C  1  28                   plp
00102D  1  99 03 02             sta abst,y
001030  1  08                   php         ;flags after load/store sequence
001031  1  49 C3                eor #$c3
001033  1  D9 18 02             cmp abs1,y  ;test result X
001036  1  F0 03 20 FF          trap_ne
00103A  1  42           
00103B  1  68                   pla         ;load status
00103C  1  49 7D                eor_flag <~fnz ;mask bits not altered
00103E  1  D9 1D 02             cmp fLDx,y  ;test flags
001041  1  F0 03 20 FF          trap_ne
001045  1  42           
001046  1  88                   dey
001047  1  10 D9                bpl tldx1
001049  1               
001049  1  A0 03                ldy #3	; $103d (mit X)
00104B  1               tldx2:
00104B  1  A9 00 48 28          set_stat 0
00104F  1  BE 18 02             ldx abs1,y
001052  1  08                   php         ;test stores do not alter flags
001053  1  8A                   txa
001054  1  49 C3                eor #$c3
001056  1  AA                   tax
001057  1  28                   plp
001058  1  96 0C                stx zpt,y
00105A  1  08                   php         ;flags after load/store sequence
00105B  1  49 C3                eor #$c3
00105D  1  D9 15 00             cmp zp1,y   ;test result
001060  1  F0 03 20 FF          trap_ne
001064  1  42           
001065  1  68                   pla         ;load status
001066  1  49 30                eor_flag 0
001068  1  D9 1D 02             cmp fLDx,y  ;test flags
00106B  1  F0 03 20 FF          trap_ne
00106F  1  42           
001070  1  88                   dey
001071  1  10 D8                bpl tldx2
001073  1               
001073  1  A0 03                ldy #3		; $1067 (mit X)
001075  1               tldx3:
001075  1  A9 FF 48 28          set_stat $ff
001079  1  BE 18 02             ldx abs1,y
00107C  1  08                   php         ;test stores do not alter flags
00107D  1  8A                   txa
00107E  1  49 C3                eor #$c3
001080  1  AA                   tax
001081  1  28                   plp
001082  1  96 0C                stx zpt,y
001084  1  08                   php         ;flags after load/store sequence
001085  1  49 C3                eor #$c3
001087  1  D9 15 00             cmp zp1,y   ;test result
00108A  1  F0 03 20 FF          trap_ne
00108E  1  42           
00108F  1  68                   pla         ;load status
001090  1  49 7D                eor_flag <~fnz ;mask bits not altered
001092  1  D9 1D 02             cmp fLDx,y  ;test flags
001095  1  F0 03 20 FF          trap_ne
001099  1  42           
00109A  1  88                   dey
00109B  1  10 D8                bpl tldx3
00109D  1               
00109D  1  A0 03                ldy #3      ;testing store result
00109F  1  A2 00                ldx #0		; $1095 (mit X)
0010A1  1  B9 0C 00     tstx:   lda zpt,y
0010A4  1  49 C3                eor #$c3
0010A6  1  D9 15 00             cmp zp1,y
0010A9  1  F0 03 20 FF          trap_ne     ;store to zp data
0010AD  1  42           
0010AE  1  96 0C                stx zpt,y   ;clear
0010B0  1  B9 03 02             lda abst,y
0010B3  1  49 C3                eor #$c3
0010B5  1  D9 18 02             cmp abs1,y
0010B8  1  F0 03 20 FF          trap_ne     ;store to abs data
0010BC  1  42           
0010BD  1  8A                   txa
0010BE  1  99 03 02             sta abst,y  ;clear
0010C1  1  88                   dey
0010C2  1  10 DD                bpl tstx
0010C4  1  AD 00 02 C9          next_test
0010C8  1  0F F0 03 20  
0010CC  1  FF 42 A9 10  
0010D3  1               
0010D3  1               ; indexed wraparound test (only zp should wrap) Test 16
0010D3  1  A0 FD                ldy #3+$fa
0010D5  1  B6 1B        tldx4:  ldx <(zp1-$fa),y   ;wrap on indexed zp
0010D7  1  8A                   txa
0010D8  1  99 09 01             sta abst-$fa,y      ;no STX abs,y!
0010DB  1  88                   dey
0010DC  1  C0 FA                cpy #$fa
0010DE  1  B0 F5                bcs tldx4
0010E0  1  A0 FD                ldy #3+$fa
0010E2  1  BE 1E 01     tldx5:  ldx abs1-$fa,y      ;no wrap on indexed abs
0010E5  1  96 12                stx <(zpt-$fa),y
0010E7  1  88                   dey
0010E8  1  C0 FA                cpy #$fa
0010EA  1  B0 F6                bcs tldx5
0010EC  1  A0 03                ldy #3      ;testing wraparound result
0010EE  1  A2 00                ldx #0
0010F0  1  B9 0C 00     tstx1:  lda zpt,y
0010F3  1  D9 15 00             cmp zp1,y
0010F6  1                       ; trap_ne     ;store to zp data (issue related to Z. 2162)
0010F6  1  96 0C                stx zpt,y   ;clear
0010F8  1  B9 03 02             lda abst,y	; $10fd
0010FB  1  D9 18 02             cmp abs1,y	; X $1100 (with issues $10fb)
0010FE  1                       ; trap_ne     ;store to abs data
0010FE  1  8A                   txa
0010FF  1  99 03 02             sta abst,y  ;clear
001102  1  88                   dey
001103  1  10 EB                bpl tstx1
001105  1  AD 00 02 C9          next_test
001109  1  10 F0 03 20  
00110D  1  FF 42 A9 11  
001114  1               
001114  1               ; LDY / STY - zp,x / abs,x Test 17
001114  1  A2 03                ldx #3		; $1114 (with issues)
001116  1               tldy:
001116  1  A9 00 48 28          set_stat 0
00111A  1  B4 15                ldy zp1,x
00111C  1  08                   php         ;test stores do not alter flags
00111D  1  98                   tya
00111E  1  49 C3                eor #$c3
001120  1  28                   plp
001121  1  9D 03 02             sta abst,x
001124  1  08                   php         ;flags after load/store sequence
001125  1  49 C3                eor #$c3
001127  1  DD 18 02             cmp abs1,x  ;test result
00112A  1  F0 03 20 FF          trap_ne
00112E  1  42           
00112F  1  68                   pla         ;load status
001130  1  49 30                eor_flag 0
001132  1  DD 1D 02             cmp fLDx,x  ;test flags
001135  1  F0 03 20 FF          trap_ne
001139  1  42           
00113A  1  CA                   dex
00113B  1  10 D9                bpl tldy
00113D  1               
00113D  1  A2 03                ldx #3
00113F  1               tldy1:
00113F  1  A9 FF 48 28          set_stat $ff
001143  1  B4 15                ldy zp1,x
001145  1  08                   php         ;test stores do not alter flags
001146  1  98                   tya
001147  1  49 C3                eor #$c3
001149  1  28                   plp
00114A  1  9D 03 02             sta abst,x
00114D  1  08                   php         ;flags after load/store sequence
00114E  1  49 C3                eor #$c3
001150  1  DD 18 02             cmp abs1,x  ;test result
001153  1  F0 03 20 FF          trap_ne
001157  1  42           
001158  1  68                   pla         ;load status
001159  1  49 7D                eor_flag <~fnz ;mask bits not altered
00115B  1  DD 1D 02             cmp fLDx,x  ;test flags
00115E  1  F0 03 20 FF          trap_ne
001162  1  42           
001163  1  CA                   dex
001164  1  10 D9                bpl tldy1
001166  1               
001166  1  A2 03                ldx #3
001168  1               tldy2:
001168  1  A9 00 48 28          set_stat 0
00116C  1  BC 18 02             ldy abs1,x		; $116c
00116F  1  08                   php         ;test stores do not alter flags
001170  1  98                   tya
001171  1  49 C3                eor #$c3
001173  1  A8                   tay
001174  1  28                   plp
001175  1  94 0C                sty zpt,x
001177  1  08                   php         ;flags after load/store sequence
001178  1  49 C3                eor #$c3
00117A  1  D5 15                cmp zp1,x   ;test result
00117C  1  F0 03 20 FF          trap_ne
001180  1  42           
001181  1  68                   pla         ;load status
001182  1  49 30                eor_flag 0
001184  1  DD 1D 02             cmp fLDx,x  ;test flags
001187  1  F0 03 20 FF          trap_ne
00118B  1  42           
00118C  1  CA                   dex
00118D  1  10 D9                bpl tldy2
00118F  1               
00118F  1  A2 03                ldx #3			; $118f
001191  1               tldy3:
001191  1  A9 FF 48 28          set_stat $ff
001195  1  BC 18 02             ldy abs1,x
001198  1  08                   php         ;test stores do not alter flags
001199  1  98                   tya
00119A  1  49 C3                eor #$c3
00119C  1  A8                   tay
00119D  1  28                   plp
00119E  1  94 0C                sty zpt,x
0011A0  1  08                   php         ;flags after load/store sequence
0011A1  1  49 C3                eor #$c3
0011A3  1  D5 15                cmp zp1,x   ;test result
0011A5  1  F0 03 20 FF          trap_ne
0011A9  1  42           
0011AA  1  68                   pla         ;load status
0011AB  1  49 7D                eor_flag <~fnz ;mask bits not altered
0011AD  1  DD 1D 02             cmp fLDx,x  ;test flags
0011B0  1  F0 03 20 FF          trap_ne
0011B4  1  42           
0011B5  1  CA                   dex
0011B6  1  10 D9                bpl tldy3
0011B8  1               
0011B8  1  A2 03                ldx #3      ;testing store result $11b8
0011BA  1  A0 00                ldy #0
0011BC  1  B5 0C        tsty:   lda zpt,x
0011BE  1  49 C3                eor #$c3
0011C0  1  D5 15                cmp zp1,x
0011C2  1  F0 03 20 FF          trap_ne     ;store to zp,x data
0011C6  1  42           
0011C7  1  94 0C                sty zpt,x   ;clear
0011C9  1  BD 03 02             lda abst,x
0011CC  1  49 C3                eor #$c3
0011CE  1  DD 18 02             cmp abs1,x
0011D1  1  F0 03 20 FF          trap_ne     ;store to abs,x data
0011D5  1  42           
0011D6  1  8A                   txa
0011D7  1  9D 03 02             sta abst,x  ;clear
0011DA  1  CA                   dex
0011DB  1  10 DF                bpl tsty
0011DD  1  AD 00 02 C9          next_test	; Aktuell
0011E1  1  11 F0 03 20  
0011E5  1  FF 42 A9 12  
0011EC  1               
0011EC  1               ; indexed wraparound test (only zp should wrap)
0011EC  1  A2 FD                ldx #3+$fa		; $11ec -> X = 0xfd
0011EE  1  B4 1B        tldy4:  ldy <(zp1-$fa),x   ;wrap on indexed zp
0011F0  1  98                   tya
0011F1  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
0011F4  1  CA                   dex
0011F5  1  E0 FA                cpx #$fa
0011F7  1  B0 F5                bcs tldy4
0011F9  1  A2 FD                ldx #3+$fa		; $11f9 -> X = 0xfd
0011FB  1  BC 1E 01     tldy5:  ldy abs1-$fa,x      ;no wrap on indexed abs
0011FE  1  94 12                sty <(zpt-$fa),x
001200  1  CA                   dex
001201  1  E0 FA                cpx #$fa
001203  1  B0 F6                bcs tldy5
001205  1  A2 03                ldx #3      ;testing wraparound result X
001207  1  A0 00                ldy #0
001209  1  B5 0C        tsty1:  lda zpt,x	; $1209
00120B  1  D5 15                cmp zp1,x	; X
00120D  1                       ; trap_ne     ;store to zp,x data
00120D  1  94 0C                sty zpt,x   ;clear
00120F  1  BD 03 02             lda abst,x
001212  1  DD 18 02             cmp abs1,x	; X
001215  1                       ; trap_ne     ;store to abs,x data
001215  1  8A                   txa
001216  1  9D 03 02             sta abst,x  ;clear
001219  1  CA                   dex
00121A  1  10 ED                bpl tsty1
00121C  1  AD 00 02 C9          next_test
001220  1  12 F0 03 20  
001224  1  FF 42 A9 13  
00122B  1               
00122B  1               ; LDX / STX - zp / abs / #
00122B  1  A9 00 48 28          set_stat 0
00122F  1  A6 15                ldx zp1
001231  1  08                   php         ;test stores do not alter flags
001232  1  8A                   txa
001233  1  49 C3                eor #$c3
001235  1  AA                   tax
001236  1  28                   plp
001237  1  8E 03 02             stx abst
00123A  1  08                   php         ;flags after load/store sequence
00123B  1  49 C3                eor #$c3
00123D  1  AA                   tax
00123E  1  E0 C3                cpx #$c3    ;test result
001240  1  F0 03 20 FF          trap_ne
001244  1  42           
001245  1  68                   pla         ;load status
001246  1  49 30                eor_flag 0
001248  1  CD 1D 02             cmp fLDx    ;test flags
00124B  1  F0 03 20 FF          trap_ne
00124F  1  42           
001250  1  A9 00 48 28          set_stat 0
001254  1  A6 16                ldx zp1+1
001256  1  08                   php         ;test stores do not alter flags
001257  1  8A                   txa
001258  1  49 C3                eor #$c3
00125A  1  AA                   tax
00125B  1  28                   plp
00125C  1  8E 04 02             stx abst+1
00125F  1  08                   php         ;flags after load/store sequence
001260  1  49 C3                eor #$c3
001262  1  AA                   tax
001263  1  E0 82                cpx #$82    ;test result
001265  1  F0 03 20 FF          trap_ne
001269  1  42           
00126A  1  68                   pla         ;load status
00126B  1  49 30                eor_flag 0
00126D  1  CD 1E 02             cmp fLDx+1  ;test flags
001270  1  F0 03 20 FF          trap_ne
001274  1  42           
001275  1  A9 00 48 28          set_stat 0
001279  1  A6 17                ldx zp1+2
00127B  1  08                   php         ;test stores do not alter flags
00127C  1  8A                   txa
00127D  1  49 C3                eor #$c3
00127F  1  AA                   tax
001280  1  28                   plp
001281  1  8E 05 02             stx abst+2
001284  1  08                   php         ;flags after load/store sequence
001285  1  49 C3                eor #$c3
001287  1  AA                   tax
001288  1  E0 41                cpx #$41    ;test result
00128A  1  F0 03 20 FF          trap_ne
00128E  1  42           
00128F  1  68                   pla         ;load status
001290  1  49 30                eor_flag 0
001292  1  CD 1F 02             cmp fLDx+2  ;test flags
001295  1  F0 03 20 FF          trap_ne
001299  1  42           
00129A  1  A9 00 48 28          set_stat 0
00129E  1  A6 18                ldx zp1+3
0012A0  1  08                   php         ;test stores do not alter flags
0012A1  1  8A                   txa
0012A2  1  49 C3                eor #$c3
0012A4  1  AA                   tax
0012A5  1  28                   plp
0012A6  1  8E 06 02             stx abst+3
0012A9  1  08                   php         ;flags after load/store sequence
0012AA  1  49 C3                eor #$c3
0012AC  1  AA                   tax
0012AD  1  E0 00                cpx #0      ;test result
0012AF  1  F0 03 20 FF          trap_ne
0012B3  1  42           
0012B4  1  68                   pla         ;load status
0012B5  1  49 30                eor_flag 0
0012B7  1  CD 20 02             cmp fLDx+3  ;test flags
0012BA  1  F0 03 20 FF          trap_ne
0012BE  1  42           
0012BF  1               
0012BF  1  A9 FF 48 28          set_stat $ff
0012C3  1  A6 15                ldx zp1
0012C5  1  08                   php         ;test stores do not alter flags
0012C6  1  8A                   txa
0012C7  1  49 C3                eor #$c3
0012C9  1  AA                   tax
0012CA  1  28                   plp
0012CB  1  8E 03 02             stx abst
0012CE  1  08                   php         ;flags after load/store sequence
0012CF  1  49 C3                eor #$c3
0012D1  1  AA                   tax
0012D2  1  E0 C3                cpx #$c3    ;test result
0012D4  1  F0 03 20 FF          trap_ne     ;
0012D8  1  42           
0012D9  1  68                   pla         ;load status
0012DA  1  49 7D                eor_flag <~fnz ;mask bits not altered
0012DC  1  CD 1D 02             cmp fLDx    ;test flags
0012DF  1  F0 03 20 FF          trap_ne
0012E3  1  42           
0012E4  1  A9 FF 48 28          set_stat $ff
0012E8  1  A6 16                ldx zp1+1
0012EA  1  08                   php         ;test stores do not alter flags
0012EB  1  8A                   txa
0012EC  1  49 C3                eor #$c3
0012EE  1  AA                   tax
0012EF  1  28                   plp
0012F0  1  8E 04 02             stx abst+1
0012F3  1  08                   php         ;flags after load/store sequence
0012F4  1  49 C3                eor #$c3
0012F6  1  AA                   tax
0012F7  1  E0 82                cpx #$82    ;test result
0012F9  1  F0 03 20 FF          trap_ne
0012FD  1  42           
0012FE  1  68                   pla         ;load status
0012FF  1  49 7D                eor_flag <~fnz ;mask bits not altered
001301  1  CD 1E 02             cmp fLDx+1  ;test flags
001304  1  F0 03 20 FF          trap_ne
001308  1  42           
001309  1  A9 FF 48 28          set_stat $ff
00130D  1  A6 17                ldx zp1+2
00130F  1  08                   php         ;test stores do not alter flags
001310  1  8A                   txa
001311  1  49 C3                eor #$c3
001313  1  AA                   tax
001314  1  28                   plp
001315  1  8E 05 02             stx abst+2
001318  1  08                   php         ;flags after load/store sequence
001319  1  49 C3                eor #$c3
00131B  1  AA                   tax
00131C  1  E0 41                cpx #$41    ;test result
00131E  1  F0 03 20 FF          trap_ne     ;
001322  1  42           
001323  1  68                   pla         ;load status
001324  1  49 7D                eor_flag <~fnz ;mask bits not altered
001326  1  CD 1F 02             cmp fLDx+2  ;test flags
001329  1  F0 03 20 FF          trap_ne
00132D  1  42           
00132E  1  A9 FF 48 28          set_stat $ff
001332  1  A6 18                ldx zp1+3
001334  1  08                   php         ;test stores do not alter flags
001335  1  8A                   txa
001336  1  49 C3                eor #$c3
001338  1  AA                   tax
001339  1  28                   plp
00133A  1  8E 06 02             stx abst+3
00133D  1  08                   php         ;flags after load/store sequence
00133E  1  49 C3                eor #$c3
001340  1  AA                   tax
001341  1  E0 00                cpx #0      ;test result
001343  1  F0 03 20 FF          trap_ne
001347  1  42           
001348  1  68                   pla         ;load status
001349  1  49 7D                eor_flag <~fnz ;mask bits not altered
00134B  1  CD 20 02             cmp fLDx+3  ;test flags
00134E  1  F0 03 20 FF          trap_ne
001352  1  42           
001353  1               
001353  1  A9 00 48 28          set_stat 0
001357  1  AE 18 02             ldx abs1
00135A  1  08                   php         ;test stores do not alter flags
00135B  1  8A                   txa
00135C  1  49 C3                eor #$c3
00135E  1  AA                   tax
00135F  1  28                   plp
001360  1  86 0C                stx zpt
001362  1  08                   php         ;flags after load/store sequence
001363  1  49 C3                eor #$c3
001365  1  C5 15                cmp zp1     ;test result
001367  1  F0 03 20 FF          trap_ne
00136B  1  42           
00136C  1  68                   pla         ;load status
00136D  1  49 30                eor_flag 0
00136F  1  CD 1D 02             cmp fLDx    ;test flags
001372  1  F0 03 20 FF          trap_ne
001376  1  42           
001377  1  A9 00 48 28          set_stat 0
00137B  1  AE 19 02             ldx abs1+1
00137E  1  08                   php         ;test stores do not alter flags
00137F  1  8A                   txa
001380  1  49 C3                eor #$c3
001382  1  AA                   tax
001383  1  28                   plp
001384  1  86 0D                stx zpt+1
001386  1  08                   php         ;flags after load/store sequence
001387  1  49 C3                eor #$c3
001389  1  C5 16                cmp zp1+1   ;test result
00138B  1  F0 03 20 FF          trap_ne
00138F  1  42           
001390  1  68                   pla         ;load status
001391  1  49 30                eor_flag 0
001393  1  CD 1E 02             cmp fLDx+1  ;test flags
001396  1  F0 03 20 FF          trap_ne
00139A  1  42           
00139B  1  A9 00 48 28          set_stat 0
00139F  1  AE 1A 02             ldx abs1+2
0013A2  1  08                   php         ;test stores do not alter flags
0013A3  1  8A                   txa
0013A4  1  49 C3                eor #$c3
0013A6  1  AA                   tax
0013A7  1  28                   plp
0013A8  1  86 0E                stx zpt+2
0013AA  1  08                   php         ;flags after load/store sequence
0013AB  1  49 C3                eor #$c3
0013AD  1  C5 17                cmp zp1+2   ;test result
0013AF  1  F0 03 20 FF          trap_ne
0013B3  1  42           
0013B4  1  68                   pla         ;load status
0013B5  1  49 30                eor_flag 0
0013B7  1  CD 1F 02             cmp fLDx+2  ;test flags
0013BA  1  F0 03 20 FF          trap_ne
0013BE  1  42           
0013BF  1  A9 00 48 28          set_stat 0
0013C3  1  AE 1B 02             ldx abs1+3
0013C6  1  08                   php         ;test stores do not alter flags
0013C7  1  8A                   txa
0013C8  1  49 C3                eor #$c3
0013CA  1  AA                   tax
0013CB  1  28                   plp
0013CC  1  86 0F                stx zpt+3
0013CE  1  08                   php         ;flags after load/store sequence
0013CF  1  49 C3                eor #$c3
0013D1  1  C5 18                cmp zp1+3   ;test result
0013D3  1  F0 03 20 FF          trap_ne
0013D7  1  42           
0013D8  1  68                   pla         ;load status
0013D9  1  49 30                eor_flag 0
0013DB  1  CD 20 02             cmp fLDx+3  ;test flags
0013DE  1  F0 03 20 FF          trap_ne
0013E2  1  42           
0013E3  1               
0013E3  1  A9 FF 48 28          set_stat $ff
0013E7  1  AE 18 02             ldx abs1
0013EA  1  08                   php         ;test stores do not alter flags
0013EB  1  8A                   txa
0013EC  1  49 C3                eor #$c3
0013EE  1  AA                   tax
0013EF  1  28                   plp
0013F0  1  86 0C                stx zpt
0013F2  1  08                   php         ;flags after load/store sequence
0013F3  1  49 C3                eor #$c3
0013F5  1  AA                   tax
0013F6  1  E4 15                cpx zp1     ;test result
0013F8  1  F0 03 20 FF          trap_ne
0013FC  1  42           
0013FD  1  68                   pla         ;load status
0013FE  1  49 7D                eor_flag <~fnz ;mask bits not altered
001400  1  CD 1D 02             cmp fLDx    ;test flags
001403  1  F0 03 20 FF          trap_ne
001407  1  42           
001408  1  A9 FF 48 28          set_stat $ff
00140C  1  AE 19 02             ldx abs1+1
00140F  1  08                   php         ;test stores do not alter flags
001410  1  8A                   txa
001411  1  49 C3                eor #$c3
001413  1  AA                   tax
001414  1  28                   plp
001415  1  86 0D                stx zpt+1
001417  1  08                   php         ;flags after load/store sequence
001418  1  49 C3                eor #$c3
00141A  1  AA                   tax
00141B  1  E4 16                cpx zp1+1   ;test result
00141D  1  F0 03 20 FF          trap_ne
001421  1  42           
001422  1  68                   pla         ;load status
001423  1  49 7D                eor_flag <~fnz ;mask bits not altered
001425  1  CD 1E 02             cmp fLDx+1  ;test flags
001428  1  F0 03 20 FF          trap_ne
00142C  1  42           
00142D  1  A9 FF 48 28          set_stat $ff
001431  1  AE 1A 02             ldx abs1+2
001434  1  08                   php         ;test stores do not alter flags
001435  1  8A                   txa
001436  1  49 C3                eor #$c3
001438  1  AA                   tax
001439  1  28                   plp
00143A  1  86 0E                stx zpt+2
00143C  1  08                   php         ;flags after load/store sequence
00143D  1  49 C3                eor #$c3
00143F  1  AA                   tax
001440  1  E4 17                cpx zp1+2   ;test result
001442  1  F0 03 20 FF          trap_ne
001446  1  42           
001447  1  68                   pla         ;load status
001448  1  49 7D                eor_flag <~fnz ;mask bits not altered
00144A  1  CD 1F 02             cmp fLDx+2  ;test flags
00144D  1  F0 03 20 FF          trap_ne
001451  1  42           
001452  1  A9 FF 48 28          set_stat $ff
001456  1  AE 1B 02             ldx abs1+3
001459  1  08                   php         ;test stores do not alter flags
00145A  1  8A                   txa
00145B  1  49 C3                eor #$c3
00145D  1  AA                   tax
00145E  1  28                   plp
00145F  1  86 0F                stx zpt+3
001461  1  08                   php         ;flags after load/store sequence
001462  1  49 C3                eor #$c3
001464  1  AA                   tax
001465  1  E4 18                cpx zp1+3   ;test result
001467  1  F0 03 20 FF          trap_ne
00146B  1  42           
00146C  1  68                   pla         ;load status
00146D  1  49 7D                eor_flag <~fnz ;mask bits not altered
00146F  1  CD 20 02             cmp fLDx+3  ;test flags
001472  1  F0 03 20 FF          trap_ne
001476  1  42           
001477  1               
001477  1  A9 00 48 28          set_stat 0
00147B  1  A2 C3                ldx #$c3
00147D  1  08                   php
00147E  1  EC 18 02             cpx abs1    ;test result
001481  1  F0 03 20 FF          trap_ne
001485  1  42           
001486  1  68                   pla         ;load status
001487  1  49 30                eor_flag 0
001489  1  CD 1D 02             cmp fLDx    ;test flags
00148C  1  F0 03 20 FF          trap_ne
001490  1  42           
001491  1  A9 00 48 28          set_stat 0
001495  1  A2 82                ldx #$82
001497  1  08                   php
001498  1  EC 19 02             cpx abs1+1  ;test result
00149B  1  F0 03 20 FF          trap_ne
00149F  1  42           
0014A0  1  68                   pla         ;load status
0014A1  1  49 30                eor_flag 0
0014A3  1  CD 1E 02             cmp fLDx+1  ;test flags
0014A6  1  F0 03 20 FF          trap_ne
0014AA  1  42           
0014AB  1  A9 00 48 28          set_stat 0
0014AF  1  A2 41                ldx #$41
0014B1  1  08                   php
0014B2  1  EC 1A 02             cpx abs1+2  ;test result
0014B5  1  F0 03 20 FF          trap_ne
0014B9  1  42           
0014BA  1  68                   pla         ;load status
0014BB  1  49 30                eor_flag 0
0014BD  1  CD 1F 02             cmp fLDx+2  ;test flags
0014C0  1  F0 03 20 FF          trap_ne
0014C4  1  42           
0014C5  1  A9 00 48 28          set_stat 0
0014C9  1  A2 00                ldx #0
0014CB  1  08                   php
0014CC  1  EC 1B 02             cpx abs1+3  ;test result
0014CF  1  F0 03 20 FF          trap_ne
0014D3  1  42           
0014D4  1  68                   pla         ;load status
0014D5  1  49 30                eor_flag 0
0014D7  1  CD 20 02             cmp fLDx+3  ;test flags
0014DA  1  F0 03 20 FF          trap_ne
0014DE  1  42           
0014DF  1               
0014DF  1  A9 FF 48 28          set_stat $ff
0014E3  1  A2 C3                ldx #$c3
0014E5  1  08                   php
0014E6  1  EC 18 02             cpx abs1    ;test result
0014E9  1  F0 03 20 FF          trap_ne
0014ED  1  42           
0014EE  1  68                   pla         ;load status
0014EF  1  49 7D                eor_flag <~fnz ;mask bits not altered
0014F1  1  CD 1D 02             cmp fLDx    ;test flags
0014F4  1  F0 03 20 FF          trap_ne
0014F8  1  42           
0014F9  1  A9 FF 48 28          set_stat $ff
0014FD  1  A2 82                ldx #$82
0014FF  1  08                   php
001500  1  EC 19 02             cpx abs1+1  ;test result
001503  1  F0 03 20 FF          trap_ne
001507  1  42           
001508  1  68                   pla         ;load status
001509  1  49 7D                eor_flag <~fnz ;mask bits not altered
00150B  1  CD 1E 02             cmp fLDx+1  ;test flags
00150E  1  F0 03 20 FF          trap_ne
001512  1  42           
001513  1  A9 FF 48 28          set_stat $ff
001517  1  A2 41                ldx #$41
001519  1  08                   php
00151A  1  EC 1A 02             cpx abs1+2  ;test result
00151D  1  F0 03 20 FF          trap_ne
001521  1  42           
001522  1  68                   pla         ;load status
001523  1  49 7D                eor_flag <~fnz ;mask bits not altered
001525  1  CD 1F 02             cmp fLDx+2  ;test flags
001528  1  F0 03 20 FF          trap_ne
00152C  1  42           
00152D  1  A9 FF 48 28          set_stat $ff
001531  1  A2 00                ldx #0
001533  1  08                   php
001534  1  EC 1B 02             cpx abs1+3  ;test result
001537  1  F0 03 20 FF          trap_ne
00153B  1  42           
00153C  1  68                   pla         ;load status
00153D  1  49 7D                eor_flag <~fnz ;mask bits not altered
00153F  1  CD 20 02             cmp fLDx+3  ;test flags
001542  1  F0 03 20 FF          trap_ne
001546  1  42           
001547  1               
001547  1  A2 00                ldx #0
001549  1  A5 0C                lda zpt
00154B  1  49 C3                eor #$c3
00154D  1  C5 15                cmp zp1
00154F  1  F0 03 20 FF          trap_ne     ;store to zp data
001553  1  42           
001554  1  86 0C                stx zpt     ;clear
001556  1  AD 03 02             lda abst
001559  1  49 C3                eor #$c3
00155B  1  CD 18 02             cmp abs1
00155E  1  F0 03 20 FF          trap_ne     ;store to abs data
001562  1  42           
001563  1  8E 03 02             stx abst    ;clear
001566  1  A5 0D                lda zpt+1
001568  1  49 C3                eor #$c3
00156A  1  C5 16                cmp zp1+1
00156C  1  F0 03 20 FF          trap_ne     ;store to zp data
001570  1  42           
001571  1  86 0D                stx zpt+1   ;clear
001573  1  AD 04 02             lda abst+1
001576  1  49 C3                eor #$c3
001578  1  CD 19 02             cmp abs1+1
00157B  1  F0 03 20 FF          trap_ne     ;store to abs data
00157F  1  42           
001580  1  8E 04 02             stx abst+1  ;clear
001583  1  A5 0E                lda zpt+2
001585  1  49 C3                eor #$c3
001587  1  C5 17                cmp zp1+2
001589  1  F0 03 20 FF          trap_ne     ;store to zp data
00158D  1  42           
00158E  1  86 0E                stx zpt+2   ;clear
001590  1  AD 05 02             lda abst+2
001593  1  49 C3                eor #$c3
001595  1  CD 1A 02             cmp abs1+2
001598  1  F0 03 20 FF          trap_ne     ;store to abs data
00159C  1  42           
00159D  1  8E 05 02             stx abst+2  ;clear
0015A0  1  A5 0F                lda zpt+3
0015A2  1  49 C3                eor #$c3
0015A4  1  C5 18                cmp zp1+3
0015A6  1  F0 03 20 FF          trap_ne     ;store to zp data
0015AA  1  42           
0015AB  1  86 0F                stx zpt+3   ;clear
0015AD  1  AD 06 02             lda abst+3
0015B0  1  49 C3                eor #$c3
0015B2  1  CD 1B 02             cmp abs1+3
0015B5  1  F0 03 20 FF          trap_ne     ;store to abs data
0015B9  1  42           
0015BA  1  8E 06 02             stx abst+3  ;clear
0015BD  1  AD 00 02 C9          next_test
0015C1  1  13 F0 03 20  
0015C5  1  FF 42 A9 14  
0015CC  1               
0015CC  1               ; LDY / STY - zp / abs / #
0015CC  1  A9 00 48 28          set_stat 0
0015D0  1  A4 15                ldy zp1
0015D2  1  08                   php         ;test stores do not alter flags
0015D3  1  98                   tya
0015D4  1  49 C3                eor #$c3
0015D6  1  A8                   tay
0015D7  1  28                   plp
0015D8  1  8C 03 02             sty abst
0015DB  1  08                   php         ;flags after load/store sequence
0015DC  1  49 C3                eor #$c3
0015DE  1  A8                   tay
0015DF  1  C0 C3                cpy #$c3    ;test result
0015E1  1  F0 03 20 FF          trap_ne
0015E5  1  42           
0015E6  1  68                   pla         ;load status
0015E7  1  49 30                eor_flag 0
0015E9  1  CD 1D 02             cmp fLDx    ;test flags
0015EC  1  F0 03 20 FF          trap_ne
0015F0  1  42           
0015F1  1  A9 00 48 28          set_stat 0
0015F5  1  A4 16                ldy zp1+1
0015F7  1  08                   php         ;test stores do not alter flags
0015F8  1  98                   tya
0015F9  1  49 C3                eor #$c3
0015FB  1  A8                   tay
0015FC  1  28                   plp
0015FD  1  8C 04 02             sty abst+1
001600  1  08                   php         ;flags after load/store sequence
001601  1  49 C3                eor #$c3
001603  1  A8                   tay
001604  1  C0 82                cpy #$82    ;test result
001606  1  F0 03 20 FF          trap_ne
00160A  1  42           
00160B  1  68                   pla         ;load status
00160C  1  49 30                eor_flag 0
00160E  1  CD 1E 02             cmp fLDx+1  ;test flags
001611  1  F0 03 20 FF          trap_ne
001615  1  42           
001616  1  A9 00 48 28          set_stat 0
00161A  1  A4 17                ldy zp1+2
00161C  1  08                   php         ;test stores do not alter flags
00161D  1  98                   tya
00161E  1  49 C3                eor #$c3
001620  1  A8                   tay
001621  1  28                   plp
001622  1  8C 05 02             sty abst+2
001625  1  08                   php         ;flags after load/store sequence
001626  1  49 C3                eor #$c3
001628  1  A8                   tay
001629  1  C0 41                cpy #$41    ;test result
00162B  1  F0 03 20 FF          trap_ne
00162F  1  42           
001630  1  68                   pla         ;load status
001631  1  49 30                eor_flag 0
001633  1  CD 1F 02             cmp fLDx+2  ;test flags
001636  1  F0 03 20 FF          trap_ne
00163A  1  42           
00163B  1  A9 00 48 28          set_stat 0
00163F  1  A4 18                ldy zp1+3
001641  1  08                   php         ;test stores do not alter flags
001642  1  98                   tya
001643  1  49 C3                eor #$c3
001645  1  A8                   tay
001646  1  28                   plp
001647  1  8C 06 02             sty abst+3
00164A  1  08                   php         ;flags after load/store sequence
00164B  1  49 C3                eor #$c3
00164D  1  A8                   tay
00164E  1  C0 00                cpy #0      ;test result
001650  1  F0 03 20 FF          trap_ne
001654  1  42           
001655  1  68                   pla         ;load status
001656  1  49 30                eor_flag 0
001658  1  CD 20 02             cmp fLDx+3  ;test flags
00165B  1  F0 03 20 FF          trap_ne
00165F  1  42           
001660  1               
001660  1  A9 FF 48 28          set_stat $ff
001664  1  A4 15                ldy zp1
001666  1  08                   php         ;test stores do not alter flags
001667  1  98                   tya
001668  1  49 C3                eor #$c3
00166A  1  A8                   tay
00166B  1  28                   plp
00166C  1  8C 03 02             sty abst
00166F  1  08                   php         ;flags after load/store sequence
001670  1  49 C3                eor #$c3
001672  1  A8                   tay
001673  1  C0 C3                cpy #$c3    ;test result
001675  1  F0 03 20 FF          trap_ne
001679  1  42           
00167A  1  68                   pla         ;load status
00167B  1  49 7D                eor_flag <~fnz ;mask bits not altered
00167D  1  CD 1D 02             cmp fLDx    ;test flags
001680  1  F0 03 20 FF          trap_ne
001684  1  42           
001685  1  A9 FF 48 28          set_stat $ff
001689  1  A4 16                ldy zp1+1
00168B  1  08                   php         ;test stores do not alter flags
00168C  1  98                   tya
00168D  1  49 C3                eor #$c3
00168F  1  A8                   tay
001690  1  28                   plp
001691  1  8C 04 02             sty abst+1
001694  1  08                   php         ;flags after load/store sequence
001695  1  49 C3                eor #$c3
001697  1  A8                   tay
001698  1  C0 82                cpy #$82   ;test result
00169A  1  F0 03 20 FF          trap_ne
00169E  1  42           
00169F  1  68                   pla         ;load status
0016A0  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016A2  1  CD 1E 02             cmp fLDx+1  ;test flags
0016A5  1  F0 03 20 FF          trap_ne
0016A9  1  42           
0016AA  1  A9 FF 48 28          set_stat $ff
0016AE  1  A4 17                ldy zp1+2
0016B0  1  08                   php         ;test stores do not alter flags
0016B1  1  98                   tya
0016B2  1  49 C3                eor #$c3
0016B4  1  A8                   tay
0016B5  1  28                   plp
0016B6  1  8C 05 02             sty abst+2
0016B9  1  08                   php         ;flags after load/store sequence
0016BA  1  49 C3                eor #$c3
0016BC  1  A8                   tay
0016BD  1  C0 41                cpy #$41    ;test result
0016BF  1  F0 03 20 FF          trap_ne
0016C3  1  42           
0016C4  1  68                   pla         ;load status
0016C5  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016C7  1  CD 1F 02             cmp fLDx+2  ;test flags
0016CA  1  F0 03 20 FF          trap_ne
0016CE  1  42           
0016CF  1  A9 FF 48 28          set_stat $ff
0016D3  1  A4 18                ldy zp1+3
0016D5  1  08                   php         ;test stores do not alter flags
0016D6  1  98                   tya
0016D7  1  49 C3                eor #$c3
0016D9  1  A8                   tay
0016DA  1  28                   plp
0016DB  1  8C 06 02             sty abst+3
0016DE  1  08                   php         ;flags after load/store sequence
0016DF  1  49 C3                eor #$c3
0016E1  1  A8                   tay
0016E2  1  C0 00                cpy #0      ;test result
0016E4  1  F0 03 20 FF          trap_ne
0016E8  1  42           
0016E9  1  68                   pla         ;load status
0016EA  1  49 7D                eor_flag <~fnz ;mask bits not altered
0016EC  1  CD 20 02             cmp fLDx+3  ;test flags
0016EF  1  F0 03 20 FF          trap_ne
0016F3  1  42           
0016F4  1               
0016F4  1  A9 00 48 28          set_stat 0
0016F8  1  AC 18 02             ldy abs1
0016FB  1  08                   php         ;test stores do not alter flags
0016FC  1  98                   tya
0016FD  1  49 C3                eor #$c3
0016FF  1  A8                   tay
001700  1  28                   plp
001701  1  84 0C                sty zpt
001703  1  08                   php         ;flags after load/store sequence
001704  1  49 C3                eor #$c3
001706  1  A8                   tay
001707  1  C4 15                cpy zp1     ;test result
001709  1  F0 03 20 FF          trap_ne
00170D  1  42           
00170E  1  68                   pla         ;load status
00170F  1  49 30                eor_flag 0
001711  1  CD 1D 02             cmp fLDx    ;test flags
001714  1  F0 03 20 FF          trap_ne
001718  1  42           
001719  1  A9 00 48 28          set_stat 0
00171D  1  AC 19 02             ldy abs1+1
001720  1  08                   php         ;test stores do not alter flags
001721  1  98                   tya
001722  1  49 C3                eor #$c3
001724  1  A8                   tay
001725  1  28                   plp
001726  1  84 0D                sty zpt+1
001728  1  08                   php         ;flags after load/store sequence
001729  1  49 C3                eor #$c3
00172B  1  A8                   tay
00172C  1  C4 16                cpy zp1+1   ;test result
00172E  1  F0 03 20 FF          trap_ne
001732  1  42           
001733  1  68                   pla         ;load status
001734  1  49 30                eor_flag 0
001736  1  CD 1E 02             cmp fLDx+1  ;test flags
001739  1  F0 03 20 FF          trap_ne
00173D  1  42           
00173E  1  A9 00 48 28          set_stat 0
001742  1  AC 1A 02             ldy abs1+2
001745  1  08                   php         ;test stores do not alter flags
001746  1  98                   tya
001747  1  49 C3                eor #$c3
001749  1  A8                   tay
00174A  1  28                   plp
00174B  1  84 0E                sty zpt+2
00174D  1  08                   php         ;flags after load/store sequence
00174E  1  49 C3                eor #$c3
001750  1  A8                   tay
001751  1  C4 17                cpy zp1+2   ;test result
001753  1  F0 03 20 FF          trap_ne
001757  1  42           
001758  1  68                   pla         ;load status
001759  1  49 30                eor_flag 0
00175B  1  CD 1F 02             cmp fLDx+2  ;test flags
00175E  1  F0 03 20 FF          trap_ne
001762  1  42           
001763  1  A9 00 48 28          set_stat 0
001767  1  AC 1B 02             ldy abs1+3
00176A  1  08                   php         ;test stores do not alter flags
00176B  1  98                   tya
00176C  1  49 C3                eor #$c3
00176E  1  A8                   tay
00176F  1  28                   plp
001770  1  84 0F                sty zpt+3
001772  1  08                   php         ;flags after load/store sequence
001773  1  49 C3                eor #$c3
001775  1  A8                   tay
001776  1  C4 18                cpy zp1+3   ;test result
001778  1  F0 03 20 FF          trap_ne
00177C  1  42           
00177D  1  68                   pla         ;load status
00177E  1  49 30                eor_flag 0
001780  1  CD 20 02             cmp fLDx+3  ;test flags
001783  1  F0 03 20 FF          trap_ne
001787  1  42           
001788  1               
001788  1  A9 FF 48 28          set_stat $ff
00178C  1  AC 18 02             ldy abs1
00178F  1  08                   php         ;test stores do not alter flags
001790  1  98                   tya
001791  1  49 C3                eor #$c3
001793  1  A8                   tay
001794  1  28                   plp
001795  1  84 0C                sty zpt
001797  1  08                   php         ;flags after load/store sequence
001798  1  49 C3                eor #$c3
00179A  1  A8                   tay
00179B  1  C5 15                cmp zp1     ;test result
00179D  1  F0 03 20 FF          trap_ne
0017A1  1  42           
0017A2  1  68                   pla         ;load status
0017A3  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017A5  1  CD 1D 02             cmp fLDx    ;test flags
0017A8  1  F0 03 20 FF          trap_ne
0017AC  1  42           
0017AD  1  A9 FF 48 28          set_stat $ff
0017B1  1  AC 19 02             ldy abs1+1
0017B4  1  08                   php         ;test stores do not alter flags
0017B5  1  98                   tya
0017B6  1  49 C3                eor #$c3
0017B8  1  A8                   tay
0017B9  1  28                   plp
0017BA  1  84 0D                sty zpt+1
0017BC  1  08                   php         ;flags after load/store sequence
0017BD  1  49 C3                eor #$c3
0017BF  1  A8                   tay
0017C0  1  C5 16                cmp zp1+1   ;test result
0017C2  1  F0 03 20 FF          trap_ne
0017C6  1  42           
0017C7  1  68                   pla         ;load status
0017C8  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017CA  1  CD 1E 02             cmp fLDx+1  ;test flags
0017CD  1  F0 03 20 FF          trap_ne
0017D1  1  42           
0017D2  1  A9 FF 48 28          set_stat $ff
0017D6  1  AC 1A 02             ldy abs1+2
0017D9  1  08                   php         ;test stores do not alter flags
0017DA  1  98                   tya
0017DB  1  49 C3                eor #$c3
0017DD  1  A8                   tay
0017DE  1  28                   plp
0017DF  1  84 0E                sty zpt+2
0017E1  1  08                   php         ;flags after load/store sequence
0017E2  1  49 C3                eor #$c3
0017E4  1  A8                   tay
0017E5  1  C5 17                cmp zp1+2   ;test result
0017E7  1  F0 03 20 FF          trap_ne
0017EB  1  42           
0017EC  1  68                   pla         ;load status
0017ED  1  49 7D                eor_flag <~fnz ;mask bits not altered
0017EF  1  CD 1F 02             cmp fLDx+2  ;test flags
0017F2  1  F0 03 20 FF          trap_ne
0017F6  1  42           
0017F7  1  A9 FF 48 28          set_stat $ff
0017FB  1  AC 1B 02             ldy abs1+3
0017FE  1  08                   php         ;test stores do not alter flags
0017FF  1  98                   tya
001800  1  49 C3                eor #$c3
001802  1  A8                   tay
001803  1  28                   plp
001804  1  84 0F                sty zpt+3
001806  1  08                   php         ;flags after load/store sequence
001807  1  49 C3                eor #$c3
001809  1  A8                   tay
00180A  1  C5 18                cmp zp1+3   ;test result
00180C  1  F0 03 20 FF          trap_ne
001810  1  42           
001811  1  68                   pla         ;load status
001812  1  49 7D                eor_flag <~fnz ;mask bits not altered
001814  1  CD 20 02             cmp fLDx+3  ;test flags
001817  1  F0 03 20 FF          trap_ne
00181B  1  42           
00181C  1               
00181C  1               
00181C  1  A9 00 48 28          set_stat 0
001820  1  A0 C3                ldy #$c3
001822  1  08                   php
001823  1  CC 18 02             cpy abs1    ;test result
001826  1  F0 03 20 FF          trap_ne
00182A  1  42           
00182B  1  68                   pla         ;load status
00182C  1  49 30                eor_flag 0
00182E  1  CD 1D 02             cmp fLDx    ;test flags
001831  1  F0 03 20 FF          trap_ne
001835  1  42           
001836  1  A9 00 48 28          set_stat 0
00183A  1  A0 82                ldy #$82
00183C  1  08                   php
00183D  1  CC 19 02             cpy abs1+1  ;test result
001840  1  F0 03 20 FF          trap_ne
001844  1  42           
001845  1  68                   pla         ;load status
001846  1  49 30                eor_flag 0
001848  1  CD 1E 02             cmp fLDx+1  ;test flags
00184B  1  F0 03 20 FF          trap_ne
00184F  1  42           
001850  1  A9 00 48 28          set_stat 0
001854  1  A0 41                ldy #$41
001856  1  08                   php
001857  1  CC 1A 02             cpy abs1+2  ;test result
00185A  1  F0 03 20 FF          trap_ne
00185E  1  42           
00185F  1  68                   pla         ;load status
001860  1  49 30                eor_flag 0
001862  1  CD 1F 02             cmp fLDx+2  ;test flags
001865  1  F0 03 20 FF          trap_ne
001869  1  42           
00186A  1  A9 00 48 28          set_stat 0
00186E  1  A0 00                ldy #0
001870  1  08                   php
001871  1  CC 1B 02             cpy abs1+3  ;test result
001874  1  F0 03 20 FF          trap_ne
001878  1  42           
001879  1  68                   pla         ;load status
00187A  1  49 30                eor_flag 0
00187C  1  CD 20 02             cmp fLDx+3  ;test flags
00187F  1  F0 03 20 FF          trap_ne
001883  1  42           
001884  1               
001884  1  A9 FF 48 28          set_stat $ff
001888  1  A0 C3                ldy #$c3
00188A  1  08                   php
00188B  1  CC 18 02             cpy abs1    ;test result
00188E  1  F0 03 20 FF          trap_ne
001892  1  42           
001893  1  68                   pla         ;load status
001894  1  49 7D                eor_flag <~fnz ;mask bits not altered
001896  1  CD 1D 02             cmp fLDx    ;test flags
001899  1  F0 03 20 FF          trap_ne
00189D  1  42           
00189E  1  A9 FF 48 28          set_stat $ff
0018A2  1  A0 82                ldy #$82
0018A4  1  08                   php
0018A5  1  CC 19 02             cpy abs1+1  ;test result
0018A8  1  F0 03 20 FF          trap_ne
0018AC  1  42           
0018AD  1  68                   pla         ;load status
0018AE  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018B0  1  CD 1E 02             cmp fLDx+1  ;test flags
0018B3  1  F0 03 20 FF          trap_ne
0018B7  1  42           
0018B8  1  A9 FF 48 28          set_stat $ff
0018BC  1  A0 41                ldy #$41
0018BE  1  08                   php
0018BF  1  CC 1A 02             cpy abs1+2   ;test result
0018C2  1  F0 03 20 FF          trap_ne
0018C6  1  42           
0018C7  1  68                   pla         ;load status
0018C8  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018CA  1  CD 1F 02             cmp fLDx+2  ;test flags
0018CD  1  F0 03 20 FF          trap_ne
0018D1  1  42           
0018D2  1  A9 FF 48 28          set_stat $ff
0018D6  1  A0 00                ldy #0
0018D8  1  08                   php
0018D9  1  CC 1B 02             cpy abs1+3  ;test result
0018DC  1  F0 03 20 FF          trap_ne
0018E0  1  42           
0018E1  1  68                   pla         ;load status
0018E2  1  49 7D                eor_flag <~fnz ;mask bits not altered
0018E4  1  CD 20 02             cmp fLDx+3  ;test flags
0018E7  1  F0 03 20 FF          trap_ne
0018EB  1  42           
0018EC  1               
0018EC  1  A0 00                ldy #0
0018EE  1  A5 0C                lda zpt
0018F0  1  49 C3                eor #$c3
0018F2  1  C5 15                cmp zp1
0018F4  1  F0 03 20 FF          trap_ne     ;store to zp   data
0018F8  1  42           
0018F9  1  84 0C                sty zpt     ;clear
0018FB  1  AD 03 02             lda abst
0018FE  1  49 C3                eor #$c3
001900  1  CD 18 02             cmp abs1
001903  1  F0 03 20 FF          trap_ne     ;store to abs   data
001907  1  42           
001908  1  8C 03 02             sty abst    ;clear
00190B  1  A5 0D                lda zpt+1
00190D  1  49 C3                eor #$c3
00190F  1  C5 16                cmp zp1+1
001911  1  F0 03 20 FF          trap_ne     ;store to zp+1 data
001915  1  42           
001916  1  84 0D                sty zpt+1   ;clear
001918  1  AD 04 02             lda abst+1
00191B  1  49 C3                eor #$c3
00191D  1  CD 19 02             cmp abs1+1
001920  1  F0 03 20 FF          trap_ne     ;store to abs+1 data
001924  1  42           
001925  1  8C 04 02             sty abst+1  ;clear
001928  1  A5 0E                lda zpt+2
00192A  1  49 C3                eor #$c3
00192C  1  C5 17                cmp zp1+2
00192E  1  F0 03 20 FF          trap_ne     ;store to zp+2 data
001932  1  42           
001933  1  84 0E                sty zpt+2   ;clear
001935  1  AD 05 02             lda abst+2
001938  1  49 C3                eor #$c3
00193A  1  CD 1A 02             cmp abs1+2
00193D  1  F0 03 20 FF          trap_ne     ;store to abs+2 data
001941  1  42           
001942  1  8C 05 02             sty abst+2  ;clear
001945  1  A5 0F                lda zpt+3
001947  1  49 C3                eor #$c3
001949  1  C5 18                cmp zp1+3
00194B  1  F0 03 20 FF          trap_ne     ;store to zp+3 data
00194F  1  42           
001950  1  84 0F                sty zpt+3   ;clear
001952  1  AD 06 02             lda abst+3
001955  1  49 C3                eor #$c3
001957  1  CD 1B 02             cmp abs1+3
00195A  1  F0 03 20 FF          trap_ne     ;store to abs+3 data
00195E  1  42           
00195F  1  8C 06 02             sty abst+3  ;clear
001962  1  AD 00 02 C9          next_test
001966  1  14 F0 03 20  
00196A  1  FF 42 A9 15  
001971  1               
001971  1               ; testing load / store accumulator LDA / STA all addressing modes
001971  1               ; LDA / STA - zp,x / abs,x
001971  1  A2 03                ldx #3
001973  1               tldax:
001973  1  A9 00 48 28          set_stat 0
001977  1  B5 15                lda zp1,x
001979  1  08                   php         ;test stores do not alter flags
00197A  1  49 C3                eor #$c3
00197C  1  28                   plp
00197D  1  9D 03 02             sta abst,x
001980  1  08                   php         ;flags after load/store sequence
001981  1  49 C3                eor #$c3
001983  1  DD 18 02             cmp abs1,x  ;test result
001986  1  F0 03 20 FF          trap_ne
00198A  1  42           
00198B  1  68                   pla         ;load status
00198C  1  49 30                eor_flag 0
00198E  1  DD 1D 02             cmp fLDx,x  ;test flags
001991  1  F0 03 20 FF          trap_ne
001995  1  42           
001996  1  CA                   dex
001997  1  10 DA                bpl tldax
001999  1               
001999  1  A2 03                ldx #3
00199B  1               tldax1:
00199B  1  A9 FF 48 28          set_stat $ff
00199F  1  B5 15                lda zp1,x
0019A1  1  08                   php         ;test stores do not alter flags
0019A2  1  49 C3                eor #$c3
0019A4  1  28                   plp
0019A5  1  9D 03 02             sta abst,x
0019A8  1  08                   php         ;flags after load/store sequence
0019A9  1  49 C3                eor #$c3
0019AB  1  DD 18 02             cmp abs1,x   ;test result
0019AE  1  F0 03 20 FF          trap_ne
0019B2  1  42           
0019B3  1  68                   pla         ;load status
0019B4  1  49 7D                eor_flag <~fnz ;mask bits not altered
0019B6  1  DD 1D 02             cmp fLDx,x  ;test flags
0019B9  1  F0 03 20 FF          trap_ne
0019BD  1  42           
0019BE  1  CA                   dex
0019BF  1  10 DA                bpl tldax1
0019C1  1               
0019C1  1  A2 03                ldx #3
0019C3  1               tldax2:
0019C3  1  A9 00 48 28          set_stat 0
0019C7  1  BD 18 02             lda abs1,x
0019CA  1  08                   php         ;test stores do not alter flags
0019CB  1  49 C3                eor #$c3
0019CD  1  28                   plp
0019CE  1  95 0C                sta zpt,x
0019D0  1  08                   php         ;flags after load/store sequence
0019D1  1  49 C3                eor #$c3
0019D3  1  D5 15                cmp zp1,x   ;test result
0019D5  1  F0 03 20 FF          trap_ne
0019D9  1  42           
0019DA  1  68                   pla         ;load status
0019DB  1  49 30                eor_flag 0
0019DD  1  DD 1D 02             cmp fLDx,x  ;test flags
0019E0  1  F0 03 20 FF          trap_ne
0019E4  1  42           
0019E5  1  CA                   dex
0019E6  1  10 DB                bpl tldax2
0019E8  1               
0019E8  1  A2 03                ldx #3
0019EA  1               tldax3:
0019EA  1  A9 FF 48 28          set_stat $ff
0019EE  1  BD 18 02             lda abs1,x
0019F1  1  08                   php         ;test stores do not alter flags
0019F2  1  49 C3                eor #$c3
0019F4  1  28                   plp
0019F5  1  95 0C                sta zpt,x
0019F7  1  08                   php         ;flags after load/store sequence
0019F8  1  49 C3                eor #$c3
0019FA  1  D5 15                cmp zp1,x   ;test result
0019FC  1  F0 03 20 FF          trap_ne
001A00  1  42           
001A01  1  68                   pla         ;load status
001A02  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A04  1  DD 1D 02             cmp fLDx,x  ;test flags
001A07  1  F0 03 20 FF          trap_ne
001A0B  1  42           
001A0C  1  CA                   dex
001A0D  1  10 DB                bpl tldax3
001A0F  1               
001A0F  1  A2 03                ldx #3      ;testing store result
001A11  1  A0 00                ldy #0
001A13  1  B5 0C        tstax:  lda zpt,x
001A15  1  49 C3                eor #$c3
001A17  1  D5 15                cmp zp1,x
001A19  1  F0 03 20 FF          trap_ne     ;store to zp,x data
001A1D  1  42           
001A1E  1  94 0C                sty zpt,x   ;clear
001A20  1  BD 03 02             lda abst,x
001A23  1  49 C3                eor #$c3
001A25  1  DD 18 02             cmp abs1,x
001A28  1  F0 03 20 FF          trap_ne     ;store to abs,x data
001A2C  1  42           
001A2D  1  8A                   txa
001A2E  1  9D 03 02             sta abst,x  ;clear
001A31  1  CA                   dex
001A32  1  10 DF                bpl tstax
001A34  1  AD 00 02 C9          next_test
001A38  1  15 F0 03 20  
001A3C  1  FF 42 A9 16  
001A43  1               
001A43  1               ; LDA / STA - (zp),y / abs,y / (zp,x)
001A43  1  A0 03                ldy #3
001A45  1               tlday:
001A45  1  A9 00 48 28          set_stat 0
001A49  1  B1 26                lda (ind1),y
001A4B  1  08                   php         ;test stores do not alter flags
001A4C  1  49 C3                eor #$c3
001A4E  1  28                   plp
001A4F  1  99 03 02             sta abst,y
001A52  1  08                   php         ;flags after load/store sequence
001A53  1  49 C3                eor #$c3
001A55  1  D9 18 02             cmp abs1,y  ;test result
001A58  1  F0 03 20 FF          trap_ne
001A5C  1  42           
001A5D  1  68                   pla         ;load status
001A5E  1  49 30                eor_flag 0
001A60  1  D9 1D 02             cmp fLDx,y  ;test flags
001A63  1  F0 03 20 FF          trap_ne
001A67  1  42           
001A68  1  88                   dey
001A69  1  10 DA                bpl tlday
001A6B  1               
001A6B  1  A0 03                ldy #3
001A6D  1               tlday1:
001A6D  1  A9 FF 48 28          set_stat $ff
001A71  1  B1 26                lda (ind1),y
001A73  1  08                   php         ;test stores do not alter flags
001A74  1  49 C3                eor #$c3
001A76  1  28                   plp
001A77  1  99 03 02             sta abst,y
001A7A  1  08                   php         ;flags after load/store sequence
001A7B  1  49 C3                eor #$c3
001A7D  1  D9 18 02             cmp abs1,y  ;test result
001A80  1  F0 03 20 FF          trap_ne
001A84  1  42           
001A85  1  68                   pla         ;load status
001A86  1  49 7D                eor_flag <~fnz ;mask bits not altered
001A88  1  D9 1D 02             cmp fLDx,y  ;test flags
001A8B  1  F0 03 20 FF          trap_ne
001A8F  1  42           
001A90  1  88                   dey
001A91  1  10 DA                bpl tlday1
001A93  1               
001A93  1  A0 03                ldy #3      ;testing store result
001A95  1  A2 00                ldx #0
001A97  1  B9 03 02     tstay:  lda abst,y
001A9A  1  49 C3                eor #$c3
001A9C  1  D9 18 02             cmp abs1,y
001A9F  1  F0 03 20 FF          trap_ne     ;store to abs data
001AA3  1  42           
001AA4  1  8A                   txa
001AA5  1  99 03 02             sta abst,y  ;clear
001AA8  1  88                   dey
001AA9  1  10 EC                bpl tstay
001AAB  1               
001AAB  1  A0 03                ldy #3
001AAD  1               tlday2:
001AAD  1  A9 00 48 28          set_stat 0
001AB1  1  B9 18 02             lda abs1,y
001AB4  1  08                   php         ;test stores do not alter flags
001AB5  1  49 C3                eor #$c3
001AB7  1  28                   plp
001AB8  1  91 32                sta (indt),y
001ABA  1  08                   php         ;flags after load/store sequence
001ABB  1  49 C3                eor #$c3
001ABD  1  D1 26                cmp (ind1),y    ;test result
001ABF  1  F0 03 20 FF          trap_ne
001AC3  1  42           
001AC4  1  68                   pla         ;load status
001AC5  1  49 30                eor_flag 0
001AC7  1  D9 1D 02             cmp fLDx,y  ;test flags
001ACA  1  F0 03 20 FF          trap_ne
001ACE  1  42           
001ACF  1  88                   dey
001AD0  1  10 DB                bpl tlday2
001AD2  1               
001AD2  1  A0 03                ldy #3
001AD4  1               tlday3:
001AD4  1  A9 FF 48 28          set_stat $ff
001AD8  1  B9 18 02             lda abs1,y
001ADB  1  08                   php         ;test stores do not alter flags
001ADC  1  49 C3                eor #$c3
001ADE  1  28                   plp
001ADF  1  91 32                sta (indt),y
001AE1  1  08                   php         ;flags after load/store sequence
001AE2  1  49 C3                eor #$c3
001AE4  1  D1 26                cmp (ind1),y   ;test result
001AE6  1  F0 03 20 FF          trap_ne
001AEA  1  42           
001AEB  1  68                   pla         ;load status
001AEC  1  49 7D                eor_flag <~fnz ;mask bits not altered
001AEE  1  D9 1D 02             cmp fLDx,y  ;test flags
001AF1  1  F0 03 20 FF          trap_ne
001AF5  1  42           
001AF6  1  88                   dey
001AF7  1  10 DB                bpl tlday3
001AF9  1               
001AF9  1  A0 03                ldy #3      ;testing store result
001AFB  1  A2 00                ldx #0
001AFD  1  B9 03 02     tstay1: lda abst,y
001B00  1  49 C3                eor #$c3
001B02  1  D9 18 02             cmp abs1,y
001B05  1  F0 03 20 FF          trap_ne     ;store to abs data
001B09  1  42           
001B0A  1  8A                   txa
001B0B  1  99 03 02             sta abst,y  ;clear
001B0E  1  88                   dey
001B0F  1  10 EC                bpl tstay1
001B11  1               
001B11  1  A2 06                ldx #6
001B13  1  A0 03                ldy #3
001B15  1               tldax4:
001B15  1  A9 00 48 28          set_stat 0
001B19  1  A1 26                lda (ind1,x)
001B1B  1  08                   php         ;test stores do not alter flags
001B1C  1  49 C3                eor #$c3
001B1E  1  28                   plp
001B1F  1  81 32                sta (indt,x)
001B21  1  08                   php         ;flags after load/store sequence
001B22  1  49 C3                eor #$c3
001B24  1  D9 18 02             cmp abs1,y  ;test result
001B27  1  F0 03 20 FF          trap_ne
001B2B  1  42           
001B2C  1  68                   pla         ;load status
001B2D  1  49 30                eor_flag 0
001B2F  1  D9 1D 02             cmp fLDx,y  ;test flags
001B32  1  F0 03 20 FF          trap_ne
001B36  1  42           
001B37  1  CA                   dex
001B38  1  CA                   dex
001B39  1  88                   dey
001B3A  1  10 D9                bpl tldax4
001B3C  1               
001B3C  1  A2 06                ldx #6
001B3E  1  A0 03                ldy #3
001B40  1               tldax5:
001B40  1  A9 FF 48 28          set_stat $ff
001B44  1  A1 26                lda (ind1,x)
001B46  1  08                   php         ;test stores do not alter flags
001B47  1  49 C3                eor #$c3
001B49  1  28                   plp
001B4A  1  81 32                sta (indt,x)
001B4C  1  08                   php         ;flags after load/store sequence
001B4D  1  49 C3                eor #$c3
001B4F  1  D9 18 02             cmp abs1,y  ;test result
001B52  1  F0 03 20 FF          trap_ne
001B56  1  42           
001B57  1  68                   pla         ;load status
001B58  1  49 7D                eor_flag <~fnz ;mask bits not altered
001B5A  1  D9 1D 02             cmp fLDx,y  ;test flags
001B5D  1  F0 03 20 FF          trap_ne
001B61  1  42           
001B62  1  CA                   dex
001B63  1  CA                   dex
001B64  1  88                   dey
001B65  1  10 D9                bpl tldax5
001B67  1               
001B67  1  A0 03                ldy #3      ;testing store result
001B69  1  A2 00                ldx #0
001B6B  1  B9 03 02     tstay2: lda abst,y
001B6E  1  49 C3                eor #$c3
001B70  1  D9 18 02             cmp abs1,y
001B73  1  F0 03 20 FF          trap_ne     ;store to abs data
001B77  1  42           
001B78  1  8A                   txa
001B79  1  99 03 02             sta abst,y  ;clear
001B7C  1  88                   dey
001B7D  1  10 EC                bpl tstay2
001B7F  1  AD 00 02 C9          next_test
001B83  1  16 F0 03 20  
001B87  1  FF 42 A9 17  
001B8E  1               
001B8E  1               ; indexed wraparound test (only zp should wrap)
001B8E  1  A2 FD                ldx #3+$fa
001B90  1  B5 1B        tldax6: lda <(zp1-$fa),x   ;wrap on indexed zp
001B92  1  9D 09 01             sta abst-$fa,x      ;no STX abs,x!
001B95  1  CA                   dex
001B96  1  E0 FA                cpx #$fa
001B98  1  B0 F6                bcs tldax6
001B9A  1  A2 FD                ldx #3+$fa
001B9C  1  BD 1E 01     tldax7: lda abs1-$fa,x      ;no wrap on indexed abs
001B9F  1  95 12                sta <(zpt-$fa),x
001BA1  1  CA                   dex
001BA2  1  E0 FA                cpx #$fa
001BA4  1  B0 F6                bcs tldax7
001BA6  1               
001BA6  1  A2 03                ldx #3      ;testing wraparound result
001BA8  1  A0 00                ldy #0
001BAA  1  B5 0C        tstax1: lda zpt,x
001BAC  1  D5 15                cmp zp1,x
001BAE  1  F0 03 20 FF          trap_ne     ;store to zp,x data
001BB2  1  42           
001BB3  1  94 0C                sty zpt,x   ;clear
001BB5  1  BD 03 02             lda abst,x
001BB8  1  DD 18 02             cmp abs1,x
001BBB  1  F0 03 20 FF          trap_ne     ;store to abs,x data
001BBF  1  42           
001BC0  1  8A                   txa
001BC1  1  9D 03 02             sta abst,x  ;clear
001BC4  1  CA                   dex
001BC5  1  10 E3                bpl tstax1
001BC7  1               
001BC7  1  A0 FB                ldy #3+$f8
001BC9  1  A2 FE                ldx #6+$f8
001BCB  1  A1 2E        tlday4: lda (<(ind1-$f8),x) ;wrap on indexed zp indirect
001BCD  1  99 0B 01             sta abst-$f8,y
001BD0  1  CA                   dex
001BD1  1  CA                   dex
001BD2  1  88                   dey
001BD3  1  C0 F8                cpy #$f8
001BD5  1  B0 F4                bcs tlday4
001BD7  1  A0 03                ldy #3      ;testing wraparound result
001BD9  1  A2 00                ldx #0
001BDB  1  B9 03 02     tstay4: lda abst,y
001BDE  1  D9 18 02             cmp abs1,y
001BE1  1  F0 03 20 FF          trap_ne     ;store to abs data
001BE5  1  42           
001BE6  1  8A                   txa
001BE7  1  99 03 02             sta abst,y  ;clear
001BEA  1  88                   dey
001BEB  1  10 EE                bpl tstay4
001BED  1               
001BED  1  A0 FB                ldy #3+$f8
001BEF  1  B9 20 01     tlday5: lda abs1-$f8,y  ;no wrap on indexed abs
001BF2  1  91 3A                sta (inwt),y
001BF4  1  88                   dey
001BF5  1  C0 F8                cpy #$f8
001BF7  1  B0 F6                bcs tlday5
001BF9  1  A0 03                ldy #3      ;testing wraparound result
001BFB  1  A2 00                ldx #0
001BFD  1  B9 03 02     tstay5: lda abst,y
001C00  1  D9 18 02             cmp abs1,y
001C03  1  F0 03 20 FF          trap_ne     ;store to abs data
001C07  1  42           
001C08  1  8A                   txa
001C09  1  99 03 02             sta abst,y  ;clear
001C0C  1  88                   dey
001C0D  1  10 EE                bpl tstay5
001C0F  1               
001C0F  1  A0 FB                ldy #3+$f8
001C11  1  A2 FE                ldx #6+$f8
001C13  1  B1 30        tlday6: lda (inw1),y    ;no wrap on zp indirect indexed
001C15  1  81 3A                sta (<(indt-$f8),x)
001C17  1  CA                   dex
001C18  1  CA                   dex
001C19  1  88                   dey
001C1A  1  C0 F8                cpy #$f8
001C1C  1  B0 F5                bcs tlday6
001C1E  1  A0 03                ldy #3      ;testing wraparound result
001C20  1  A2 00                ldx #0
001C22  1  B9 03 02     tstay6: lda abst,y
001C25  1  D9 18 02             cmp abs1,y
001C28  1  F0 03 20 FF          trap_ne     ;store to abs data
001C2C  1  42           
001C2D  1  8A                   txa
001C2E  1  99 03 02             sta abst,y  ;clear
001C31  1  88                   dey
001C32  1  10 EE                bpl tstay6
001C34  1  AD 00 02 C9          next_test
001C38  1  17 F0 03 20  
001C3C  1  FF 42 A9 18  
001C43  1               
001C43  1               ; LDA / STA - zp / abs / #
001C43  1  A9 00 48 28          set_stat 0
001C47  1  A5 15                lda zp1
001C49  1  08                   php         ;test stores do not alter flags
001C4A  1  49 C3                eor #$c3
001C4C  1  28                   plp
001C4D  1  8D 03 02             sta abst
001C50  1  08                   php         ;flags after load/store sequence
001C51  1  49 C3                eor #$c3
001C53  1  C9 C3                cmp #$c3    ;test result
001C55  1  F0 03 20 FF          trap_ne
001C59  1  42           
001C5A  1  68                   pla         ;load status
001C5B  1  49 30                eor_flag 0
001C5D  1  CD 1D 02             cmp fLDx    ;test flags
001C60  1  F0 03 20 FF          trap_ne
001C64  1  42           
001C65  1  A9 00 48 28          set_stat 0
001C69  1  A5 16                lda zp1+1
001C6B  1  08                   php         ;test stores do not alter flags
001C6C  1  49 C3                eor #$c3
001C6E  1  28                   plp
001C6F  1  8D 04 02             sta abst+1
001C72  1  08                   php         ;flags after load/store sequence
001C73  1  49 C3                eor #$c3
001C75  1  C9 82                cmp #$82    ;test result
001C77  1  F0 03 20 FF          trap_ne
001C7B  1  42           
001C7C  1  68                   pla         ;load status
001C7D  1  49 30                eor_flag 0
001C7F  1  CD 1E 02             cmp fLDx+1  ;test flags
001C82  1  F0 03 20 FF          trap_ne
001C86  1  42           
001C87  1  A9 00 48 28          set_stat 0
001C8B  1  A5 17                lda zp1+2
001C8D  1  08                   php         ;test stores do not alter flags
001C8E  1  49 C3                eor #$c3
001C90  1  28                   plp
001C91  1  8D 05 02             sta abst+2
001C94  1  08                   php         ;flags after load/store sequence
001C95  1  49 C3                eor #$c3
001C97  1  C9 41                cmp #$41    ;test result
001C99  1  F0 03 20 FF          trap_ne
001C9D  1  42           
001C9E  1  68                   pla         ;load status
001C9F  1  49 30                eor_flag 0
001CA1  1  CD 1F 02             cmp fLDx+2  ;test flags
001CA4  1  F0 03 20 FF          trap_ne
001CA8  1  42           
001CA9  1  A9 00 48 28          set_stat 0
001CAD  1  A5 18                lda zp1+3
001CAF  1  08                   php         ;test stores do not alter flags
001CB0  1  49 C3                eor #$c3
001CB2  1  28                   plp
001CB3  1  8D 06 02             sta abst+3
001CB6  1  08                   php         ;flags after load/store sequence
001CB7  1  49 C3                eor #$c3
001CB9  1  C9 00                cmp #0      ;test result
001CBB  1  F0 03 20 FF          trap_ne
001CBF  1  42           
001CC0  1  68                   pla         ;load status
001CC1  1  49 30                eor_flag 0
001CC3  1  CD 20 02             cmp fLDx+3  ;test flags
001CC6  1  F0 03 20 FF          trap_ne
001CCA  1  42           
001CCB  1  A9 FF 48 28          set_stat $ff
001CCF  1  A5 15                lda zp1
001CD1  1  08                   php         ;test stores do not alter flags
001CD2  1  49 C3                eor #$c3
001CD4  1  28                   plp
001CD5  1  8D 03 02             sta abst
001CD8  1  08                   php         ;flags after load/store sequence
001CD9  1  49 C3                eor #$c3
001CDB  1  C9 C3                cmp #$c3    ;test result
001CDD  1  F0 03 20 FF          trap_ne
001CE1  1  42           
001CE2  1  68                   pla         ;load status
001CE3  1  49 7D                eor_flag <~fnz ;mask bits not altered
001CE5  1  CD 1D 02             cmp fLDx    ;test flags
001CE8  1  F0 03 20 FF          trap_ne
001CEC  1  42           
001CED  1  A9 FF 48 28          set_stat $ff
001CF1  1  A5 16                lda zp1+1
001CF3  1  08                   php         ;test stores do not alter flags
001CF4  1  49 C3                eor #$c3
001CF6  1  28                   plp
001CF7  1  8D 04 02             sta abst+1
001CFA  1  08                   php         ;flags after load/store sequence
001CFB  1  49 C3                eor #$c3
001CFD  1  C9 82                cmp #$82    ;test result
001CFF  1  F0 03 20 FF          trap_ne
001D03  1  42           
001D04  1  68                   pla         ;load status
001D05  1  49 7D                eor_flag <~fnz ;mask bits not altered
001D07  1  CD 1E 02             cmp fLDx+1  ;test flags
001D0A  1  F0 03 20 FF          trap_ne
001D0E  1  42           
001D0F  1  A9 FF 48 28          set_stat $ff
001D13  1  A5 17                lda zp1+2
001D15  1  08                   php         ;test stores do not alter flags
001D16  1  49 C3                eor #$c3
001D18  1  28                   plp
001D19  1  8D 05 02             sta abst+2
001D1C  1  08                   php         ;flags after load/store sequence
001D1D  1  49 C3                eor #$c3
001D1F  1  C9 41                cmp #$41    ;test result
001D21  1  F0 03 20 FF          trap_ne
001D25  1  42           
001D26  1  68                   pla         ;load status
001D27  1  49 7D                eor_flag <~fnz ;mask bits not altered
001D29  1  CD 1F 02             cmp fLDx+2  ;test flags
001D2C  1  F0 03 20 FF          trap_ne
001D30  1  42           
001D31  1  A9 FF 48 28          set_stat $ff
001D35  1  A5 18                lda zp1+3
001D37  1  08                   php         ;test stores do not alter flags
001D38  1  49 C3                eor #$c3
001D3A  1  28                   plp
001D3B  1  8D 06 02             sta abst+3
001D3E  1  08                   php         ;flags after load/store sequence
001D3F  1  49 C3                eor #$c3
001D41  1  C9 00                cmp #0      ;test result
001D43  1  F0 03 20 FF          trap_ne
001D47  1  42           
001D48  1  68                   pla         ;load status
001D49  1  49 7D                eor_flag <~fnz ;mask bits not altered
001D4B  1  CD 20 02             cmp fLDx+3  ;test flags
001D4E  1  F0 03 20 FF          trap_ne
001D52  1  42           
001D53  1  A9 00 48 28          set_stat 0
001D57  1  AD 18 02             lda abs1
001D5A  1  08                   php         ;test stores do not alter flags
001D5B  1  49 C3                eor #$c3
001D5D  1  28                   plp
001D5E  1  85 0C                sta zpt
001D60  1  08                   php         ;flags after load/store sequence
001D61  1  49 C3                eor #$c3
001D63  1  C5 15                cmp zp1     ;test result
001D65  1  F0 03 20 FF          trap_ne
001D69  1  42           
001D6A  1  68                   pla         ;load status
001D6B  1  49 30                eor_flag 0
001D6D  1  CD 1D 02             cmp fLDx    ;test flags
001D70  1  F0 03 20 FF          trap_ne
001D74  1  42           
001D75  1  A9 00 48 28          set_stat 0
001D79  1  AD 19 02             lda abs1+1
001D7C  1  08                   php         ;test stores do not alter flags
001D7D  1  49 C3                eor #$c3
001D7F  1  28                   plp
001D80  1  85 0D                sta zpt+1
001D82  1  08                   php         ;flags after load/store sequence
001D83  1  49 C3                eor #$c3
001D85  1  C5 16                cmp zp1+1   ;test result
001D87  1  F0 03 20 FF          trap_ne
001D8B  1  42           
001D8C  1  68                   pla         ;load status
001D8D  1  49 30                eor_flag 0
001D8F  1  CD 1E 02             cmp fLDx+1  ;test flags
001D92  1  F0 03 20 FF          trap_ne
001D96  1  42           
001D97  1  A9 00 48 28          set_stat 0
001D9B  1  AD 1A 02             lda abs1+2
001D9E  1  08                   php         ;test stores do not alter flags
001D9F  1  49 C3                eor #$c3
001DA1  1  28                   plp
001DA2  1  85 0E                sta zpt+2
001DA4  1  08                   php         ;flags after load/store sequence
001DA5  1  49 C3                eor #$c3
001DA7  1  C5 17                cmp zp1+2   ;test result
001DA9  1  F0 03 20 FF          trap_ne
001DAD  1  42           
001DAE  1  68                   pla         ;load status
001DAF  1  49 30                eor_flag 0
001DB1  1  CD 1F 02             cmp fLDx+2  ;test flags
001DB4  1  F0 03 20 FF          trap_ne
001DB8  1  42           
001DB9  1  A9 00 48 28          set_stat 0
001DBD  1  AD 1B 02             lda abs1+3
001DC0  1  08                   php         ;test stores do not alter flags
001DC1  1  49 C3                eor #$c3
001DC3  1  28                   plp
001DC4  1  85 0F                sta zpt+3
001DC6  1  08                   php         ;flags after load/store sequence
001DC7  1  49 C3                eor #$c3
001DC9  1  C5 18                cmp zp1+3   ;test result
001DCB  1  F0 03 20 FF          trap_ne
001DCF  1  42           
001DD0  1  68                   pla         ;load status
001DD1  1  49 30                eor_flag 0
001DD3  1  CD 20 02             cmp fLDx+3  ;test flags
001DD6  1  F0 03 20 FF          trap_ne
001DDA  1  42           
001DDB  1  A9 FF 48 28          set_stat $ff
001DDF  1  AD 18 02             lda abs1
001DE2  1  08                   php         ;test stores do not alter flags
001DE3  1  49 C3                eor #$c3
001DE5  1  28                   plp
001DE6  1  85 0C                sta zpt
001DE8  1  08                   php         ;flags after load/store sequence
001DE9  1  49 C3                eor #$c3
001DEB  1  C5 15                cmp zp1     ;test result
001DED  1  F0 03 20 FF          trap_ne
001DF1  1  42           
001DF2  1  68                   pla         ;load status
001DF3  1  49 7D                eor_flag <~fnz ;mask bits not altered
001DF5  1  CD 1D 02             cmp fLDx    ;test flags
001DF8  1  F0 03 20 FF          trap_ne
001DFC  1  42           
001DFD  1  A9 FF 48 28          set_stat $ff
001E01  1  AD 19 02             lda abs1+1
001E04  1  08                   php         ;test stores do not alter flags
001E05  1  49 C3                eor #$c3
001E07  1  28                   plp
001E08  1  85 0D                sta zpt+1
001E0A  1  08                   php         ;flags after load/store sequence
001E0B  1  49 C3                eor #$c3
001E0D  1  C5 16                cmp zp1+1   ;test result
001E0F  1  F0 03 20 FF          trap_ne
001E13  1  42           
001E14  1  68                   pla         ;load status
001E15  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E17  1  CD 1E 02             cmp fLDx+1  ;test flags
001E1A  1  F0 03 20 FF          trap_ne
001E1E  1  42           
001E1F  1  A9 FF 48 28          set_stat $ff
001E23  1  AD 1A 02             lda abs1+2
001E26  1  08                   php         ;test stores do not alter flags
001E27  1  49 C3                eor #$c3
001E29  1  28                   plp
001E2A  1  85 0E                sta zpt+2
001E2C  1  08                   php         ;flags after load/store sequence
001E2D  1  49 C3                eor #$c3
001E2F  1  C5 17                cmp zp1+2   ;test result
001E31  1  F0 03 20 FF          trap_ne
001E35  1  42           
001E36  1  68                   pla         ;load status
001E37  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E39  1  CD 1F 02             cmp fLDx+2  ;test flags
001E3C  1  F0 03 20 FF          trap_ne
001E40  1  42           
001E41  1  A9 FF 48 28          set_stat $ff
001E45  1  AD 1B 02             lda abs1+3
001E48  1  08                   php         ;test stores do not alter flags
001E49  1  49 C3                eor #$c3
001E4B  1  28                   plp
001E4C  1  85 0F                sta zpt+3
001E4E  1  08                   php         ;flags after load/store sequence
001E4F  1  49 C3                eor #$c3
001E51  1  C5 18                cmp zp1+3   ;test result
001E53  1  F0 03 20 FF          trap_ne
001E57  1  42           
001E58  1  68                   pla         ;load status
001E59  1  49 7D                eor_flag <~fnz ;mask bits not altered
001E5B  1  CD 20 02             cmp fLDx+3  ;test flags
001E5E  1  F0 03 20 FF          trap_ne
001E62  1  42           
001E63  1  A9 00 48 28          set_stat 0
001E67  1  A9 C3                lda #$c3
001E69  1  08                   php
001E6A  1  CD 18 02             cmp abs1    ;test result
001E6D  1  F0 03 20 FF          trap_ne
001E71  1  42           
001E72  1  68                   pla         ;load status
001E73  1  49 30                eor_flag 0
001E75  1  CD 1D 02             cmp fLDx    ;test flags
001E78  1  F0 03 20 FF          trap_ne
001E7C  1  42           
001E7D  1  A9 00 48 28          set_stat 0
001E81  1  A9 82                lda #$82
001E83  1  08                   php
001E84  1  CD 19 02             cmp abs1+1  ;test result
001E87  1  F0 03 20 FF          trap_ne
001E8B  1  42           
001E8C  1  68                   pla         ;load status
001E8D  1  49 30                eor_flag 0
001E8F  1  CD 1E 02             cmp fLDx+1  ;test flags
001E92  1  F0 03 20 FF          trap_ne
001E96  1  42           
001E97  1  A9 00 48 28          set_stat 0
001E9B  1  A9 41                lda #$41
001E9D  1  08                   php
001E9E  1  CD 1A 02             cmp abs1+2  ;test result
001EA1  1  F0 03 20 FF          trap_ne
001EA5  1  42           
001EA6  1  68                   pla         ;load status
001EA7  1  49 30                eor_flag 0
001EA9  1  CD 1F 02             cmp fLDx+2  ;test flags
001EAC  1  F0 03 20 FF          trap_ne
001EB0  1  42           
001EB1  1  A9 00 48 28          set_stat 0
001EB5  1  A9 00                lda #0
001EB7  1  08                   php
001EB8  1  CD 1B 02             cmp abs1+3  ;test result
001EBB  1  F0 03 20 FF          trap_ne
001EBF  1  42           
001EC0  1  68                   pla         ;load status
001EC1  1  49 30                eor_flag 0
001EC3  1  CD 20 02             cmp fLDx+3  ;test flags
001EC6  1  F0 03 20 FF          trap_ne
001ECA  1  42           
001ECB  1               
001ECB  1  A9 FF 48 28          set_stat $ff
001ECF  1  A9 C3                lda #$c3
001ED1  1  08                   php
001ED2  1  CD 18 02             cmp abs1    ;test result
001ED5  1  F0 03 20 FF          trap_ne
001ED9  1  42           
001EDA  1  68                   pla         ;load status
001EDB  1  49 7D                eor_flag <~fnz ;mask bits not altered
001EDD  1  CD 1D 02             cmp fLDx    ;test flags
001EE0  1  F0 03 20 FF          trap_ne
001EE4  1  42           
001EE5  1  A9 FF 48 28          set_stat $ff
001EE9  1  A9 82                lda #$82
001EEB  1  08                   php
001EEC  1  CD 19 02             cmp abs1+1  ;test result
001EEF  1  F0 03 20 FF          trap_ne
001EF3  1  42           
001EF4  1  68                   pla         ;load status
001EF5  1  49 7D                eor_flag <~fnz ;mask bits not altered
001EF7  1  CD 1E 02             cmp fLDx+1  ;test flags
001EFA  1  F0 03 20 FF          trap_ne
001EFE  1  42           
001EFF  1  A9 FF 48 28          set_stat $ff
001F03  1  A9 41                lda #$41
001F05  1  08                   php
001F06  1  CD 1A 02             cmp abs1+2  ;test result
001F09  1  F0 03 20 FF          trap_ne
001F0D  1  42           
001F0E  1  68                   pla         ;load status
001F0F  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F11  1  CD 1F 02             cmp fLDx+2  ;test flags
001F14  1  F0 03 20 FF          trap_ne
001F18  1  42           
001F19  1  A9 FF 48 28          set_stat $ff
001F1D  1  A9 00                lda #0
001F1F  1  08                   php
001F20  1  CD 1B 02             cmp abs1+3  ;test result
001F23  1  F0 03 20 FF          trap_ne
001F27  1  42           
001F28  1  68                   pla         ;load status
001F29  1  49 7D                eor_flag <~fnz ;mask bits not altered
001F2B  1  CD 20 02             cmp fLDx+3  ;test flags
001F2E  1  F0 03 20 FF          trap_ne
001F32  1  42           
001F33  1               
001F33  1  A2 00                ldx #0
001F35  1  A5 0C                lda zpt
001F37  1  49 C3                eor #$c3
001F39  1  C5 15                cmp zp1
001F3B  1  F0 03 20 FF          trap_ne     ;store to zp data
001F3F  1  42           
001F40  1  86 0C                stx zpt     ;clear
001F42  1  AD 03 02             lda abst
001F45  1  49 C3                eor #$c3
001F47  1  CD 18 02             cmp abs1
001F4A  1  F0 03 20 FF          trap_ne     ;store to abs data
001F4E  1  42           
001F4F  1  8E 03 02             stx abst    ;clear
001F52  1  A5 0D                lda zpt+1
001F54  1  49 C3                eor #$c3
001F56  1  C5 16                cmp zp1+1
001F58  1  F0 03 20 FF          trap_ne     ;store to zp data
001F5C  1  42           
001F5D  1  86 0D                stx zpt+1   ;clear
001F5F  1  AD 04 02             lda abst+1
001F62  1  49 C3                eor #$c3
001F64  1  CD 19 02             cmp abs1+1
001F67  1  F0 03 20 FF          trap_ne     ;store to abs data
001F6B  1  42           
001F6C  1  8E 04 02             stx abst+1  ;clear
001F6F  1  A5 0E                lda zpt+2
001F71  1  49 C3                eor #$c3
001F73  1  C5 17                cmp zp1+2
001F75  1  F0 03 20 FF          trap_ne     ;store to zp data
001F79  1  42           
001F7A  1  86 0E                stx zpt+2   ;clear
001F7C  1  AD 05 02             lda abst+2
001F7F  1  49 C3                eor #$c3
001F81  1  CD 1A 02             cmp abs1+2
001F84  1  F0 03 20 FF          trap_ne     ;store to abs data
001F88  1  42           
001F89  1  8E 05 02             stx abst+2  ;clear
001F8C  1  A5 0F                lda zpt+3
001F8E  1  49 C3                eor #$c3
001F90  1  C5 18                cmp zp1+3
001F92  1  F0 03 20 FF          trap_ne     ;store to zp data
001F96  1  42           
001F97  1  86 0F                stx zpt+3   ;clear
001F99  1  AD 06 02             lda abst+3
001F9C  1  49 C3                eor #$c3
001F9E  1  CD 1B 02             cmp abs1+3
001FA1  1  F0 03 20 FF          trap_ne     ;store to abs data
001FA5  1  42           
001FA6  1  8E 06 02             stx abst+3  ;clear
001FA9  1  AD 00 02 C9          next_test
001FAD  1  18 F0 03 20  
001FB1  1  FF 42 A9 19  
001FB8  1               
001FB8  1               ; testing bit test & compares BIT CPX CPY CMP all addressing modes
001FB8  1               ; BIT - zp / abs
001FB8  1  A9 00 48 A9          set_a $ff,0
001FBC  1  FF 28        
001FBE  1  24 18                bit zp1+3   ;00 - should set Z / clear  NV
001FC0  1  08 C9 FF F0          tst_a $ff,fz
001FC4  1  03 20 FF 42  
001FC8  1  68 48 C9 32  
001FD2  1  A9 00 48 A9          set_a 1,0
001FD6  1  01 28        
001FD8  1  24 17                bit zp1+2   ;41 - should set V (M6) / clear NZ
001FDA  1  08 C9 01 F0          tst_a 1,fv
001FDE  1  03 20 FF 42  
001FE2  1  68 48 C9 70  
001FEC  1  A9 00 48 A9          set_a 1,0
001FF0  1  01 28        
001FF2  1  24 16                bit zp1+1   ;82 - should set N (M7) & Z / clear V
001FF4  1  08 C9 01 F0          tst_a 1,fnz
001FF8  1  03 20 FF 42  
001FFC  1  68 48 C9 B2  
002006  1  A9 00 48 A9          set_a 1,0
00200A  1  01 28        
00200C  1  24 15                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
00200E  1  08 C9 01 F0          tst_a 1,fnv
002012  1  03 20 FF 42  
002016  1  68 48 C9 F0  
002020  1               
002020  1  A9 FF 48 A9          set_a $ff,$ff
002024  1  FF 28        
002026  1  24 18                bit zp1+3   ;00 - should set Z / clear  NV
002028  1  08 C9 FF F0          tst_a $ff,~fnv
00202C  1  03 20 FF 42  
002030  1  68 48 C9 3F  
00203A  1  A9 FF 48 A9          set_a 1,$ff
00203E  1  01 28        
002040  1  24 17                bit zp1+2   ;41 - should set V (M6) / clear NZ
002042  1  08 C9 01 F0          tst_a 1,~fnz
002046  1  03 20 FF 42  
00204A  1  68 48 C9 7D  
002054  1  A9 FF 48 A9          set_a 1,$ff
002058  1  01 28        
00205A  1  24 16                bit zp1+1   ;82 - should set N (M7) & Z / clear V
00205C  1  08 C9 01 F0          tst_a 1,~fv
002060  1  03 20 FF 42  
002064  1  68 48 C9 BF  
00206E  1  A9 FF 48 A9          set_a 1,$ff
002072  1  01 28        
002074  1  24 15                bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
002076  1  08 C9 01 F0          tst_a 1,~fz
00207A  1  03 20 FF 42  
00207E  1  68 48 C9 FD  
002088  1               
002088  1  A9 00 48 A9          set_a $ff,0
00208C  1  FF 28        
00208E  1  2C 1B 02             bit abs1+3  ;00 - should set Z / clear  NV
002091  1  08 C9 FF F0          tst_a $ff,fz
002095  1  03 20 FF 42  
002099  1  68 48 C9 32  
0020A3  1  A9 00 48 A9          set_a 1,0
0020A7  1  01 28        
0020A9  1  2C 1A 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
0020AC  1  08 C9 01 F0          tst_a 1,fv
0020B0  1  03 20 FF 42  
0020B4  1  68 48 C9 70  
0020BE  1  A9 00 48 A9          set_a 1,0
0020C2  1  01 28        
0020C4  1  2C 19 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
0020C7  1  08 C9 01 F0          tst_a 1,fnz
0020CB  1  03 20 FF 42  
0020CF  1  68 48 C9 B2  
0020D9  1  A9 00 48 A9          set_a 1,0
0020DD  1  01 28        
0020DF  1  2C 18 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
0020E2  1  08 C9 01 F0          tst_a 1,fnv
0020E6  1  03 20 FF 42  
0020EA  1  68 48 C9 F0  
0020F4  1               
0020F4  1  A9 FF 48 A9          set_a $ff,$ff
0020F8  1  FF 28        
0020FA  1  2C 1B 02             bit abs1+3  ;00 - should set Z / clear  NV
0020FD  1  08 C9 FF F0          tst_a $ff,~fnv
002101  1  03 20 FF 42  
002105  1  68 48 C9 3F  
00210F  1  A9 FF 48 A9          set_a 1,$ff
002113  1  01 28        
002115  1  2C 1A 02             bit abs1+2  ;41 - should set V (M6) / clear NZ
002118  1  08 C9 01 F0          tst_a 1,~fnz
00211C  1  03 20 FF 42  
002120  1  68 48 C9 7D  
00212A  1  A9 FF 48 A9          set_a 1,$ff
00212E  1  01 28        
002130  1  2C 19 02             bit abs1+1  ;82 - should set N (M7) & Z / clear V
002133  1  08 C9 01 F0          tst_a 1,~fv
002137  1  03 20 FF 42  
00213B  1  68 48 C9 BF  
002145  1  A9 FF 48 A9          set_a 1,$ff
002149  1  01 28        
00214B  1  2C 18 02             bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
00214E  1  08 C9 01 F0          tst_a 1,~fz
002152  1  03 20 FF 42  
002156  1  68 48 C9 FD  
002160  1  AD 00 02 C9          next_test
002164  1  19 F0 03 20  
002168  1  FF 42 A9 1A  
00216F  1               
00216F  1               ; CPX - zp / abs / #
00216F  1  A9 00 48 A2          set_x $80,0
002173  1  80 28        
002175  1  E4 19                cpx zp7f
002177  1  08 68 48 C9          tst_stat fc
00217B  1  31 F0 03 20  
00217F  1  FF 42 28     
002182  1  CA                   dex
002183  1  E4 19                cpx zp7f
002185  1  08 68 48 C9          tst_stat fzc
002189  1  33 F0 03 20  
00218D  1  FF 42 28     
002190  1  CA                   dex
002191  1  E4 19                cpx zp7f
002193  1  08 E0 7E F0          tst_x $7e,fn
002197  1  03 20 FF 42  
00219B  1  68 48 C9 B0  
0021A5  1  A9 FF 48 A2          set_x $80,$ff
0021A9  1  80 28        
0021AB  1  E4 19                cpx zp7f
0021AD  1  08 68 48 C9          tst_stat ~fnz
0021B1  1  7D F0 03 20  
0021B5  1  FF 42 28     
0021B8  1  CA                   dex
0021B9  1  E4 19                cpx zp7f
0021BB  1  08 68 48 C9          tst_stat ~fn
0021BF  1  7F F0 03 20  
0021C3  1  FF 42 28     
0021C6  1  CA                   dex
0021C7  1  E4 19                cpx zp7f
0021C9  1  08 E0 7E F0          tst_x $7e,~fzc
0021CD  1  03 20 FF 42  
0021D1  1  68 48 C9 FC  
0021DB  1               
0021DB  1  A9 00 48 A2          set_x $80,0
0021DF  1  80 28        
0021E1  1  EC 1C 02             cpx abs7f
0021E4  1  08 68 48 C9          tst_stat fc
0021E8  1  31 F0 03 20  
0021EC  1  FF 42 28     
0021EF  1  CA                   dex
0021F0  1  EC 1C 02             cpx abs7f
0021F3  1  08 68 48 C9          tst_stat fzc
0021F7  1  33 F0 03 20  
0021FB  1  FF 42 28     
0021FE  1  CA                   dex
0021FF  1  EC 1C 02             cpx abs7f
002202  1  08 E0 7E F0          tst_x $7e,fn
002206  1  03 20 FF 42  
00220A  1  68 48 C9 B0  
002214  1  A9 FF 48 A2          set_x $80,$ff
002218  1  80 28        
00221A  1  EC 1C 02             cpx abs7f
00221D  1  08 68 48 C9          tst_stat ~fnz
002221  1  7D F0 03 20  
002225  1  FF 42 28     
002228  1  CA                   dex
002229  1  EC 1C 02             cpx abs7f
00222C  1  08 68 48 C9          tst_stat ~fn
002230  1  7F F0 03 20  
002234  1  FF 42 28     
002237  1  CA                   dex
002238  1  EC 1C 02             cpx abs7f
00223B  1  08 E0 7E F0          tst_x $7e,~fzc
00223F  1  03 20 FF 42  
002243  1  68 48 C9 FC  
00224D  1               
00224D  1  A9 00 48 A2          set_x $80,0
002251  1  80 28        
002253  1  E0 7F                cpx #$7f
002255  1  08 68 48 C9          tst_stat fc
002259  1  31 F0 03 20  
00225D  1  FF 42 28     
002260  1  CA                   dex
002261  1  E0 7F                cpx #$7f
002263  1  08 68 48 C9          tst_stat fzc
002267  1  33 F0 03 20  
00226B  1  FF 42 28     
00226E  1  CA                   dex
00226F  1  E0 7F                cpx #$7f
002271  1  08 E0 7E F0          tst_x $7e,fn
002275  1  03 20 FF 42  
002279  1  68 48 C9 B0  
002283  1  A9 FF 48 A2          set_x $80,$ff
002287  1  80 28        
002289  1  E0 7F                cpx #$7f
00228B  1  08 68 48 C9          tst_stat ~fnz
00228F  1  7D F0 03 20  
002293  1  FF 42 28     
002296  1  CA                   dex
002297  1  E0 7F                cpx #$7f
002299  1  08 68 48 C9          tst_stat ~fn
00229D  1  7F F0 03 20  
0022A1  1  FF 42 28     
0022A4  1  CA                   dex
0022A5  1  E0 7F                cpx #$7f
0022A7  1  08 E0 7E F0          tst_x $7e,~fzc
0022AB  1  03 20 FF 42  
0022AF  1  68 48 C9 FC  
0022B9  1  AD 00 02 C9          next_test
0022BD  1  1A F0 03 20  
0022C1  1  FF 42 A9 1B  
0022C8  1               
0022C8  1               ; CPY - zp / abs / #
0022C8  1  A9 00 48 A0          set_y $80,0
0022CC  1  80 28        
0022CE  1  C4 19                cpy zp7f
0022D0  1  08 68 48 C9          tst_stat fc
0022D4  1  31 F0 03 20  
0022D8  1  FF 42 28     
0022DB  1  88                   dey
0022DC  1  C4 19                cpy zp7f
0022DE  1  08 68 48 C9          tst_stat fzc
0022E2  1  33 F0 03 20  
0022E6  1  FF 42 28     
0022E9  1  88                   dey
0022EA  1  C4 19                cpy zp7f
0022EC  1  08 C0 7E F0          tst_y $7e,fn
0022F0  1  03 20 FF 42  
0022F4  1  68 48 C9 B0  
0022FE  1  A9 FF 48 A0          set_y $80,$ff
002302  1  80 28        
002304  1  C4 19                cpy zp7f
002306  1  08 68 48 C9          tst_stat ~fnz
00230A  1  7D F0 03 20  
00230E  1  FF 42 28     
002311  1  88                   dey
002312  1  C4 19                cpy zp7f
002314  1  08 68 48 C9          tst_stat ~fn
002318  1  7F F0 03 20  
00231C  1  FF 42 28     
00231F  1  88                   dey
002320  1  C4 19                cpy zp7f
002322  1  08 C0 7E F0          tst_y $7e,~fzc
002326  1  03 20 FF 42  
00232A  1  68 48 C9 FC  
002334  1               
002334  1  A9 00 48 A0          set_y $80,0
002338  1  80 28        
00233A  1  CC 1C 02             cpy abs7f
00233D  1  08 68 48 C9          tst_stat fc
002341  1  31 F0 03 20  
002345  1  FF 42 28     
002348  1  88                   dey
002349  1  CC 1C 02             cpy abs7f
00234C  1  08 68 48 C9          tst_stat fzc
002350  1  33 F0 03 20  
002354  1  FF 42 28     
002357  1  88                   dey
002358  1  CC 1C 02             cpy abs7f
00235B  1  08 C0 7E F0          tst_y $7e,fn
00235F  1  03 20 FF 42  
002363  1  68 48 C9 B0  
00236D  1  A9 FF 48 A0          set_y $80,$ff
002371  1  80 28        
002373  1  CC 1C 02             cpy abs7f
002376  1  08 68 48 C9          tst_stat ~fnz
00237A  1  7D F0 03 20  
00237E  1  FF 42 28     
002381  1  88                   dey
002382  1  CC 1C 02             cpy abs7f
002385  1  08 68 48 C9          tst_stat ~fn
002389  1  7F F0 03 20  
00238D  1  FF 42 28     
002390  1  88                   dey
002391  1  CC 1C 02             cpy abs7f
002394  1  08 C0 7E F0          tst_y $7e,~fzc
002398  1  03 20 FF 42  
00239C  1  68 48 C9 FC  
0023A6  1               
0023A6  1  A9 00 48 A0          set_y $80,0
0023AA  1  80 28        
0023AC  1  C0 7F                cpy #$7f
0023AE  1  08 68 48 C9          tst_stat fc
0023B2  1  31 F0 03 20  
0023B6  1  FF 42 28     
0023B9  1  88                   dey
0023BA  1  C0 7F                cpy #$7f
0023BC  1  08 68 48 C9          tst_stat fzc
0023C0  1  33 F0 03 20  
0023C4  1  FF 42 28     
0023C7  1  88                   dey
0023C8  1  C0 7F                cpy #$7f
0023CA  1  08 C0 7E F0          tst_y $7e,fn
0023CE  1  03 20 FF 42  
0023D2  1  68 48 C9 B0  
0023DC  1  A9 FF 48 A0          set_y $80,$ff
0023E0  1  80 28        
0023E2  1  C0 7F                cpy #$7f
0023E4  1  08 68 48 C9          tst_stat ~fnz
0023E8  1  7D F0 03 20  
0023EC  1  FF 42 28     
0023EF  1  88                   dey
0023F0  1  C0 7F                cpy #$7f
0023F2  1  08 68 48 C9          tst_stat ~fn
0023F6  1  7F F0 03 20  
0023FA  1  FF 42 28     
0023FD  1  88                   dey
0023FE  1  C0 7F                cpy #$7f
002400  1  08 C0 7E F0          tst_y $7e,~fzc
002404  1  03 20 FF 42  
002408  1  68 48 C9 FC  
002412  1  AD 00 02 C9          next_test
002416  1  1B F0 03 20  
00241A  1  FF 42 A9 1C  
002421  1               
002421  1               ; CMP - zp / abs / #
002421  1  A9 00 48 A9          set_a $80,0
002425  1  80 28        
002427  1  C5 19                cmp zp7f
002429  1  08 C9 80 F0          tst_a $80,fc
00242D  1  03 20 FF 42  
002431  1  68 48 C9 31  
00243B  1  A9 00 48 A9          set_a $7f,0
00243F  1  7F 28        
002441  1  C5 19                cmp zp7f
002443  1  08 C9 7F F0          tst_a $7f,fzc
002447  1  03 20 FF 42  
00244B  1  68 48 C9 33  
002455  1  A9 00 48 A9          set_a $7e,0
002459  1  7E 28        
00245B  1  C5 19                cmp zp7f
00245D  1  08 C9 7E F0          tst_a $7e,fn
002461  1  03 20 FF 42  
002465  1  68 48 C9 B0  
00246F  1  A9 FF 48 A9          set_a $80,$ff
002473  1  80 28        
002475  1  C5 19                cmp zp7f
002477  1  08 C9 80 F0          tst_a $80,~fnz
00247B  1  03 20 FF 42  
00247F  1  68 48 C9 7D  
002489  1  A9 FF 48 A9          set_a $7f,$ff
00248D  1  7F 28        
00248F  1  C5 19                cmp zp7f
002491  1  08 C9 7F F0          tst_a $7f,~fn
002495  1  03 20 FF 42  
002499  1  68 48 C9 7F  
0024A3  1  A9 FF 48 A9          set_a $7e,$ff
0024A7  1  7E 28        
0024A9  1  C5 19                cmp zp7f
0024AB  1  08 C9 7E F0          tst_a $7e,~fzc
0024AF  1  03 20 FF 42  
0024B3  1  68 48 C9 FC  
0024BD  1               
0024BD  1  A9 00 48 A9          set_a $80,0
0024C1  1  80 28        
0024C3  1  CD 1C 02             cmp abs7f
0024C6  1  08 C9 80 F0          tst_a $80,fc
0024CA  1  03 20 FF 42  
0024CE  1  68 48 C9 31  
0024D8  1  A9 00 48 A9          set_a $7f,0
0024DC  1  7F 28        
0024DE  1  CD 1C 02             cmp abs7f
0024E1  1  08 C9 7F F0          tst_a $7f,fzc
0024E5  1  03 20 FF 42  
0024E9  1  68 48 C9 33  
0024F3  1  A9 00 48 A9          set_a $7e,0
0024F7  1  7E 28        
0024F9  1  CD 1C 02             cmp abs7f
0024FC  1  08 C9 7E F0          tst_a $7e,fn
002500  1  03 20 FF 42  
002504  1  68 48 C9 B0  
00250E  1  A9 FF 48 A9          set_a $80,$ff
002512  1  80 28        
002514  1  CD 1C 02             cmp abs7f
002517  1  08 C9 80 F0          tst_a $80,~fnz
00251B  1  03 20 FF 42  
00251F  1  68 48 C9 7D  
002529  1  A9 FF 48 A9          set_a $7f,$ff
00252D  1  7F 28        
00252F  1  CD 1C 02             cmp abs7f
002532  1  08 C9 7F F0          tst_a $7f,~fn
002536  1  03 20 FF 42  
00253A  1  68 48 C9 7F  
002544  1  A9 FF 48 A9          set_a $7e,$ff
002548  1  7E 28        
00254A  1  CD 1C 02             cmp abs7f
00254D  1  08 C9 7E F0          tst_a $7e,~fzc
002551  1  03 20 FF 42  
002555  1  68 48 C9 FC  
00255F  1               
00255F  1  A9 00 48 A9          set_a $80,0
002563  1  80 28        
002565  1  C9 7F                cmp #$7f
002567  1  08 C9 80 F0          tst_a $80,fc
00256B  1  03 20 FF 42  
00256F  1  68 48 C9 31  
002579  1  A9 00 48 A9          set_a $7f,0
00257D  1  7F 28        
00257F  1  C9 7F                cmp #$7f
002581  1  08 C9 7F F0          tst_a $7f,fzc
002585  1  03 20 FF 42  
002589  1  68 48 C9 33  
002593  1  A9 00 48 A9          set_a $7e,0
002597  1  7E 28        
002599  1  C9 7F                cmp #$7f
00259B  1  08 C9 7E F0          tst_a $7e,fn
00259F  1  03 20 FF 42  
0025A3  1  68 48 C9 B0  
0025AD  1  A9 FF 48 A9          set_a $80,$ff
0025B1  1  80 28        
0025B3  1  C9 7F                cmp #$7f
0025B5  1  08 C9 80 F0          tst_a $80,~fnz
0025B9  1  03 20 FF 42  
0025BD  1  68 48 C9 7D  
0025C7  1  A9 FF 48 A9          set_a $7f,$ff
0025CB  1  7F 28        
0025CD  1  C9 7F                cmp #$7f
0025CF  1  08 C9 7F F0          tst_a $7f,~fn
0025D3  1  03 20 FF 42  
0025D7  1  68 48 C9 7F  
0025E1  1  A9 FF 48 A9          set_a $7e,$ff
0025E5  1  7E 28        
0025E7  1  C9 7F                cmp #$7f
0025E9  1  08 C9 7E F0          tst_a $7e,~fzc
0025ED  1  03 20 FF 42  
0025F1  1  68 48 C9 FC  
0025FB  1               
0025FB  1  A2 04                ldx #4          ;with indexing by X
0025FD  1  A9 00 48 A9          set_a $80,0
002601  1  80 28        
002603  1  D5 15                cmp zp1,x
002605  1  08 C9 80 F0          tst_a $80,fc
002609  1  03 20 FF 42  
00260D  1  68 48 C9 31  
002617  1  A9 00 48 A9          set_a $7f,0
00261B  1  7F 28        
00261D  1  D5 15                cmp zp1,x
00261F  1  08 C9 7F F0          tst_a $7f,fzc
002623  1  03 20 FF 42  
002627  1  68 48 C9 33  
002631  1  A9 00 48 A9          set_a $7e,0
002635  1  7E 28        
002637  1  D5 15                cmp zp1,x
002639  1  08 C9 7E F0          tst_a $7e,fn
00263D  1  03 20 FF 42  
002641  1  68 48 C9 B0  
00264B  1  A9 FF 48 A9          set_a $80,$ff
00264F  1  80 28        
002651  1  D5 15                cmp zp1,x
002653  1  08 C9 80 F0          tst_a $80,~fnz
002657  1  03 20 FF 42  
00265B  1  68 48 C9 7D  
002665  1  A9 FF 48 A9          set_a $7f,$ff
002669  1  7F 28        
00266B  1  D5 15                cmp zp1,x
00266D  1  08 C9 7F F0          tst_a $7f,~fn
002671  1  03 20 FF 42  
002675  1  68 48 C9 7F  
00267F  1  A9 FF 48 A9          set_a $7e,$ff
002683  1  7E 28        
002685  1  D5 15                cmp zp1,x
002687  1  08 C9 7E F0          tst_a $7e,~fzc
00268B  1  03 20 FF 42  
00268F  1  68 48 C9 FC  
002699  1               
002699  1  A9 00 48 A9          set_a $80,0
00269D  1  80 28        
00269F  1  DD 18 02             cmp abs1,x
0026A2  1  08 C9 80 F0          tst_a $80,fc
0026A6  1  03 20 FF 42  
0026AA  1  68 48 C9 31  
0026B4  1  A9 00 48 A9          set_a $7f,0
0026B8  1  7F 28        
0026BA  1  DD 18 02             cmp abs1,x
0026BD  1  08 C9 7F F0          tst_a $7f,fzc
0026C1  1  03 20 FF 42  
0026C5  1  68 48 C9 33  
0026CF  1  A9 00 48 A9          set_a $7e,0
0026D3  1  7E 28        
0026D5  1  DD 18 02             cmp abs1,x
0026D8  1  08 C9 7E F0          tst_a $7e,fn
0026DC  1  03 20 FF 42  
0026E0  1  68 48 C9 B0  
0026EA  1  A9 FF 48 A9          set_a $80,$ff
0026EE  1  80 28        
0026F0  1  DD 18 02             cmp abs1,x
0026F3  1  08 C9 80 F0          tst_a $80,~fnz
0026F7  1  03 20 FF 42  
0026FB  1  68 48 C9 7D  
002705  1  A9 FF 48 A9          set_a $7f,$ff
002709  1  7F 28        
00270B  1  DD 18 02             cmp abs1,x
00270E  1  08 C9 7F F0          tst_a $7f,~fn
002712  1  03 20 FF 42  
002716  1  68 48 C9 7F  
002720  1  A9 FF 48 A9          set_a $7e,$ff
002724  1  7E 28        
002726  1  DD 18 02             cmp abs1,x
002729  1  08 C9 7E F0          tst_a $7e,~fzc
00272D  1  03 20 FF 42  
002731  1  68 48 C9 FC  
00273B  1               
00273B  1  A0 04                ldy #4          ;with indexing by Y
00273D  1  A2 08                ldx #8          ;with indexed indirect
00273F  1  A9 00 48 A9          set_a $80,0
002743  1  80 28        
002745  1  D9 18 02             cmp abs1,y
002748  1  08 C9 80 F0          tst_a $80,fc
00274C  1  03 20 FF 42  
002750  1  68 48 C9 31  
00275A  1  A9 00 48 A9          set_a $7f,0
00275E  1  7F 28        
002760  1  D9 18 02             cmp abs1,y
002763  1  08 C9 7F F0          tst_a $7f,fzc
002767  1  03 20 FF 42  
00276B  1  68 48 C9 33  
002775  1  A9 00 48 A9          set_a $7e,0
002779  1  7E 28        
00277B  1  D9 18 02             cmp abs1,y
00277E  1  08 C9 7E F0          tst_a $7e,fn
002782  1  03 20 FF 42  
002786  1  68 48 C9 B0  
002790  1  A9 FF 48 A9          set_a $80,$ff
002794  1  80 28        
002796  1  D9 18 02             cmp abs1,y
002799  1  08 C9 80 F0          tst_a $80,~fnz
00279D  1  03 20 FF 42  
0027A1  1  68 48 C9 7D  
0027AB  1  A9 FF 48 A9          set_a $7f,$ff
0027AF  1  7F 28        
0027B1  1  D9 18 02             cmp abs1,y
0027B4  1  08 C9 7F F0          tst_a $7f,~fn
0027B8  1  03 20 FF 42  
0027BC  1  68 48 C9 7F  
0027C6  1  A9 FF 48 A9          set_a $7e,$ff
0027CA  1  7E 28        
0027CC  1  D9 18 02             cmp abs1,y
0027CF  1  08 C9 7E F0          tst_a $7e,~fzc
0027D3  1  03 20 FF 42  
0027D7  1  68 48 C9 FC  
0027E1  1               
0027E1  1  A9 00 48 A9          set_a $80,0
0027E5  1  80 28        
0027E7  1  C1 26                cmp (ind1,x)
0027E9  1  08 C9 80 F0          tst_a $80,fc
0027ED  1  03 20 FF 42  
0027F1  1  68 48 C9 31  
0027FB  1  A9 00 48 A9          set_a $7f,0
0027FF  1  7F 28        
002801  1  C1 26                cmp (ind1,x)
002803  1  08 C9 7F F0          tst_a $7f,fzc
002807  1  03 20 FF 42  
00280B  1  68 48 C9 33  
002815  1  A9 00 48 A9          set_a $7e,0
002819  1  7E 28        
00281B  1  C1 26                cmp (ind1,x)
00281D  1  08 C9 7E F0          tst_a $7e,fn
002821  1  03 20 FF 42  
002825  1  68 48 C9 B0  
00282F  1  A9 FF 48 A9          set_a $80,$ff
002833  1  80 28        
002835  1  C1 26                cmp (ind1,x)
002837  1  08 C9 80 F0          tst_a $80,~fnz
00283B  1  03 20 FF 42  
00283F  1  68 48 C9 7D  
002849  1  A9 FF 48 A9          set_a $7f,$ff
00284D  1  7F 28        
00284F  1  C1 26                cmp (ind1,x)
002851  1  08 C9 7F F0          tst_a $7f,~fn
002855  1  03 20 FF 42  
002859  1  68 48 C9 7F  
002863  1  A9 FF 48 A9          set_a $7e,$ff
002867  1  7E 28        
002869  1  C1 26                cmp (ind1,x)
00286B  1  08 C9 7E F0          tst_a $7e,~fzc
00286F  1  03 20 FF 42  
002873  1  68 48 C9 FC  
00287D  1               
00287D  1  A9 00 48 A9          set_a $80,0
002881  1  80 28        
002883  1  D1 26                cmp (ind1),y
002885  1  08 C9 80 F0          tst_a $80,fc
002889  1  03 20 FF 42  
00288D  1  68 48 C9 31  
002897  1  A9 00 48 A9          set_a $7f,0
00289B  1  7F 28        
00289D  1  D1 26                cmp (ind1),y
00289F  1  08 C9 7F F0          tst_a $7f,fzc
0028A3  1  03 20 FF 42  
0028A7  1  68 48 C9 33  
0028B1  1  A9 00 48 A9          set_a $7e,0
0028B5  1  7E 28        
0028B7  1  D1 26                cmp (ind1),y
0028B9  1  08 C9 7E F0          tst_a $7e,fn
0028BD  1  03 20 FF 42  
0028C1  1  68 48 C9 B0  
0028CB  1  A9 FF 48 A9          set_a $80,$ff
0028CF  1  80 28        
0028D1  1  D1 26                cmp (ind1),y
0028D3  1  08 C9 80 F0          tst_a $80,~fnz
0028D7  1  03 20 FF 42  
0028DB  1  68 48 C9 7D  
0028E5  1  A9 FF 48 A9          set_a $7f,$ff
0028E9  1  7F 28        
0028EB  1  D1 26                cmp (ind1),y
0028ED  1  08 C9 7F F0          tst_a $7f,~fn
0028F1  1  03 20 FF 42  
0028F5  1  68 48 C9 7F  
0028FF  1  A9 FF 48 A9          set_a $7e,$ff
002903  1  7E 28        
002905  1  D1 26                cmp (ind1),y
002907  1  08 C9 7E F0          tst_a $7e,~fzc
00290B  1  03 20 FF 42  
00290F  1  68 48 C9 FC  
002919  1  AD 00 02 C9          next_test
00291D  1  1C F0 03 20  
002921  1  FF 42 A9 1D  
002928  1               
002928  1               ; testing shifts - ASL LSR ROL ROR all addressing modes
002928  1               ; shifts - accumulator
002928  1  A2 05                ldx #5
00292A  1               tasl:
00292A  1  A9 00 48 B5          set_ax zps,0
00292E  1  13 28        
002930  1  0A                   asl a
002931  1  08 DD 21 02          tst_ax rASL,fASL,0
002935  1  F0 03 20 FF  
002939  1  42 68 49 30  
002945  1  CA                   dex
002946  1  10 E2                bpl tasl
002948  1  A2 05                ldx #5
00294A  1               tasl1:
00294A  1  A9 FF 48 B5          set_ax zps,$ff
00294E  1  13 28        
002950  1  0A                   asl a
002951  1  08 DD 21 02          tst_ax rASL,fASL,$ff-fnzc
002955  1  F0 03 20 FF  
002959  1  42 68 49 7C  
002965  1  CA                   dex
002966  1  10 E2                bpl tasl1
002968  1               
002968  1  A2 05                ldx #5
00296A  1               tlsr:
00296A  1  A9 00 48 B5          set_ax zps,0
00296E  1  13 28        
002970  1  4A                   lsr a
002971  1  08 DD 2D 02          tst_ax rLSR,fLSR,0
002975  1  F0 03 20 FF  
002979  1  42 68 49 30  
002985  1  CA                   dex
002986  1  10 E2                bpl tlsr
002988  1  A2 05                ldx #5
00298A  1               tlsr1:
00298A  1  A9 FF 48 B5          set_ax zps,$ff
00298E  1  13 28        
002990  1  4A                   lsr a
002991  1  08 DD 2D 02          tst_ax rLSR,fLSR,$ff-fnzc
002995  1  F0 03 20 FF  
002999  1  42 68 49 7C  
0029A5  1  CA                   dex
0029A6  1  10 E2                bpl tlsr1
0029A8  1               
0029A8  1  A2 05                ldx #5
0029AA  1               trol:
0029AA  1  A9 00 48 B5          set_ax zps,0
0029AE  1  13 28        
0029B0  1  2A                   rol a
0029B1  1  08 DD 21 02          tst_ax rROL,fROL,0
0029B5  1  F0 03 20 FF  
0029B9  1  42 68 49 30  
0029C5  1  CA                   dex
0029C6  1  10 E2                bpl trol
0029C8  1  A2 05                ldx #5
0029CA  1               trol1:
0029CA  1  A9 FE 48 B5          set_ax zps,$ff-fc
0029CE  1  13 28        
0029D0  1  2A                   rol a
0029D1  1  08 DD 21 02          tst_ax rROL,fROL,$ff-fnzc
0029D5  1  F0 03 20 FF  
0029D9  1  42 68 49 7C  
0029E5  1  CA                   dex
0029E6  1  10 E2                bpl trol1
0029E8  1               
0029E8  1  A2 05                ldx #5
0029EA  1               trolc:
0029EA  1  A9 01 48 B5          set_ax zps,fc
0029EE  1  13 28        
0029F0  1  2A                   rol a
0029F1  1  08 DD 27 02          tst_ax rROLc,fROLc,0
0029F5  1  F0 03 20 FF  
0029F9  1  42 68 49 30  
002A05  1  CA                   dex
002A06  1  10 E2                bpl trolc
002A08  1  A2 05                ldx #5
002A0A  1               trolc1:
002A0A  1  A9 FF 48 B5          set_ax zps,$ff
002A0E  1  13 28        
002A10  1  2A                   rol a
002A11  1  08 DD 27 02          tst_ax rROLc,fROLc,$ff-fnzc
002A15  1  F0 03 20 FF  
002A19  1  42 68 49 7C  
002A25  1  CA                   dex
002A26  1  10 E2                bpl trolc1
002A28  1               
002A28  1  A2 05                ldx #5
002A2A  1               tror:
002A2A  1  A9 00 48 B5          set_ax zps,0
002A2E  1  13 28        
002A30  1  6A                   ror a
002A31  1  08 DD 2D 02          tst_ax rROR,fROR,0
002A35  1  F0 03 20 FF  
002A39  1  42 68 49 30  
002A45  1  CA                   dex
002A46  1  10 E2                bpl tror
002A48  1  A2 05                ldx #5
002A4A  1               tror1:
002A4A  1  A9 FE 48 B5          set_ax zps,$ff-fc
002A4E  1  13 28        
002A50  1  6A                   ror a
002A51  1  08 DD 2D 02          tst_ax rROR,fROR,$ff-fnzc
002A55  1  F0 03 20 FF  
002A59  1  42 68 49 7C  
002A65  1  CA                   dex
002A66  1  10 E2                bpl tror1
002A68  1               
002A68  1  A2 05                ldx #5
002A6A  1               trorc:
002A6A  1  A9 01 48 B5          set_ax zps,fc
002A6E  1  13 28        
002A70  1  6A                   ror a
002A71  1  08 DD 33 02          tst_ax rRORc,fRORc,0
002A75  1  F0 03 20 FF  
002A79  1  42 68 49 30  
002A85  1  CA                   dex
002A86  1  10 E2                bpl trorc
002A88  1  A2 05                ldx #5
002A8A  1               trorc1:
002A8A  1  A9 FF 48 B5          set_ax zps,$ff
002A8E  1  13 28        
002A90  1  6A                   ror a
002A91  1  08 DD 33 02          tst_ax rRORc,fRORc,$ff-fnzc
002A95  1  F0 03 20 FF  
002A99  1  42 68 49 7C  
002AA5  1  CA                   dex
002AA6  1  10 E2                bpl trorc1
002AA8  1  AD 00 02 C9          next_test
002AAC  1  1D F0 03 20  
002AB0  1  FF 42 A9 1E  
002AB7  1               
002AB7  1               ; shifts - zeropage
002AB7  1  A2 05                ldx #5
002AB9  1               tasl2:
002AB9  1  A9 00 48 B5          set_z zps,0
002ABD  1  13 85 0C 28  
002AC1  1  06 0C                asl zpt
002AC3  1  08 A5 0C DD          tst_z rASL,fASL,0
002AC7  1  21 02 F0 03  
002ACB  1  20 FF 42 68  
002AD9  1  CA                   dex
002ADA  1  10 DD                bpl tasl2
002ADC  1  A2 05                ldx #5
002ADE  1               tasl3:
002ADE  1  A9 FF 48 B5          set_z zps,$ff
002AE2  1  13 85 0C 28  
002AE6  1  06 0C                asl zpt
002AE8  1  08 A5 0C DD          tst_z rASL,fASL,$ff-fnzc
002AEC  1  21 02 F0 03  
002AF0  1  20 FF 42 68  
002AFE  1  CA                   dex
002AFF  1  10 DD                bpl tasl3
002B01  1               
002B01  1  A2 05                ldx #5
002B03  1               tlsr2:
002B03  1  A9 00 48 B5          set_z zps,0
002B07  1  13 85 0C 28  
002B0B  1  46 0C                lsr zpt
002B0D  1  08 A5 0C DD          tst_z rLSR,fLSR,0
002B11  1  2D 02 F0 03  
002B15  1  20 FF 42 68  
002B23  1  CA                   dex
002B24  1  10 DD                bpl tlsr2
002B26  1  A2 05                ldx #5
002B28  1               tlsr3:
002B28  1  A9 FF 48 B5          set_z zps,$ff
002B2C  1  13 85 0C 28  
002B30  1  46 0C                lsr zpt
002B32  1  08 A5 0C DD          tst_z rLSR,fLSR,$ff-fnzc
002B36  1  2D 02 F0 03  
002B3A  1  20 FF 42 68  
002B48  1  CA                   dex
002B49  1  10 DD                bpl tlsr3
002B4B  1               
002B4B  1  A2 05                ldx #5
002B4D  1               trol2:
002B4D  1  A9 00 48 B5          set_z zps,0
002B51  1  13 85 0C 28  
002B55  1  26 0C                rol zpt
002B57  1  08 A5 0C DD          tst_z rROL,fROL,0
002B5B  1  21 02 F0 03  
002B5F  1  20 FF 42 68  
002B6D  1  CA                   dex
002B6E  1  10 DD                bpl trol2
002B70  1  A2 05                ldx #5
002B72  1               trol3:
002B72  1  A9 FE 48 B5          set_z zps,$ff-fc
002B76  1  13 85 0C 28  
002B7A  1  26 0C                rol zpt
002B7C  1  08 A5 0C DD          tst_z rROL,fROL,$ff-fnzc
002B80  1  21 02 F0 03  
002B84  1  20 FF 42 68  
002B92  1  CA                   dex
002B93  1  10 DD                bpl trol3
002B95  1               
002B95  1  A2 05                ldx #5
002B97  1               trolc2:
002B97  1  A9 01 48 B5          set_z zps,fc
002B9B  1  13 85 0C 28  
002B9F  1  26 0C                rol zpt
002BA1  1  08 A5 0C DD          tst_z rROLc,fROLc,0
002BA5  1  27 02 F0 03  
002BA9  1  20 FF 42 68  
002BB7  1  CA                   dex
002BB8  1  10 DD                bpl trolc2
002BBA  1  A2 05                ldx #5
002BBC  1               trolc3:
002BBC  1  A9 FF 48 B5          set_z zps,$ff
002BC0  1  13 85 0C 28  
002BC4  1  26 0C                rol zpt
002BC6  1  08 A5 0C DD          tst_z rROLc,fROLc,$ff-fnzc
002BCA  1  27 02 F0 03  
002BCE  1  20 FF 42 68  
002BDC  1  CA                   dex
002BDD  1  10 DD                bpl trolc3
002BDF  1               
002BDF  1  A2 05                ldx #5
002BE1  1               tror2:
002BE1  1  A9 00 48 B5          set_z zps,0
002BE5  1  13 85 0C 28  
002BE9  1  66 0C                ror zpt
002BEB  1  08 A5 0C DD          tst_z rROR,fROR,0
002BEF  1  2D 02 F0 03  
002BF3  1  20 FF 42 68  
002C01  1  CA                   dex
002C02  1  10 DD                bpl tror2
002C04  1  A2 05                ldx #5
002C06  1               tror3:
002C06  1  A9 FE 48 B5          set_z zps,$ff-fc
002C0A  1  13 85 0C 28  
002C0E  1  66 0C                ror zpt
002C10  1  08 A5 0C DD          tst_z rROR,fROR,$ff-fnzc
002C14  1  2D 02 F0 03  
002C18  1  20 FF 42 68  
002C26  1  CA                   dex
002C27  1  10 DD                bpl tror3
002C29  1               
002C29  1  A2 05                ldx #5
002C2B  1               trorc2:
002C2B  1  A9 01 48 B5          set_z zps,fc
002C2F  1  13 85 0C 28  
002C33  1  66 0C                ror zpt
002C35  1  08 A5 0C DD          tst_z rRORc,fRORc,0
002C39  1  33 02 F0 03  
002C3D  1  20 FF 42 68  
002C4B  1  CA                   dex
002C4C  1  10 DD                bpl trorc2
002C4E  1  A2 05                ldx #5
002C50  1               trorc3:
002C50  1  A9 FF 48 B5          set_z zps,$ff
002C54  1  13 85 0C 28  
002C58  1  66 0C                ror zpt
002C5A  1  08 A5 0C DD          tst_z rRORc,fRORc,$ff-fnzc
002C5E  1  33 02 F0 03  
002C62  1  20 FF 42 68  
002C70  1  CA                   dex
002C71  1  10 DD                bpl trorc3
002C73  1  AD 00 02 C9          next_test
002C77  1  1E F0 03 20  
002C7B  1  FF 42 A9 1F  
002C82  1               
002C82  1               ; shifts - absolute
002C82  1  A2 05                ldx #5
002C84  1               tasl4:
002C84  1  A9 00 48 B5          set_abs zps,0
002C88  1  13 8D 03 02  
002C8C  1  28           
002C8D  1  0E 03 02             asl abst
002C90  1  08 AD 03 02          tst_abs rASL,fASL,0
002C94  1  DD 21 02 F0  
002C98  1  03 20 FF 42  
002CA7  1  CA                   dex
002CA8  1  10 DA                bpl tasl4
002CAA  1  A2 05                ldx #5
002CAC  1               tasl5:
002CAC  1  A9 FF 48 B5          set_abs zps,$ff
002CB0  1  13 8D 03 02  
002CB4  1  28           
002CB5  1  0E 03 02             asl abst
002CB8  1  08 AD 03 02          tst_abs rASL,fASL,$ff-fnzc
002CBC  1  DD 21 02 F0  
002CC0  1  03 20 FF 42  
002CCF  1  CA                   dex
002CD0  1  10 DA                bpl tasl5
002CD2  1               
002CD2  1  A2 05                ldx #5
002CD4  1               tlsr4:
002CD4  1  A9 00 48 B5          set_abs zps,0
002CD8  1  13 8D 03 02  
002CDC  1  28           
002CDD  1  4E 03 02             lsr abst
002CE0  1  08 AD 03 02          tst_abs rLSR,fLSR,0
002CE4  1  DD 2D 02 F0  
002CE8  1  03 20 FF 42  
002CF7  1  CA                   dex
002CF8  1  10 DA                bpl tlsr4
002CFA  1  A2 05                ldx #5
002CFC  1               tlsr5:
002CFC  1  A9 FF 48 B5          set_abs zps,$ff
002D00  1  13 8D 03 02  
002D04  1  28           
002D05  1  4E 03 02             lsr abst
002D08  1  08 AD 03 02          tst_abs rLSR,fLSR,$ff-fnzc
002D0C  1  DD 2D 02 F0  
002D10  1  03 20 FF 42  
002D1F  1  CA                   dex
002D20  1  10 DA                bpl tlsr5
002D22  1               
002D22  1  A2 05                ldx #5
002D24  1               trol4:
002D24  1  A9 00 48 B5          set_abs zps,0
002D28  1  13 8D 03 02  
002D2C  1  28           
002D2D  1  2E 03 02             rol abst
002D30  1  08 AD 03 02          tst_abs rROL,fROL,0
002D34  1  DD 21 02 F0  
002D38  1  03 20 FF 42  
002D47  1  CA                   dex
002D48  1  10 DA                bpl trol4
002D4A  1  A2 05                ldx #5
002D4C  1               trol5:
002D4C  1  A9 FE 48 B5          set_abs zps,$ff-fc
002D50  1  13 8D 03 02  
002D54  1  28           
002D55  1  2E 03 02             rol abst
002D58  1  08 AD 03 02          tst_abs rROL,fROL,$ff-fnzc
002D5C  1  DD 21 02 F0  
002D60  1  03 20 FF 42  
002D6F  1  CA                   dex
002D70  1  10 DA                bpl trol5
002D72  1               
002D72  1  A2 05                ldx #5
002D74  1               trolc4:
002D74  1  A9 01 48 B5          set_abs zps,fc
002D78  1  13 8D 03 02  
002D7C  1  28           
002D7D  1  2E 03 02             rol abst
002D80  1  08 AD 03 02          tst_abs rROLc,fROLc,0
002D84  1  DD 27 02 F0  
002D88  1  03 20 FF 42  
002D97  1  CA                   dex
002D98  1  10 DA                bpl trolc4
002D9A  1  A2 05                ldx #5
002D9C  1               trolc5:
002D9C  1  A9 FF 48 B5          set_abs zps,$ff
002DA0  1  13 8D 03 02  
002DA4  1  28           
002DA5  1  2E 03 02             rol abst
002DA8  1  08 AD 03 02          tst_abs rROLc,fROLc,$ff-fnzc
002DAC  1  DD 27 02 F0  
002DB0  1  03 20 FF 42  
002DBF  1  CA                   dex
002DC0  1  10 DA                bpl trolc5
002DC2  1               
002DC2  1  A2 05                ldx #5
002DC4  1               tror4:
002DC4  1  A9 00 48 B5          set_abs zps,0
002DC8  1  13 8D 03 02  
002DCC  1  28           
002DCD  1  6E 03 02             ror abst
002DD0  1  08 AD 03 02          tst_abs rROR,fROR,0
002DD4  1  DD 2D 02 F0  
002DD8  1  03 20 FF 42  
002DE7  1  CA                   dex
002DE8  1  10 DA                bpl tror4
002DEA  1  A2 05                ldx #5
002DEC  1               tror5:
002DEC  1  A9 FE 48 B5          set_abs zps,$ff-fc
002DF0  1  13 8D 03 02  
002DF4  1  28           
002DF5  1  6E 03 02             ror abst
002DF8  1  08 AD 03 02          tst_abs rROR,fROR,$ff-fnzc
002DFC  1  DD 2D 02 F0  
002E00  1  03 20 FF 42  
002E0F  1  CA                   dex
002E10  1  10 DA                bpl tror5
002E12  1               
002E12  1  A2 05                ldx #5
002E14  1               trorc4:
002E14  1  A9 01 48 B5          set_abs zps,fc
002E18  1  13 8D 03 02  
002E1C  1  28           
002E1D  1  6E 03 02             ror abst
002E20  1  08 AD 03 02          tst_abs rRORc,fRORc,0
002E24  1  DD 33 02 F0  
002E28  1  03 20 FF 42  
002E37  1  CA                   dex
002E38  1  10 DA                bpl trorc4
002E3A  1  A2 05                ldx #5
002E3C  1               trorc5:
002E3C  1  A9 FF 48 B5          set_abs zps,$ff
002E40  1  13 8D 03 02  
002E44  1  28           
002E45  1  6E 03 02             ror abst
002E48  1  08 AD 03 02          tst_abs rRORc,fRORc,$ff-fnzc
002E4C  1  DD 33 02 F0  
002E50  1  03 20 FF 42  
002E5F  1  CA                   dex
002E60  1  10 DA                bpl trorc5
002E62  1  AD 00 02 C9          next_test
002E66  1  1F F0 03 20  
002E6A  1  FF 42 A9 20  
002E71  1               
002E71  1               ; shifts - zp indexed
002E71  1  A2 05                ldx #5
002E73  1               tasl6:
002E73  1  A9 00 48 B5          set_zx zps,0
002E77  1  13 95 0C 28  
002E7B  1  16 0C                asl zpt,x
002E7D  1  08 B5 0C DD          tst_zx rASL,fASL,0
002E81  1  21 02 F0 03  
002E85  1  20 FF 42 68  
002E93  1  CA                   dex
002E94  1  10 DD                bpl tasl6
002E96  1  A2 05                ldx #5
002E98  1               tasl7:
002E98  1  A9 FF 48 B5          set_zx zps,$ff
002E9C  1  13 95 0C 28  
002EA0  1  16 0C                asl zpt,x
002EA2  1  08 B5 0C DD          tst_zx rASL,fASL,$ff-fnzc
002EA6  1  21 02 F0 03  
002EAA  1  20 FF 42 68  
002EB8  1  CA                   dex
002EB9  1  10 DD                bpl tasl7
002EBB  1               
002EBB  1  A2 05                ldx #5
002EBD  1               tlsr6:
002EBD  1  A9 00 48 B5          set_zx zps,0
002EC1  1  13 95 0C 28  
002EC5  1  56 0C                lsr zpt,x
002EC7  1  08 B5 0C DD          tst_zx rLSR,fLSR,0
002ECB  1  2D 02 F0 03  
002ECF  1  20 FF 42 68  
002EDD  1  CA                   dex
002EDE  1  10 DD                bpl tlsr6
002EE0  1  A2 05                ldx #5
002EE2  1               tlsr7:
002EE2  1  A9 FF 48 B5          set_zx zps,$ff
002EE6  1  13 95 0C 28  
002EEA  1  56 0C                lsr zpt,x
002EEC  1  08 B5 0C DD          tst_zx rLSR,fLSR,$ff-fnzc
002EF0  1  2D 02 F0 03  
002EF4  1  20 FF 42 68  
002F02  1  CA                   dex
002F03  1  10 DD                bpl tlsr7
002F05  1               
002F05  1  A2 05                ldx #5
002F07  1               trol6:
002F07  1  A9 00 48 B5          set_zx zps,0
002F0B  1  13 95 0C 28  
002F0F  1  36 0C                rol zpt,x
002F11  1  08 B5 0C DD          tst_zx rROL,fROL,0
002F15  1  21 02 F0 03  
002F19  1  20 FF 42 68  
002F27  1  CA                   dex
002F28  1  10 DD                bpl trol6
002F2A  1  A2 05                ldx #5
002F2C  1               trol7:
002F2C  1  A9 FE 48 B5          set_zx zps,$ff-fc
002F30  1  13 95 0C 28  
002F34  1  36 0C                rol zpt,x
002F36  1  08 B5 0C DD          tst_zx rROL,fROL,$ff-fnzc
002F3A  1  21 02 F0 03  
002F3E  1  20 FF 42 68  
002F4C  1  CA                   dex
002F4D  1  10 DD                bpl trol7
002F4F  1               
002F4F  1  A2 05                ldx #5
002F51  1               trolc6:
002F51  1  A9 01 48 B5          set_zx zps,fc
002F55  1  13 95 0C 28  
002F59  1  36 0C                rol zpt,x
002F5B  1  08 B5 0C DD          tst_zx rROLc,fROLc,0
002F5F  1  27 02 F0 03  
002F63  1  20 FF 42 68  
002F71  1  CA                   dex
002F72  1  10 DD                bpl trolc6
002F74  1  A2 05                ldx #5
002F76  1               trolc7:
002F76  1  A9 FF 48 B5          set_zx zps,$ff
002F7A  1  13 95 0C 28  
002F7E  1  36 0C                rol zpt,x
002F80  1  08 B5 0C DD          tst_zx rROLc,fROLc,$ff-fnzc
002F84  1  27 02 F0 03  
002F88  1  20 FF 42 68  
002F96  1  CA                   dex
002F97  1  10 DD                bpl trolc7
002F99  1               
002F99  1  A2 05                ldx #5
002F9B  1               tror6:
002F9B  1  A9 00 48 B5          set_zx zps,0
002F9F  1  13 95 0C 28  
002FA3  1  76 0C                ror zpt,x
002FA5  1  08 B5 0C DD          tst_zx rROR,fROR,0
002FA9  1  2D 02 F0 03  
002FAD  1  20 FF 42 68  
002FBB  1  CA                   dex
002FBC  1  10 DD                bpl tror6
002FBE  1  A2 05                ldx #5
002FC0  1               tror7:
002FC0  1  A9 FE 48 B5          set_zx zps,$ff-fc
002FC4  1  13 95 0C 28  
002FC8  1  76 0C                ror zpt,x
002FCA  1  08 B5 0C DD          tst_zx rROR,fROR,$ff-fnzc
002FCE  1  2D 02 F0 03  
002FD2  1  20 FF 42 68  
002FE0  1  CA                   dex
002FE1  1  10 DD                bpl tror7
002FE3  1               
002FE3  1  A2 05                ldx #5
002FE5  1               trorc6:
002FE5  1  A9 01 48 B5          set_zx zps,fc
002FE9  1  13 95 0C 28  
002FED  1  76 0C                ror zpt,x
002FEF  1  08 B5 0C DD          tst_zx rRORc,fRORc,0
002FF3  1  33 02 F0 03  
002FF7  1  20 FF 42 68  
003005  1  CA                   dex
003006  1  10 DD                bpl trorc6
003008  1  A2 05                ldx #5
00300A  1               trorc7:
00300A  1  A9 FF 48 B5          set_zx zps,$ff
00300E  1  13 95 0C 28  
003012  1  76 0C                ror zpt,x
003014  1  08 B5 0C DD          tst_zx rRORc,fRORc,$ff-fnzc
003018  1  33 02 F0 03  
00301C  1  20 FF 42 68  
00302A  1  CA                   dex
00302B  1  10 DD                bpl trorc7
00302D  1  AD 00 02 C9          next_test
003031  1  20 F0 03 20  
003035  1  FF 42 A9 21  
00303C  1               
00303C  1               ; shifts - abs indexed
00303C  1  A2 05                ldx #5
00303E  1               tasl8:
00303E  1  A9 00 48 B5          set_absx zps,0
003042  1  13 9D 03 02  
003046  1  28           
003047  1  1E 03 02             asl abst,x
00304A  1  08 BD 03 02          tst_absx rASL,fASL,0
00304E  1  DD 21 02 F0  
003052  1  03 20 FF 42  
003061  1  CA                   dex
003062  1  10 DA                bpl tasl8
003064  1  A2 05                ldx #5
003066  1               tasl9:
003066  1  A9 FF 48 B5          set_absx zps,$ff
00306A  1  13 9D 03 02  
00306E  1  28           
00306F  1  1E 03 02             asl abst,x
003072  1  08 BD 03 02          tst_absx rASL,fASL,$ff-fnzc
003076  1  DD 21 02 F0  
00307A  1  03 20 FF 42  
003089  1  CA                   dex
00308A  1  10 DA                bpl tasl9
00308C  1               
00308C  1  A2 05                ldx #5
00308E  1               tlsr8:
00308E  1  A9 00 48 B5          set_absx zps,0
003092  1  13 9D 03 02  
003096  1  28           
003097  1  5E 03 02             lsr abst,x
00309A  1  08 BD 03 02          tst_absx rLSR,fLSR,0
00309E  1  DD 2D 02 F0  
0030A2  1  03 20 FF 42  
0030B1  1  CA                   dex
0030B2  1  10 DA                bpl tlsr8
0030B4  1  A2 05                ldx #5
0030B6  1               tlsr9:
0030B6  1  A9 FF 48 B5          set_absx zps,$ff
0030BA  1  13 9D 03 02  
0030BE  1  28           
0030BF  1  5E 03 02             lsr abst,x
0030C2  1  08 BD 03 02          tst_absx rLSR,fLSR,$ff-fnzc
0030C6  1  DD 2D 02 F0  
0030CA  1  03 20 FF 42  
0030D9  1  CA                   dex
0030DA  1  10 DA                bpl tlsr9
0030DC  1               
0030DC  1  A2 05                ldx #5
0030DE  1               trol8:
0030DE  1  A9 00 48 B5          set_absx zps,0
0030E2  1  13 9D 03 02  
0030E6  1  28           
0030E7  1  3E 03 02             rol abst,x
0030EA  1  08 BD 03 02          tst_absx rROL,fROL,0
0030EE  1  DD 21 02 F0  
0030F2  1  03 20 FF 42  
003101  1  CA                   dex
003102  1  10 DA                bpl trol8
003104  1  A2 05                ldx #5
003106  1               trol9:
003106  1  A9 FE 48 B5          set_absx zps,$ff-fc
00310A  1  13 9D 03 02  
00310E  1  28           
00310F  1  3E 03 02             rol abst,x
003112  1  08 BD 03 02          tst_absx rROL,fROL,$ff-fnzc
003116  1  DD 21 02 F0  
00311A  1  03 20 FF 42  
003129  1  CA                   dex
00312A  1  10 DA                bpl trol9
00312C  1               
00312C  1  A2 05                ldx #5
00312E  1               trolc8:
00312E  1  A9 01 48 B5          set_absx zps,fc
003132  1  13 9D 03 02  
003136  1  28           
003137  1  3E 03 02             rol abst,x
00313A  1  08 BD 03 02          tst_absx rROLc,fROLc,0
00313E  1  DD 27 02 F0  
003142  1  03 20 FF 42  
003151  1  CA                   dex
003152  1  10 DA                bpl trolc8
003154  1  A2 05                ldx #5
003156  1               trolc9:
003156  1  A9 FF 48 B5          set_absx zps,$ff
00315A  1  13 9D 03 02  
00315E  1  28           
00315F  1  3E 03 02             rol abst,x
003162  1  08 BD 03 02          tst_absx rROLc,fROLc,$ff-fnzc
003166  1  DD 27 02 F0  
00316A  1  03 20 FF 42  
003179  1  CA                   dex
00317A  1  10 DA                bpl trolc9
00317C  1               
00317C  1  A2 05                ldx #5
00317E  1               tror8:
00317E  1  A9 00 48 B5          set_absx zps,0
003182  1  13 9D 03 02  
003186  1  28           
003187  1  7E 03 02             ror abst,x
00318A  1  08 BD 03 02          tst_absx rROR,fROR,0
00318E  1  DD 2D 02 F0  
003192  1  03 20 FF 42  
0031A1  1  CA                   dex
0031A2  1  10 DA                bpl tror8
0031A4  1  A2 05                ldx #5
0031A6  1               tror9:
0031A6  1  A9 FE 48 B5          set_absx zps,$ff-fc
0031AA  1  13 9D 03 02  
0031AE  1  28           
0031AF  1  7E 03 02             ror abst,x
0031B2  1  08 BD 03 02          tst_absx rROR,fROR,$ff-fnzc
0031B6  1  DD 2D 02 F0  
0031BA  1  03 20 FF 42  
0031C9  1  CA                   dex
0031CA  1  10 DA                bpl tror9
0031CC  1               
0031CC  1  A2 05                ldx #5
0031CE  1               trorc8:
0031CE  1  A9 01 48 B5          set_absx zps,fc
0031D2  1  13 9D 03 02  
0031D6  1  28           
0031D7  1  7E 03 02             ror abst,x
0031DA  1  08 BD 03 02          tst_absx rRORc,fRORc,0
0031DE  1  DD 33 02 F0  
0031E2  1  03 20 FF 42  
0031F1  1  CA                   dex
0031F2  1  10 DA                bpl trorc8
0031F4  1  A2 05                ldx #5
0031F6  1               trorc9:
0031F6  1  A9 FF 48 B5          set_absx zps,$ff
0031FA  1  13 9D 03 02  
0031FE  1  28           
0031FF  1  7E 03 02             ror abst,x
003202  1  08 BD 03 02          tst_absx rRORc,fRORc,$ff-fnzc
003206  1  DD 33 02 F0  
00320A  1  03 20 FF 42  
003219  1  CA                   dex
00321A  1  10 DA                bpl trorc9
00321C  1  AD 00 02 C9          next_test
003220  1  21 F0 03 20  
003224  1  FF 42 A9 22  
00322B  1               
00322B  1               ; testing memory increment/decrement - INC DEC all addressing modes
00322B  1               ; zeropage
00322B  1  A2 00                ldx #0
00322D  1  A9 7E                lda #$7e
00322F  1  85 0C                sta zpt
003231  1               tinc:
003231  1  A9 00 48 28          set_stat 0
003235  1  E6 0C                inc zpt
003237  1  08 A5 0C DD          tst_z rINC,fINC,0
00323B  1  51 02 F0 03  
00323F  1  20 FF 42 68  
00324D  1  E8                   inx
00324E  1  E0 02                cpx #2
003250  1  D0 04                bne tinc1
003252  1  A9 FE                lda #$fe
003254  1  85 0C                sta zpt
003256  1  E0 05        tinc1:  cpx #5
003258  1  D0 D7                bne tinc
00325A  1  CA                   dex
00325B  1  E6 0C                inc zpt
00325D  1               tdec:
00325D  1  A9 00 48 28          set_stat 0
003261  1  C6 0C                dec zpt
003263  1  08 A5 0C DD          tst_z rINC,fINC,0
003267  1  51 02 F0 03  
00326B  1  20 FF 42 68  
003279  1  CA                   dex
00327A  1  30 0A                bmi tdec1
00327C  1  E0 01                cpx #1
00327E  1  D0 DD                bne tdec
003280  1  A9 81                lda #$81
003282  1  85 0C                sta zpt
003284  1  D0 D7                bne tdec
003286  1               tdec1:
003286  1  A2 00                ldx #0
003288  1  A9 7E                lda #$7e
00328A  1  85 0C                sta zpt
00328C  1               tinc10:
00328C  1  A9 FF 48 28          set_stat $ff
003290  1  E6 0C                inc zpt
003292  1  08 A5 0C DD          tst_z rINC,fINC,$ff-fnz
003296  1  51 02 F0 03  
00329A  1  20 FF 42 68  
0032A8  1  E8                   inx
0032A9  1  E0 02                cpx #2
0032AB  1  D0 04                bne tinc11
0032AD  1  A9 FE                lda #$fe
0032AF  1  85 0C                sta zpt
0032B1  1  E0 05        tinc11: cpx #5
0032B3  1  D0 D7                bne tinc10
0032B5  1  CA                   dex
0032B6  1  E6 0C                inc zpt
0032B8  1               tdec10:
0032B8  1  A9 FF 48 28          set_stat $ff
0032BC  1  C6 0C                dec zpt
0032BE  1  08 A5 0C DD          tst_z rINC,fINC,$ff-fnz
0032C2  1  51 02 F0 03  
0032C6  1  20 FF 42 68  
0032D4  1  CA                   dex
0032D5  1  30 0A                bmi tdec11
0032D7  1  E0 01                cpx #1
0032D9  1  D0 DD                bne tdec10
0032DB  1  A9 81                lda #$81
0032DD  1  85 0C                sta zpt
0032DF  1  D0 D7                bne tdec10
0032E1  1               tdec11:
0032E1  1  AD 00 02 C9          next_test
0032E5  1  22 F0 03 20  
0032E9  1  FF 42 A9 23  
0032F0  1               
0032F0  1               ; absolute memory
0032F0  1  A2 00                ldx #0
0032F2  1  A9 7E                lda #$7e
0032F4  1  8D 03 02             sta abst
0032F7  1               tinc2:
0032F7  1  A9 00 48 28          set_stat 0
0032FB  1  EE 03 02             inc abst
0032FE  1  08 AD 03 02          tst_abs rINC,fINC,0
003302  1  DD 51 02 F0  
003306  1  03 20 FF 42  
003315  1  E8                   inx
003316  1  E0 02                cpx #2
003318  1  D0 05                bne tinc3
00331A  1  A9 FE                lda #$fe
00331C  1  8D 03 02             sta abst
00331F  1  E0 05        tinc3:  cpx #5
003321  1  D0 D4                bne tinc2
003323  1  CA                   dex
003324  1  EE 03 02             inc abst
003327  1               tdec2:
003327  1  A9 00 48 28          set_stat 0
00332B  1  CE 03 02             dec abst
00332E  1  08 AD 03 02          tst_abs rINC,fINC,0
003332  1  DD 51 02 F0  
003336  1  03 20 FF 42  
003345  1  CA                   dex
003346  1  30 0B                bmi tdec3
003348  1  E0 01                cpx #1
00334A  1  D0 DB                bne tdec2
00334C  1  A9 81                lda #$81
00334E  1  8D 03 02             sta abst
003351  1  D0 D4                bne tdec2
003353  1               tdec3:
003353  1  A2 00                ldx #0
003355  1  A9 7E                lda #$7e
003357  1  8D 03 02             sta abst
00335A  1               tinc12:
00335A  1  A9 FF 48 28          set_stat $ff
00335E  1  EE 03 02             inc abst
003361  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
003365  1  DD 51 02 F0  
003369  1  03 20 FF 42  
003378  1  E8                   inx
003379  1  E0 02                cpx #2
00337B  1  D0 05                bne tinc13
00337D  1  A9 FE                lda #$fe
00337F  1  8D 03 02             sta abst
003382  1  E0 05        tinc13:  cpx #5
003384  1  D0 D4                bne tinc12
003386  1  CA                   dex
003387  1  EE 03 02             inc abst
00338A  1               tdec12:
00338A  1  A9 FF 48 28          set_stat $ff
00338E  1  CE 03 02             dec abst
003391  1  08 AD 03 02          tst_abs rINC,fINC,$ff-fnz
003395  1  DD 51 02 F0  
003399  1  03 20 FF 42  
0033A8  1  CA                   dex
0033A9  1  30 0B                bmi tdec13
0033AB  1  E0 01                cpx #1
0033AD  1  D0 DB                bne tdec12
0033AF  1  A9 81                lda #$81
0033B1  1  8D 03 02             sta abst
0033B4  1  D0 D4                bne tdec12
0033B6  1               tdec13:
0033B6  1  AD 00 02 C9          next_test
0033BA  1  23 F0 03 20  
0033BE  1  FF 42 A9 24  
0033C5  1               
0033C5  1               ; zeropage indexed
0033C5  1  A2 00                ldx #0
0033C7  1  A9 7E                lda #$7e
0033C9  1  95 0C        tinc4:  sta zpt,x
0033CB  1  A9 00 48 28          set_stat 0
0033CF  1  F6 0C                inc zpt,x
0033D1  1  08 B5 0C DD          tst_zx rINC,fINC,0
0033D5  1  51 02 F0 03  
0033D9  1  20 FF 42 68  
0033E7  1  B5 0C                lda zpt,x
0033E9  1  E8                   inx
0033EA  1  E0 02                cpx #2
0033EC  1  D0 02                bne tinc5
0033EE  1  A9 FE                lda #$fe
0033F0  1  E0 05        tinc5:  cpx #5
0033F2  1  D0 D5                bne tinc4
0033F4  1  CA                   dex
0033F5  1  A9 02                lda #2
0033F7  1  95 0C        tdec4:  sta zpt,x
0033F9  1  A9 00 48 28          set_stat 0
0033FD  1  D6 0C                dec zpt,x
0033FF  1  08 B5 0C DD          tst_zx rINC,fINC,0
003403  1  51 02 F0 03  
003407  1  20 FF 42 68  
003415  1  B5 0C                lda zpt,x
003417  1  CA                   dex
003418  1  30 08                bmi tdec5
00341A  1  E0 01                cpx #1
00341C  1  D0 D9                bne tdec4
00341E  1  A9 81                lda #$81
003420  1  D0 D5                bne tdec4
003422  1               tdec5:
003422  1  A2 00                ldx #0
003424  1  A9 7E                lda #$7e
003426  1  95 0C        tinc14: sta zpt,x
003428  1  A9 FF 48 28          set_stat $ff
00342C  1  F6 0C                inc zpt,x
00342E  1  08 B5 0C DD          tst_zx rINC,fINC,$ff-fnz
003432  1  51 02 F0 03  
003436  1  20 FF 42 68  
003444  1  B5 0C                lda zpt,x
003446  1  E8                   inx
003447  1  E0 02                cpx #2
003449  1  D0 02                bne tinc15
00344B  1  A9 FE                lda #$fe
00344D  1  E0 05        tinc15: cpx #5
00344F  1  D0 D5                bne tinc14
003451  1  CA                   dex
003452  1  A9 02                lda #2
003454  1  95 0C        tdec14: sta zpt,x
003456  1  A9 FF 48 28          set_stat $ff
00345A  1  D6 0C                dec zpt,x
00345C  1  08 B5 0C DD          tst_zx rINC,fINC,$ff-fnz
003460  1  51 02 F0 03  
003464  1  20 FF 42 68  
003472  1  B5 0C                lda zpt,x
003474  1  CA                   dex
003475  1  30 08                bmi tdec15
003477  1  E0 01                cpx #1
003479  1  D0 D9                bne tdec14
00347B  1  A9 81                lda #$81
00347D  1  D0 D5                bne tdec14
00347F  1               tdec15:
00347F  1  AD 00 02 C9          next_test
003483  1  24 F0 03 20  
003487  1  FF 42 A9 25  
00348E  1               
00348E  1               ; memory indexed
00348E  1  A2 00                ldx #0
003490  1  A9 7E                lda #$7e
003492  1  9D 03 02     tinc6:  sta abst,x
003495  1  A9 00 48 28          set_stat 0
003499  1  FE 03 02             inc abst,x
00349C  1  08 BD 03 02          tst_absx rINC,fINC,0
0034A0  1  DD 51 02 F0  
0034A4  1  03 20 FF 42  
0034B3  1  BD 03 02             lda abst,x
0034B6  1  E8                   inx
0034B7  1  E0 02                cpx #2
0034B9  1  D0 02                bne tinc7
0034BB  1  A9 FE                lda #$fe
0034BD  1  E0 05        tinc7:  cpx #5
0034BF  1  D0 D1                bne tinc6
0034C1  1  CA                   dex
0034C2  1  A9 02                lda #2
0034C4  1  9D 03 02     tdec6:  sta abst,x
0034C7  1  A9 00 48 28          set_stat 0
0034CB  1  DE 03 02             dec abst,x
0034CE  1  08 BD 03 02          tst_absx rINC,fINC,0
0034D2  1  DD 51 02 F0  
0034D6  1  03 20 FF 42  
0034E5  1  BD 03 02             lda abst,x
0034E8  1  CA                   dex
0034E9  1  30 08                bmi tdec7
0034EB  1  E0 01                cpx #1
0034ED  1  D0 D5                bne tdec6
0034EF  1  A9 81                lda #$81
0034F1  1  D0 D1                bne tdec6
0034F3  1               tdec7:
0034F3  1  A2 00                ldx #0
0034F5  1  A9 7E                lda #$7e
0034F7  1  9D 03 02     tinc16: sta abst,x
0034FA  1  A9 FF 48 28          set_stat $ff
0034FE  1  FE 03 02             inc abst,x
003501  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
003505  1  DD 51 02 F0  
003509  1  03 20 FF 42  
003518  1  BD 03 02             lda abst,x
00351B  1  E8                   inx
00351C  1  E0 02                cpx #2
00351E  1  D0 02                bne tinc17
003520  1  A9 FE                lda #$fe
003522  1  E0 05        tinc17: cpx #5
003524  1  D0 D1                bne tinc16
003526  1  CA                   dex
003527  1  A9 02                lda #2
003529  1  9D 03 02     tdec16: sta abst,x
00352C  1  A9 FF 48 28          set_stat $ff
003530  1  DE 03 02             dec abst,x
003533  1  08 BD 03 02          tst_absx rINC,fINC,$ff-fnz
003537  1  DD 51 02 F0  
00353B  1  03 20 FF 42  
00354A  1  BD 03 02             lda abst,x
00354D  1  CA                   dex
00354E  1  30 08                bmi tdec17
003550  1  E0 01                cpx #1
003552  1  D0 D5                bne tdec16
003554  1  A9 81                lda #$81
003556  1  D0 D1                bne tdec16
003558  1               tdec17:
003558  1  AD 00 02 C9          next_test
00355C  1  25 F0 03 20  
003560  1  FF 42 A9 26  
003567  1               
003567  1               ; testing logical instructions - AND EOR ORA all addressing modes
003567  1               ; AND
003567  1  A2 03                ldx #3          ;immediate
003569  1  B5 1E        tand:   lda zpAN,x
00356B  1  8D 0A 02             sta ex_andi+1   ;set AND # operand
00356E  1  A9 00 48 BD          set_ax  absANa,0
003572  1  6B 02 28     
003575  1  20 09 02             jsr ex_andi     ;execute AND # in RAM
003578  1  08 DD 73 02          tst_ax  absrlo,absflo,0
00357C  1  F0 03 20 FF  
003580  1  42 68 49 30  
00358C  1  CA                   dex
00358D  1  10 DA                bpl tand
00358F  1  A2 03                ldx #3
003591  1  B5 1E        tand1:  lda zpAN,x
003593  1  8D 0A 02             sta ex_andi+1   ;set AND # operand
003596  1  A9 FF 48 BD          set_ax  absANa,$ff
00359A  1  6B 02 28     
00359D  1  20 09 02             jsr ex_andi     ;execute AND # in RAM
0035A0  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
0035A4  1  F0 03 20 FF  
0035A8  1  42 68 49 7D  
0035B4  1  CA                   dex
0035B5  1  10 DA                bpl tand1
0035B7  1               
0035B7  1  A2 03                ldx #3      ;zp
0035B9  1  B5 1E        tand2:  lda zpAN,x
0035BB  1  85 0C                sta zpt
0035BD  1  A9 00 48 BD          set_ax  absANa,0
0035C1  1  6B 02 28     
0035C4  1  25 0C                and zpt
0035C6  1  08 DD 73 02          tst_ax  absrlo,absflo,0
0035CA  1  F0 03 20 FF  
0035CE  1  42 68 49 30  
0035DA  1  CA                   dex
0035DB  1  10 DC                bpl tand2
0035DD  1  A2 03                ldx #3
0035DF  1  B5 1E        tand3:  lda zpAN,x
0035E1  1  85 0C                sta zpt
0035E3  1  A9 FF 48 BD          set_ax  absANa,$ff
0035E7  1  6B 02 28     
0035EA  1  25 0C                and zpt
0035EC  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
0035F0  1  F0 03 20 FF  
0035F4  1  42 68 49 7D  
003600  1  CA                   dex
003601  1  10 DC                bpl tand3
003603  1               
003603  1  A2 03                ldx #3      ;abs
003605  1  B5 1E        tand4:  lda zpAN,x
003607  1  8D 03 02             sta abst
00360A  1  A9 00 48 BD          set_ax  absANa,0
00360E  1  6B 02 28     
003611  1  2D 03 02             and abst
003614  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003618  1  F0 03 20 FF  
00361C  1  42 68 49 30  
003628  1  CA                   dex
003629  1  10 DA                bpl tand4
00362B  1  A2 03                ldx #3
00362D  1  B5 1E        tand5:  lda zpAN,x
00362F  1  8D 03 02             sta abst
003632  1  A9 FF 48 BD          set_ax  absANa,$ff
003636  1  6B 02 28     
003639  1  2D 03 02             and abst
00363C  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003640  1  F0 03 20 FF  
003644  1  42 68 49 7D  
003650  1  CA                   dex
003651  1  10 02                bpl tand6
003653  1               
003653  1  A2 03                ldx #3      ;zp,x
003655  1               tand6:
003655  1  A9 00 48 BD          set_ax  absANa,0
003659  1  6B 02 28     
00365C  1  35 1E                and zpAN,x
00365E  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003662  1  F0 03 20 FF  
003666  1  42 68 49 30  
003672  1  CA                   dex
003673  1  10 E0                bpl tand6
003675  1  A2 03                ldx #3
003677  1               tand7:
003677  1  A9 FF 48 BD          set_ax  absANa,$ff
00367B  1  6B 02 28     
00367E  1  35 1E                and zpAN,x
003680  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003684  1  F0 03 20 FF  
003688  1  42 68 49 7D  
003694  1  CA                   dex
003695  1  10 E0                bpl tand7
003697  1               
003697  1  A2 03                ldx #3      ;abs,x
003699  1               tand8:
003699  1  A9 00 48 BD          set_ax  absANa,0
00369D  1  6B 02 28     
0036A0  1  3D 5F 02             and absAN,x
0036A3  1  08 DD 73 02          tst_ax  absrlo,absflo,0
0036A7  1  F0 03 20 FF  
0036AB  1  42 68 49 30  
0036B7  1  CA                   dex
0036B8  1  10 DF                bpl tand8
0036BA  1  A2 03                ldx #3
0036BC  1               tand9:
0036BC  1  A9 FF 48 BD          set_ax  absANa,$ff
0036C0  1  6B 02 28     
0036C3  1  3D 5F 02             and absAN,x
0036C6  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
0036CA  1  F0 03 20 FF  
0036CE  1  42 68 49 7D  
0036DA  1  CA                   dex
0036DB  1  10 DF                bpl tand9
0036DD  1               
0036DD  1  A0 03                ldy #3      ;abs,y
0036DF  1               tand10:
0036DF  1  A9 00 48 B9          set_ay  absANa,0
0036E3  1  6B 02 28     
0036E6  1  39 5F 02             and absAN,y
0036E9  1  08 D9 73 02          tst_ay  absrlo,absflo,0
0036ED  1  F0 03 20 FF  
0036F1  1  42 68 49 30  
0036FD  1  88                   dey
0036FE  1  10 DF                bpl tand10
003700  1  A0 03                ldy #3
003702  1               tand11:
003702  1  A9 FF 48 B9          set_ay  absANa,$ff
003706  1  6B 02 28     
003709  1  39 5F 02             and absAN,y
00370C  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
003710  1  F0 03 20 FF  
003714  1  42 68 49 7D  
003720  1  88                   dey
003721  1  10 DF                bpl tand11
003723  1               
003723  1  A2 06                ldx #6      ;(zp,x)
003725  1  A0 03                ldy #3
003727  1               tand12:
003727  1  A9 00 48 B9          set_ay  absANa,0
00372B  1  6B 02 28     
00372E  1  21 3C                and (indAN,x)
003730  1  08 D9 73 02          tst_ay  absrlo,absflo,0
003734  1  F0 03 20 FF  
003738  1  42 68 49 30  
003744  1  CA                   dex
003745  1  CA                   dex
003746  1  88                   dey
003747  1  10 DE                bpl tand12
003749  1  A2 06                ldx #6
00374B  1  A0 03                ldy #3
00374D  1               tand13:
00374D  1  A9 FF 48 B9          set_ay  absANa,$ff
003751  1  6B 02 28     
003754  1  21 3C                and (indAN,x)
003756  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
00375A  1  F0 03 20 FF  
00375E  1  42 68 49 7D  
00376A  1  CA                   dex
00376B  1  CA                   dex
00376C  1  88                   dey
00376D  1  10 DE                bpl tand13
00376F  1               
00376F  1  A0 03                ldy #3      ;(zp),y
003771  1               tand14:
003771  1  A9 00 48 B9          set_ay  absANa,0
003775  1  6B 02 28     
003778  1  31 3C                and (indAN),y
00377A  1  08 D9 73 02          tst_ay  absrlo,absflo,0
00377E  1  F0 03 20 FF  
003782  1  42 68 49 30  
00378E  1  88                   dey
00378F  1  10 E0                bpl tand14
003791  1  A0 03                ldy #3
003793  1               tand15:
003793  1  A9 FF 48 B9          set_ay  absANa,$ff
003797  1  6B 02 28     
00379A  1  31 3C                and (indAN),y
00379C  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
0037A0  1  F0 03 20 FF  
0037A4  1  42 68 49 7D  
0037B0  1  88                   dey
0037B1  1  10 E0                bpl tand15
0037B3  1  AD 00 02 C9          next_test
0037B7  1  26 F0 03 20  
0037BB  1  FF 42 A9 27  
0037C2  1               
0037C2  1               ; EOR
0037C2  1  A2 03                ldx #3          ;immediate - self modifying code
0037C4  1  B5 22        teor:   lda zpEO,x
0037C6  1  8D 0D 02             sta ex_eori+1   ;set EOR # operand
0037C9  1  A9 00 48 BD          set_ax  absEOa,0
0037CD  1  6F 02 28     
0037D0  1  20 0C 02             jsr ex_eori     ;execute EOR # in RAM
0037D3  1  08 DD 73 02          tst_ax  absrlo,absflo,0
0037D7  1  F0 03 20 FF  
0037DB  1  42 68 49 30  
0037E7  1  CA                   dex
0037E8  1  10 DA                bpl teor
0037EA  1  A2 03                ldx #3
0037EC  1  B5 22        teor1:  lda zpEO,x
0037EE  1  8D 0D 02             sta ex_eori+1   ;set EOR # operand
0037F1  1  A9 FF 48 BD          set_ax  absEOa,$ff
0037F5  1  6F 02 28     
0037F8  1  20 0C 02             jsr ex_eori     ;execute EOR # in RAM
0037FB  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
0037FF  1  F0 03 20 FF  
003803  1  42 68 49 7D  
00380F  1  CA                   dex
003810  1  10 DA                bpl teor1
003812  1               
003812  1  A2 03                ldx #3      ;zp
003814  1  B5 22        teor2:   lda zpEO,x
003816  1  85 0C                sta zpt
003818  1  A9 00 48 BD          set_ax  absEOa,0
00381C  1  6F 02 28     
00381F  1  45 0C                eor zpt
003821  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003825  1  F0 03 20 FF  
003829  1  42 68 49 30  
003835  1  CA                   dex
003836  1  10 DC                bpl teor2
003838  1  A2 03                ldx #3
00383A  1  B5 22        teor3:  lda zpEO,x
00383C  1  85 0C                sta zpt
00383E  1  A9 FF 48 BD          set_ax  absEOa,$ff
003842  1  6F 02 28     
003845  1  45 0C                eor zpt
003847  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
00384B  1  F0 03 20 FF  
00384F  1  42 68 49 7D  
00385B  1  CA                   dex
00385C  1  10 DC                bpl teor3
00385E  1               
00385E  1  A2 03                ldx #3      ;abs
003860  1  B5 22        teor4:  lda zpEO,x
003862  1  8D 03 02             sta abst
003865  1  A9 00 48 BD          set_ax  absEOa,0
003869  1  6F 02 28     
00386C  1  4D 03 02             eor abst
00386F  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003873  1  F0 03 20 FF  
003877  1  42 68 49 30  
003883  1  CA                   dex
003884  1  10 DA                bpl teor4
003886  1  A2 03                ldx #3
003888  1  B5 22        teor5:  lda zpEO,x
00388A  1  8D 03 02             sta abst
00388D  1  A9 FF 48 BD          set_ax  absEOa,$ff
003891  1  6F 02 28     
003894  1  4D 03 02             eor abst
003897  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
00389B  1  F0 03 20 FF  
00389F  1  42 68 49 7D  
0038AB  1  CA                   dex
0038AC  1  10 02                bpl teor6
0038AE  1               
0038AE  1  A2 03                ldx #3      ;zp,x
0038B0  1               teor6:
0038B0  1  A9 00 48 BD          set_ax  absEOa,0
0038B4  1  6F 02 28     
0038B7  1  55 22                eor zpEO,x
0038B9  1  08 DD 73 02          tst_ax  absrlo,absflo,0
0038BD  1  F0 03 20 FF  
0038C1  1  42 68 49 30  
0038CD  1  CA                   dex
0038CE  1  10 E0                bpl teor6
0038D0  1  A2 03                ldx #3
0038D2  1               teor7:
0038D2  1  A9 FF 48 BD          set_ax  absEOa,$ff
0038D6  1  6F 02 28     
0038D9  1  55 22                eor zpEO,x
0038DB  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
0038DF  1  F0 03 20 FF  
0038E3  1  42 68 49 7D  
0038EF  1  CA                   dex
0038F0  1  10 E0                bpl teor7
0038F2  1               
0038F2  1  A2 03                ldx #3      ;abs,x
0038F4  1               teor8:
0038F4  1  A9 00 48 BD          set_ax  absEOa,0
0038F8  1  6F 02 28     
0038FB  1  5D 63 02             eor absEO,x
0038FE  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003902  1  F0 03 20 FF  
003906  1  42 68 49 30  
003912  1  CA                   dex
003913  1  10 DF                bpl teor8
003915  1  A2 03                ldx #3
003917  1               teor9:
003917  1  A9 FF 48 BD          set_ax  absEOa,$ff
00391B  1  6F 02 28     
00391E  1  5D 63 02             eor absEO,x
003921  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003925  1  F0 03 20 FF  
003929  1  42 68 49 7D  
003935  1  CA                   dex
003936  1  10 DF                bpl teor9
003938  1               
003938  1  A0 03                ldy #3      ;abs,y
00393A  1               teor10:
00393A  1  A9 00 48 B9          set_ay  absEOa,0
00393E  1  6F 02 28     
003941  1  59 63 02             eor absEO,y
003944  1  08 D9 73 02          tst_ay  absrlo,absflo,0
003948  1  F0 03 20 FF  
00394C  1  42 68 49 30  
003958  1  88                   dey
003959  1  10 DF                bpl teor10
00395B  1  A0 03                ldy #3
00395D  1               teor11:
00395D  1  A9 FF 48 B9          set_ay  absEOa,$ff
003961  1  6F 02 28     
003964  1  59 63 02             eor absEO,y
003967  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
00396B  1  F0 03 20 FF  
00396F  1  42 68 49 7D  
00397B  1  88                   dey
00397C  1  10 DF                bpl teor11
00397E  1               
00397E  1  A2 06                ldx #6      ;(zp,x)
003980  1  A0 03                ldy #3
003982  1               teor12:
003982  1  A9 00 48 B9          set_ay  absEOa,0
003986  1  6F 02 28     
003989  1  41 44                eor (indEO,x)
00398B  1  08 D9 73 02          tst_ay  absrlo,absflo,0
00398F  1  F0 03 20 FF  
003993  1  42 68 49 30  
00399F  1  CA                   dex
0039A0  1  CA                   dex
0039A1  1  88                   dey
0039A2  1  10 DE                bpl teor12
0039A4  1  A2 06                ldx #6
0039A6  1  A0 03                ldy #3
0039A8  1               teor13:
0039A8  1  A9 FF 48 B9          set_ay  absEOa,$ff
0039AC  1  6F 02 28     
0039AF  1  41 44                eor (indEO,x)
0039B1  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
0039B5  1  F0 03 20 FF  
0039B9  1  42 68 49 7D  
0039C5  1  CA                   dex
0039C6  1  CA                   dex
0039C7  1  88                   dey
0039C8  1  10 DE                bpl teor13
0039CA  1               
0039CA  1  A0 03                ldy #3      ;(zp),y
0039CC  1               teor14:
0039CC  1  A9 00 48 B9          set_ay  absEOa,0
0039D0  1  6F 02 28     
0039D3  1  51 44                eor (indEO),y
0039D5  1  08 D9 73 02          tst_ay  absrlo,absflo,0
0039D9  1  F0 03 20 FF  
0039DD  1  42 68 49 30  
0039E9  1  88                   dey
0039EA  1  10 E0                bpl teor14
0039EC  1  A0 03                ldy #3
0039EE  1               teor15:
0039EE  1  A9 FF 48 B9          set_ay  absEOa,$ff
0039F2  1  6F 02 28     
0039F5  1  51 44                eor (indEO),y
0039F7  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
0039FB  1  F0 03 20 FF  
0039FF  1  42 68 49 7D  
003A0B  1  88                   dey
003A0C  1  10 E0                bpl teor15
003A0E  1  AD 00 02 C9          next_test
003A12  1  27 F0 03 20  
003A16  1  FF 42 A9 28  
003A1D  1               
003A1D  1               ; OR
003A1D  1  A2 03                ldx #3          ;immediate - self modifying code
003A1F  1  B5 1A        tora:   lda zpOR,x
003A21  1  8D 10 02             sta ex_orai+1   ;set ORA # operand
003A24  1  A9 00 48 BD          set_ax  absORa,0
003A28  1  67 02 28     
003A2B  1  20 0F 02             jsr ex_orai     ;execute ORA # in RAM
003A2E  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003A32  1  F0 03 20 FF  
003A36  1  42 68 49 30  
003A42  1  CA                   dex
003A43  1  10 DA                bpl tora
003A45  1  A2 03                ldx #3
003A47  1  B5 1A        tora1:  lda zpOR,x
003A49  1  8D 10 02             sta ex_orai+1   ;set ORA # operand
003A4C  1  A9 FF 48 BD          set_ax  absORa,$ff
003A50  1  67 02 28     
003A53  1  20 0F 02             jsr ex_orai     ;execute ORA # in RAM
003A56  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003A5A  1  F0 03 20 FF  
003A5E  1  42 68 49 7D  
003A6A  1  CA                   dex
003A6B  1  10 DA                bpl tora1
003A6D  1               
003A6D  1  A2 03                ldx #3      ;zp
003A6F  1  B5 1A        tora2:  lda zpOR,x
003A71  1  85 0C                sta zpt
003A73  1  A9 00 48 BD          set_ax  absORa,0
003A77  1  67 02 28     
003A7A  1  05 0C                ora zpt
003A7C  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003A80  1  F0 03 20 FF  
003A84  1  42 68 49 30  
003A90  1  CA                   dex
003A91  1  10 DC                bpl tora2
003A93  1  A2 03                ldx #3
003A95  1  B5 1A        tora3:  lda zpOR,x
003A97  1  85 0C                sta zpt
003A99  1  A9 FF 48 BD          set_ax  absORa,$ff
003A9D  1  67 02 28     
003AA0  1  05 0C                ora zpt
003AA2  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003AA6  1  F0 03 20 FF  
003AAA  1  42 68 49 7D  
003AB6  1  CA                   dex
003AB7  1  10 DC                bpl tora3
003AB9  1               
003AB9  1  A2 03                ldx #3      ;abs
003ABB  1  B5 1A        tora4:  lda zpOR,x
003ABD  1  8D 03 02             sta abst
003AC0  1  A9 00 48 BD          set_ax  absORa,0
003AC4  1  67 02 28     
003AC7  1  0D 03 02             ora abst
003ACA  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003ACE  1  F0 03 20 FF  
003AD2  1  42 68 49 30  
003ADE  1  CA                   dex
003ADF  1  10 DA                bpl tora4
003AE1  1  A2 03                ldx #3
003AE3  1  B5 1A        tora5:  lda zpOR,x
003AE5  1  8D 03 02             sta abst
003AE8  1  A9 FF 48 BD          set_ax  absORa,$ff
003AEC  1  67 02 28     
003AEF  1  0D 03 02             ora abst
003AF2  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003AF6  1  F0 03 20 FF  
003AFA  1  42 68 49 7D  
003B06  1  CA                   dex
003B07  1  10 02                bpl tora6
003B09  1               
003B09  1  A2 03                ldx #3      ;zp,x
003B0B  1               tora6:
003B0B  1  A9 00 48 BD          set_ax  absORa,0
003B0F  1  67 02 28     
003B12  1  15 1A                ora zpOR,x
003B14  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003B18  1  F0 03 20 FF  
003B1C  1  42 68 49 30  
003B28  1  CA                   dex
003B29  1  10 E0                bpl tora6
003B2B  1  A2 03                ldx #3
003B2D  1               tora7:
003B2D  1  A9 FF 48 BD          set_ax  absORa,$ff
003B31  1  67 02 28     
003B34  1  15 1A                ora zpOR,x
003B36  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003B3A  1  F0 03 20 FF  
003B3E  1  42 68 49 7D  
003B4A  1  CA                   dex
003B4B  1  10 E0                bpl tora7
003B4D  1               
003B4D  1  A2 03                ldx #3      ;abs,x
003B4F  1               tora8:
003B4F  1  A9 00 48 BD          set_ax  absORa,0
003B53  1  67 02 28     
003B56  1  1D 5B 02             ora absOR,x
003B59  1  08 DD 73 02          tst_ax  absrlo,absflo,0
003B5D  1  F0 03 20 FF  
003B61  1  42 68 49 30  
003B6D  1  CA                   dex
003B6E  1  10 DF                bpl tora8
003B70  1  A2 03                ldx #3
003B72  1               tora9:
003B72  1  A9 FF 48 BD          set_ax  absORa,$ff
003B76  1  67 02 28     
003B79  1  1D 5B 02             ora absOR,x
003B7C  1  08 DD 73 02          tst_ax  absrlo,absflo,$ff-fnz
003B80  1  F0 03 20 FF  
003B84  1  42 68 49 7D  
003B90  1  CA                   dex
003B91  1  10 DF                bpl tora9
003B93  1               
003B93  1  A0 03                ldy #3      ;abs,y
003B95  1               tora10:
003B95  1  A9 00 48 B9          set_ay  absORa,0
003B99  1  67 02 28     
003B9C  1  19 5B 02             ora absOR,y
003B9F  1  08 D9 73 02          tst_ay  absrlo,absflo,0
003BA3  1  F0 03 20 FF  
003BA7  1  42 68 49 30  
003BB3  1  88                   dey
003BB4  1  10 DF                bpl tora10
003BB6  1  A0 03                ldy #3
003BB8  1               tora11:
003BB8  1  A9 FF 48 B9          set_ay  absORa,$ff
003BBC  1  67 02 28     
003BBF  1  19 5B 02             ora absOR,y
003BC2  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
003BC6  1  F0 03 20 FF  
003BCA  1  42 68 49 7D  
003BD6  1  88                   dey
003BD7  1  10 DF                bpl tora11
003BD9  1               
003BD9  1  A2 06                ldx #6      ;(zp,x)
003BDB  1  A0 03                ldy #3
003BDD  1               tora12:
003BDD  1  A9 00 48 B9          set_ay  absORa,0
003BE1  1  67 02 28     
003BE4  1  01 4C                ora (indOR,x)
003BE6  1  08 D9 73 02          tst_ay  absrlo,absflo,0
003BEA  1  F0 03 20 FF  
003BEE  1  42 68 49 30  
003BFA  1  CA                   dex
003BFB  1  CA                   dex
003BFC  1  88                   dey
003BFD  1  10 DE                bpl tora12
003BFF  1  A2 06                ldx #6
003C01  1  A0 03                ldy #3
003C03  1               tora13:
003C03  1  A9 FF 48 B9          set_ay  absORa,$ff
003C07  1  67 02 28     
003C0A  1  01 4C                ora (indOR,x)
003C0C  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
003C10  1  F0 03 20 FF  
003C14  1  42 68 49 7D  
003C20  1  CA                   dex
003C21  1  CA                   dex
003C22  1  88                   dey
003C23  1  10 DE                bpl tora13
003C25  1               
003C25  1  A0 03                ldy #3      ;(zp),y
003C27  1               tora14:
003C27  1  A9 00 48 B9          set_ay  absORa,0
003C2B  1  67 02 28     
003C2E  1  11 4C                ora (indOR),y
003C30  1  08 D9 73 02          tst_ay  absrlo,absflo,0
003C34  1  F0 03 20 FF  
003C38  1  42 68 49 30  
003C44  1  88                   dey
003C45  1  10 E0                bpl tora14
003C47  1  A0 03                ldy #3
003C49  1               tora15:
003C49  1  A9 FF 48 B9          set_ay  absORa,$ff
003C4D  1  67 02 28     
003C50  1  11 4C                ora (indOR),y
003C52  1  08 D9 73 02          tst_ay  absrlo,absflo,$ff-fnz
003C56  1  F0 03 20 FF  
003C5A  1  42 68 49 7D  
003C66  1  88                   dey
003C67  1  10 E0                bpl tora15
003C69  1                   .if I_flag = 3
003C69  1  58                   cli
003C6A  1                   .endif
003C6A  1  AD 00 02 C9          next_test
003C6E  1  28 F0 03 20  
003C72  1  FF 42 A9 29  
003C79  1               
003C79  1               ; full binary add/subtract test
003C79  1               ; iterates through all combinations of operands and carry input
003C79  1               ; uses increments/decrements to predict result & result flags
003C79  1  D8                   cld
003C7A  1  A2 0E                ldx #ad2        ;for indexed test
003C7C  1  A0 FF                ldy #$ff        ;max range
003C7E  1  A9 00                lda #0          ;start with adding zeroes & no carry
003C80  1  85 0C                sta adfc        ;carry in - for diag
003C82  1  85 0D                sta ad1         ;operand 1 - accumulator
003C84  1  85 0E                sta ad2         ;operand 2 - memory or immediate
003C86  1  8D 03 02             sta ada2        ;non zp
003C89  1  85 0F                sta adrl        ;expected result bits 0-7
003C8B  1  85 10                sta adrh        ;expected result bit 8 (carry out)
003C8D  1  A9 FF                lda #$ff        ;complemented operand 2 for subtract
003C8F  1  85 12                sta sb2
003C91  1  8D 04 02             sta sba2        ;non zp
003C94  1  A9 02                lda #2          ;expected Z-flag
003C96  1  85 11                sta adrf
003C98  1  18           tadd:   clc             ;test with carry clear
003C99  1  20 8E 3F             jsr chkadd
003C9C  1  E6 0C                inc adfc        ;now with carry
003C9E  1  E6 0F                inc adrl        ;result +1
003CA0  1  08                   php             ;save N & Z from low result
003CA1  1  08                   php
003CA2  1  68                   pla             ;accu holds expected flags
003CA3  1  29 82                and #$82        ;mask N & Z
003CA5  1  28                   plp
003CA6  1  D0 02                bne tadd1
003CA8  1  E6 10                inc adrh        ;result bit 8 - carry
003CAA  1  05 10        tadd1:  ora adrh        ;merge C to expected flags
003CAC  1  85 11                sta adrf        ;save expected flags except overflow
003CAE  1  38                   sec             ;test with carry set
003CAF  1  20 8E 3F             jsr chkadd
003CB2  1  C6 0C                dec adfc        ;same for operand +1 but no carry
003CB4  1  E6 0D                inc ad1
003CB6  1  D0 E0                bne tadd        ;iterate op1
003CB8  1  A9 00                lda #0          ;preset result to op2 when op1 = 0
003CBA  1  85 10                sta adrh
003CBC  1  EE 03 02             inc ada2
003CBF  1  E6 0E                inc ad2
003CC1  1  08                   php             ;save NZ as operand 2 becomes the new result
003CC2  1  68                   pla
003CC3  1  29 82                and #$82        ;mask N00000Z0
003CC5  1  85 11                sta adrf        ;no need to check carry as we are adding to 0
003CC7  1  C6 12                dec sb2         ;complement subtract operand 2
003CC9  1  CE 04 02             dec sba2
003CCC  1  A5 0E                lda ad2
003CCE  1  85 0F                sta adrl
003CD0  1  D0 C6                bne tadd        ;iterate op2
003CD2  1                   .if disable_decimal < 1
003CD2  1  AD 00 02 C9          next_test
003CD6  1  29 F0 03 20  
003CDA  1  FF 42 A9 2A  
003CE1  1               
003CE1  1               ; decimal add/subtract test
003CE1  1               ; *** WARNING - tests documented behavior only! ***
003CE1  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003CE1  1               ; iterates through all valid combinations of operands and carry input
003CE1  1               ; uses increments/decrements to predict result & carry flag
003CE1  1  F8                   sed
003CE2  1  A2 0E                ldx #ad2        ;for indexed test
003CE4  1  A0 FF                ldy #$ff        ;max range
003CE6  1  A9 99                lda #$99        ;start with adding 99 to 99 with carry
003CE8  1  85 0D                sta ad1         ;operand 1 - accumulator
003CEA  1  85 0E                sta ad2         ;operand 2 - memory or immediate
003CEC  1  8D 03 02             sta ada2        ;non zp
003CEF  1  85 0F                sta adrl        ;expected result bits 0-7
003CF1  1  A9 01                lda #1          ;set carry in & out
003CF3  1  85 0C                sta adfc        ;carry in - for diag
003CF5  1  85 10                sta adrh        ;expected result bit 8 (carry out)
003CF7  1  A9 00                lda #0          ;complemented operand 2 for subtract
003CF9  1  85 12                sta sb2
003CFB  1  8D 04 02             sta sba2        ;non zp
003CFE  1  38           tdad:   sec             ;test with carry set
003CFF  1  20 FB 3D             jsr chkdad
003D02  1  C6 0C                dec adfc        ;now with carry clear
003D04  1  A5 0F                lda adrl        ;decimal adjust result
003D06  1  D0 08                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
003D08  1  C6 10                dec adrh
003D0A  1  A9 99                lda #$99
003D0C  1  85 0F                sta adrl
003D0E  1  D0 12                bne tdad3
003D10  1  29 0F        tdad1:  and #$f         ;lower nibble mask
003D12  1  D0 0C                bne tdad2       ;no decimal adjust needed
003D14  1  C6 0F                dec adrl        ;decimal adjust (?0-6)
003D16  1  C6 0F                dec adrl
003D18  1  C6 0F                dec adrl
003D1A  1  C6 0F                dec adrl
003D1C  1  C6 0F                dec adrl
003D1E  1  C6 0F                dec adrl
003D20  1  C6 0F        tdad2:  dec adrl        ;result -1
003D22  1  18           tdad3:  clc             ;test with carry clear
003D23  1  20 FB 3D             jsr chkdad
003D26  1  E6 0C                inc adfc        ;same for operand -1 but with carry
003D28  1  A5 0D                lda ad1         ;decimal adjust operand 1
003D2A  1  F0 15                beq tdad5       ;iterate operand 2
003D2C  1  29 0F                and #$f         ;lower nibble mask
003D2E  1  D0 0C                bne tdad4       ;skip decimal adjust
003D30  1  C6 0D                dec ad1         ;decimal adjust (?0-6)
003D32  1  C6 0D                dec ad1
003D34  1  C6 0D                dec ad1
003D36  1  C6 0D                dec ad1
003D38  1  C6 0D                dec ad1
003D3A  1  C6 0D                dec ad1
003D3C  1  C6 0D        tdad4:  dec ad1         ;operand 1 -1
003D3E  1  4C FE 3C             jmp tdad        ;iterate op1
003D41  1               
003D41  1  A9 99        tdad5:  lda #$99        ;precharge op1 max
003D43  1  85 0D                sta ad1
003D45  1  A5 0E                lda ad2         ;decimal adjust operand 2
003D47  1  F0 30                beq tdad7       ;end of iteration
003D49  1  29 0F                and #$f         ;lower nibble mask
003D4B  1  D0 18                bne tdad6       ;skip decimal adjust
003D4D  1  C6 0E                dec ad2         ;decimal adjust (?0-6)
003D4F  1  C6 0E                dec ad2
003D51  1  C6 0E                dec ad2
003D53  1  C6 0E                dec ad2
003D55  1  C6 0E                dec ad2
003D57  1  C6 0E                dec ad2
003D59  1  E6 12                inc sb2         ;complemented decimal adjust for subtract (?9+6)
003D5B  1  E6 12                inc sb2
003D5D  1  E6 12                inc sb2
003D5F  1  E6 12                inc sb2
003D61  1  E6 12                inc sb2
003D63  1  E6 12                inc sb2
003D65  1  C6 0E        tdad6:  dec ad2         ;operand 2 -1
003D67  1  E6 12                inc sb2         ;complemented operand for subtract
003D69  1  A5 12                lda sb2
003D6B  1  8D 04 02             sta sba2        ;copy as non zp operand
003D6E  1  A5 0E                lda ad2
003D70  1  8D 03 02             sta ada2        ;copy as non zp operand
003D73  1  85 0F                sta adrl        ;new result since op1+carry=00+carry +op2=op2
003D75  1  E6 10                inc adrh        ;result carry
003D77  1  D0 85                bne tdad        ;iterate op2
003D79  1               tdad7:
003D79  1  AD 00 02 C9          next_test
003D7D  1  2A F0 03 20  
003D81  1  FF 42 A9 2B  
003D88  1               
003D88  1               ; decimal/binary switch test
003D88  1               ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
003D88  1               ;   tables
003D88  1  18                   clc
003D89  1  D8                   cld
003D8A  1  08                   php
003D8B  1  A9 55                lda #$55
003D8D  1  69 55                adc #$55
003D8F  1  C9 AA                cmp #$aa
003D91  1  F0 03 20 FF          trap_ne         ;expected binary result after cld
003D95  1  42           
003D96  1  18                   clc
003D97  1  F8                   sed
003D98  1  08                   php
003D99  1  A9 55                lda #$55
003D9B  1  69 55                adc #$55
003D9D  1  C9 10                cmp #$10
003D9F  1  F0 03 20 FF          trap_ne         ;expected decimal result after sed
003DA3  1  42           
003DA4  1  D8                   cld
003DA5  1  28                   plp
003DA6  1  A9 55                lda #$55
003DA8  1  69 55                adc #$55
003DAA  1  C9 10                cmp #$10
003DAC  1  F0 03 20 FF          trap_ne         ;expected decimal result after plp D=1
003DB0  1  42           
003DB1  1  28                   plp
003DB2  1  A9 55                lda #$55
003DB4  1  69 55                adc #$55
003DB6  1  C9 AA                cmp #$aa
003DB8  1  F0 03 20 FF          trap_ne         ;expected binary result after plp D=0
003DBC  1  42           
003DBD  1  18                   clc
003DBE  1  A9 3D                lda #>bin_rti_ret ;emulated interrupt for rti
003DC0  1  48                   pha
003DC1  1  A9 DB                lda #<bin_rti_ret
003DC3  1  48                   pha
003DC4  1  08                   php
003DC5  1  F8                   sed
003DC6  1  A9 3D                lda #>dec_rti_ret ;emulated interrupt for rti
003DC8  1  48                   pha
003DC9  1  A9 CF                lda #<dec_rti_ret
003DCB  1  48                   pha
003DCC  1  08                   php
003DCD  1  D8                   cld
003DCE  1  40                   rti
003DCF  1               dec_rti_ret:
003DCF  1  A9 55                lda #$55
003DD1  1  69 55                adc #$55
003DD3  1  C9 10                cmp #$10
003DD5  1  F0 03 20 FF          trap_ne         ;expected decimal result after rti D=1
003DD9  1  42           
003DDA  1  40                   rti
003DDB  1               bin_rti_ret:
003DDB  1  A9 55                lda #$55
003DDD  1  69 55                adc #$55
003DDF  1  C9 AA                cmp #$aa
003DE1  1  F0 03 20 FF          trap_ne         ;expected binary result after rti D=0
003DE5  1  42           
003DE6  1                   .endif
003DE6  1               
003DE6  1  AD 00 02             lda test_case
003DE9  1  C9 2B                cmp #test_num
003DEB  1  F0 03 20 FF          trap_ne         ;previous test is out of sequence
003DEF  1  42           
003DF0  1  A9 F0                lda #$f0        ;mark opcode testing complete
003DF2  1  8D 00 02             sta test_case
003DF5  1               
003DF5  1               ; final RAM integrity test
003DF5  1               ;   verifies that none of the previous tests has altered RAM outside of the
003DF5  1               ;   designated write areas.
003DF5  1                       check_ram
003DF5  1               ; *** DEBUG INFO ***
003DF5  1               ; to debug checksum errors uncomment check_ram in the next_test macro to
003DF5  1               ; narrow down the responsible opcode.
003DF5  1               ; may give false errors when monitor, OS or other background activity is
003DF5  1               ; allowed during previous tests.
003DF5  1               
003DF5  1               
003DF5  1               ; S U C C E S S ************************************************
003DF5  1               ; -------------
003DF5  1  20 DC 43             success         ;if you get here everything went well
003DF8  1               ; -------------
003DF8  1               ; S U C C E S S ************************************************
003DF8  1  4C 00 04             jmp start       ;run again
003DFB  1               
003DFB  1                   .if disable_decimal < 1
003DFB  1               ; core subroutine of the decimal add/subtract test
003DFB  1               ; *** WARNING - tests documented behavior only! ***
003DFB  1               ;   only valid BCD operands are tested, N V Z flags are ignored
003DFB  1               ; iterates through all valid combinations of operands and carry input
003DFB  1               ; uses increments/decrements to predict result & carry flag
003DFB  1               chkdad:
003DFB  1               ; decimal ADC / SBC zp
003DFB  1  08                   php             ;save carry for subtract
003DFC  1  A5 0D                lda ad1
003DFE  1  65 0E                adc ad2         ;perform add
003E00  1  08                   php
003E01  1  C5 0F                cmp adrl        ;check result
003E03  1  F0 03 20 FF          trap_ne         ;bad result
003E07  1  42           
003E08  1  68                   pla             ;check flags
003E09  1  29 01                and #1          ;mask carry
003E0B  1  C5 10                cmp adrh
003E0D  1  F0 03 20 FF          trap_ne         ;bad carry
003E11  1  42           
003E12  1  28                   plp
003E13  1  08                   php             ;save carry for next add
003E14  1  A5 0D                lda ad1
003E16  1  E5 12                sbc sb2         ;perform subtract
003E18  1  08                   php
003E19  1  C5 0F                cmp adrl        ;check result
003E1B  1  F0 03 20 FF          trap_ne         ;bad result
003E1F  1  42           
003E20  1  68                   pla             ;check flags
003E21  1  29 01                and #1          ;mask carry
003E23  1  C5 10                cmp adrh
003E25  1  F0 03 20 FF          trap_ne         ;bad flags
003E29  1  42           
003E2A  1  28                   plp
003E2B  1               ; decimal ADC / SBC abs
003E2B  1  08                   php             ;save carry for subtract
003E2C  1  A5 0D                lda ad1
003E2E  1  6D 03 02             adc ada2        ;perform add
003E31  1  08                   php
003E32  1  C5 0F                cmp adrl        ;check result
003E34  1  F0 03 20 FF          trap_ne         ;bad result
003E38  1  42           
003E39  1  68                   pla             ;check flags
003E3A  1  29 01                and #1          ;mask carry
003E3C  1  C5 10                cmp adrh
003E3E  1  F0 03 20 FF          trap_ne         ;bad carry
003E42  1  42           
003E43  1  28                   plp
003E44  1  08                   php             ;save carry for next add
003E45  1  A5 0D                lda ad1
003E47  1  ED 04 02             sbc sba2        ;perform subtract
003E4A  1  08                   php
003E4B  1  C5 0F                cmp adrl        ;check result
003E4D  1  F0 03 20 FF          trap_ne         ;bad result
003E51  1  42           
003E52  1  68                   pla             ;check flags
003E53  1  29 01                and #1          ;mask carry
003E55  1  C5 10                cmp adrh
003E57  1  F0 03 20 FF          trap_ne         ;bad carry
003E5B  1  42           
003E5C  1  28                   plp
003E5D  1               ; decimal ADC / SBC #
003E5D  1  08                   php             ;save carry for subtract
003E5E  1  A5 0E                lda ad2
003E60  1  8D 13 02             sta ex_adci+1   ;set ADC # operand
003E63  1  A5 0D                lda ad1
003E65  1  20 12 02             jsr ex_adci     ;execute ADC # in RAM
003E68  1  08                   php
003E69  1  C5 0F                cmp adrl        ;check result
003E6B  1  F0 03 20 FF          trap_ne         ;bad result
003E6F  1  42           
003E70  1  68                   pla             ;check flags
003E71  1  29 01                and #1          ;mask carry
003E73  1  C5 10                cmp adrh
003E75  1  F0 03 20 FF          trap_ne         ;bad carry
003E79  1  42           
003E7A  1  28                   plp
003E7B  1  08                   php             ;save carry for next add
003E7C  1  A5 12                lda sb2
003E7E  1  8D 16 02             sta ex_sbci+1   ;set SBC # operand
003E81  1  A5 0D                lda ad1
003E83  1  20 15 02             jsr ex_sbci     ;execute SBC # in RAM
003E86  1  08                   php
003E87  1  C5 0F                cmp adrl        ;check result
003E89  1  F0 03 20 FF          trap_ne         ;bad result
003E8D  1  42           
003E8E  1  68                   pla             ;check flags
003E8F  1  29 01                and #1          ;mask carry
003E91  1  C5 10                cmp adrh
003E93  1  F0 03 20 FF          trap_ne         ;bad carry
003E97  1  42           
003E98  1  28                   plp
003E99  1               ; decimal ADC / SBC zp,x
003E99  1  08                   php             ;save carry for subtract
003E9A  1  A5 0D                lda ad1
003E9C  1  75 00                adc 0,x         ;perform add
003E9E  1  08                   php
003E9F  1  C5 0F                cmp adrl        ;check result
003EA1  1  F0 03 20 FF          trap_ne         ;bad result
003EA5  1  42           
003EA6  1  68                   pla             ;check flags
003EA7  1  29 01                and #1          ;mask carry
003EA9  1  C5 10                cmp adrh
003EAB  1  F0 03 20 FF          trap_ne         ;bad carry
003EAF  1  42           
003EB0  1  28                   plp
003EB1  1  08                   php             ;save carry for next add
003EB2  1  A5 0D                lda ad1
003EB4  1  F5 04                sbc sb2-ad2,x   ;perform subtract
003EB6  1  08                   php
003EB7  1  C5 0F                cmp adrl        ;check result
003EB9  1  F0 03 20 FF          trap_ne         ;bad result
003EBD  1  42           
003EBE  1  68                   pla             ;check flags
003EBF  1  29 01                and #1          ;mask carry
003EC1  1  C5 10                cmp adrh
003EC3  1  F0 03 20 FF          trap_ne         ;bad carry
003EC7  1  42           
003EC8  1  28                   plp
003EC9  1               ; decimal ADC / SBC abs,x
003EC9  1  08                   php             ;save carry for subtract
003ECA  1  A5 0D                lda ad1
003ECC  1  7D F5 01             adc ada2-ad2,x  ;perform add
003ECF  1  08                   php
003ED0  1  C5 0F                cmp adrl        ;check result
003ED2  1  F0 03 20 FF          trap_ne         ;bad result
003ED6  1  42           
003ED7  1  68                   pla             ;check flags
003ED8  1  29 01                and #1          ;mask carry
003EDA  1  C5 10                cmp adrh
003EDC  1  F0 03 20 FF          trap_ne         ;bad carry
003EE0  1  42           
003EE1  1  28                   plp
003EE2  1  08                   php             ;save carry for next add
003EE3  1  A5 0D                lda ad1
003EE5  1  FD F6 01             sbc sba2-ad2,x  ;perform subtract
003EE8  1  08                   php
003EE9  1  C5 0F                cmp adrl        ;check result
003EEB  1  F0 03 20 FF          trap_ne         ;bad result
003EEF  1  42           
003EF0  1  68                   pla             ;check flags
003EF1  1  29 01                and #1          ;mask carry
003EF3  1  C5 10                cmp adrh
003EF5  1  F0 03 20 FF          trap_ne         ;bad carry
003EF9  1  42           
003EFA  1  28                   plp
003EFB  1               ; decimal ADC / SBC abs,y
003EFB  1  08                   php             ;save carry for subtract
003EFC  1  A5 0D                lda ad1
003EFE  1  79 04 01             adc ada2-$ff,y  ;perform add
003F01  1  08                   php
003F02  1  C5 0F                cmp adrl        ;check result
003F04  1  F0 03 20 FF          trap_ne         ;bad result
003F08  1  42           
003F09  1  68                   pla             ;check flags
003F0A  1  29 01                and #1          ;mask carry
003F0C  1  C5 10                cmp adrh
003F0E  1  F0 03 20 FF          trap_ne         ;bad carry
003F12  1  42           
003F13  1  28                   plp
003F14  1  08                   php             ;save carry for next add
003F15  1  A5 0D                lda ad1
003F17  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
003F1A  1  08                   php
003F1B  1  C5 0F                cmp adrl        ;check result
003F1D  1  F0 03 20 FF          trap_ne         ;bad result
003F21  1  42           
003F22  1  68                   pla             ;check flags
003F23  1  29 01                and #1          ;mask carry
003F25  1  C5 10                cmp adrh
003F27  1  F0 03 20 FF          trap_ne         ;bad carry
003F2B  1  42           
003F2C  1  28                   plp
003F2D  1               ; decimal ADC / SBC (zp,x)
003F2D  1  08                   php             ;save carry for subtract
003F2E  1  A5 0D                lda ad1
003F30  1  61 46                adc (<adi2-ad2,x) ;perform add
003F32  1  08                   php
003F33  1  C5 0F                cmp adrl        ;check result
003F35  1  F0 03 20 FF          trap_ne         ;bad result
003F39  1  42           
003F3A  1  68                   pla             ;check flags
003F3B  1  29 01                and #1          ;mask carry
003F3D  1  C5 10                cmp adrh
003F3F  1  F0 03 20 FF          trap_ne         ;bad carry
003F43  1  42           
003F44  1  28                   plp
003F45  1  08                   php             ;save carry for next add
003F46  1  A5 0D                lda ad1
003F48  1  E1 48                sbc (<sbi2-ad2,x) ;perform subtract
003F4A  1  08                   php
003F4B  1  C5 0F                cmp adrl        ;check result
003F4D  1  F0 03 20 FF          trap_ne         ;bad result
003F51  1  42           
003F52  1  68                   pla             ;check flags
003F53  1  29 01                and #1          ;mask carry
003F55  1  C5 10                cmp adrh
003F57  1  F0 03 20 FF          trap_ne         ;bad carry
003F5B  1  42           
003F5C  1  28                   plp
003F5D  1               ; decimal ADC / SBC (abs),y
003F5D  1  08                   php             ;save carry for subtract
003F5E  1  A5 0D                lda ad1
003F60  1  71 58                adc (adiy2),y   ;perform add
003F62  1  08                   php
003F63  1  C5 0F                cmp adrl        ;check result
003F65  1  F0 03 20 FF          trap_ne         ;bad result
003F69  1  42           
003F6A  1  68                   pla             ;check flags
003F6B  1  29 01                and #1          ;mask carry
003F6D  1  C5 10                cmp adrh
003F6F  1  F0 03 20 FF          trap_ne         ;bad carry
003F73  1  42           
003F74  1  28                   plp
003F75  1  08                   php             ;save carry for next add
003F76  1  A5 0D                lda ad1
003F78  1  F1 5A                sbc (sbiy2),y   ;perform subtract
003F7A  1  08                   php
003F7B  1  C5 0F                cmp adrl        ;check result
003F7D  1  F0 03 20 FF          trap_ne         ;bad result
003F81  1  42           
003F82  1  68                   pla             ;check flags
003F83  1  29 01                and #1          ;mask carry
003F85  1  C5 10                cmp adrh
003F87  1  F0 03 20 FF          trap_ne         ;bad carry
003F8B  1  42           
003F8C  1  28                   plp
003F8D  1  60                   rts
003F8E  1                   .endif
003F8E  1               
003F8E  1               ; core subroutine of the full binary add/subtract test
003F8E  1               ; iterates through all combinations of operands and carry input
003F8E  1               ; uses increments/decrements to predict result & result flags
003F8E  1  A5 11        chkadd: lda adrf        ;add V-flag if overflow
003F90  1  29 83                and #$83        ;keep N-----ZC / clear V
003F92  1  48                   pha
003F93  1  A5 0D                lda ad1         ;test sign unequal between operands
003F95  1  45 0E                eor ad2
003F97  1  30 0A                bmi ckad1       ;no overflow possible - operands have different sign
003F99  1  A5 0D                lda ad1         ;test sign equal between operands and result
003F9B  1  45 0F                eor adrl
003F9D  1  10 04                bpl ckad1       ;no overflow occured - operand and result have same sign
003F9F  1  68                   pla
003FA0  1  09 40                ora #$40        ;set V
003FA2  1  48                   pha
003FA3  1  68           ckad1:  pla
003FA4  1  85 11                sta adrf        ;save expected flags
003FA6  1               ; binary ADC / SBC zp
003FA6  1  08                   php             ;save carry for subtract
003FA7  1  A5 0D                lda ad1
003FA9  1  65 0E                adc ad2         ;perform add
003FAB  1  08                   php
003FAC  1  C5 0F                cmp adrl        ;check result
003FAE  1  F0 03 20 FF          trap_ne         ;bad result
003FB2  1  42           
003FB3  1  68                   pla             ;check flags
003FB4  1  29 C3                and #$c3        ;mask NV----ZC
003FB6  1  C5 11                cmp adrf
003FB8  1  F0 03 20 FF          trap_ne         ;bad flags
003FBC  1  42           
003FBD  1  28                   plp
003FBE  1  08                   php             ;save carry for next add
003FBF  1  A5 0D                lda ad1
003FC1  1  E5 12                sbc sb2         ;perform subtract
003FC3  1  08                   php
003FC4  1  C5 0F                cmp adrl        ;check result
003FC6  1  F0 03 20 FF          trap_ne         ;bad result
003FCA  1  42           
003FCB  1  68                   pla             ;check flags
003FCC  1  29 C3                and #$c3        ;mask NV----ZC
003FCE  1  C5 11                cmp adrf
003FD0  1  F0 03 20 FF          trap_ne         ;bad flags
003FD4  1  42           
003FD5  1  28                   plp
003FD6  1               ; binary ADC / SBC abs
003FD6  1  08                   php             ;save carry for subtract
003FD7  1  A5 0D                lda ad1
003FD9  1  6D 03 02             adc ada2        ;perform add
003FDC  1  08                   php
003FDD  1  C5 0F                cmp adrl        ;check result
003FDF  1  F0 03 20 FF          trap_ne         ;bad result
003FE3  1  42           
003FE4  1  68                   pla             ;check flags
003FE5  1  29 C3                and #$c3        ;mask NV----ZC
003FE7  1  C5 11                cmp adrf
003FE9  1  F0 03 20 FF          trap_ne         ;bad flags
003FED  1  42           
003FEE  1  28                   plp
003FEF  1  08                   php             ;save carry for next add
003FF0  1  A5 0D                lda ad1
003FF2  1  ED 04 02             sbc sba2        ;perform subtract
003FF5  1  08                   php
003FF6  1  C5 0F                cmp adrl        ;check result
003FF8  1  F0 03 20 FF          trap_ne         ;bad result
003FFC  1  42           
003FFD  1  68                   pla             ;check flags
003FFE  1  29 C3                and #$c3        ;mask NV----ZC
004000  1  C5 11                cmp adrf
004002  1  F0 03 20 FF          trap_ne         ;bad flags
004006  1  42           
004007  1  28                   plp
004008  1               ; binary ADC / SBC #
004008  1  08                   php             ;save carry for subtract
004009  1  A5 0E                lda ad2
00400B  1  8D 13 02             sta ex_adci+1   ;set ADC # operand
00400E  1  A5 0D                lda ad1
004010  1  20 12 02             jsr ex_adci     ;execute ADC # in RAM
004013  1  08                   php
004014  1  C5 0F                cmp adrl        ;check result
004016  1  F0 03 20 FF          trap_ne         ;bad result
00401A  1  42           
00401B  1  68                   pla             ;check flags
00401C  1  29 C3                and #$c3        ;mask NV----ZC
00401E  1  C5 11                cmp adrf
004020  1  F0 03 20 FF          trap_ne         ;bad flags
004024  1  42           
004025  1  28                   plp
004026  1  08                   php             ;save carry for next add
004027  1  A5 12                lda sb2
004029  1  8D 16 02             sta ex_sbci+1   ;set SBC # operand
00402C  1  A5 0D                lda ad1
00402E  1  20 15 02             jsr ex_sbci     ;execute SBC # in RAM
004031  1  08                   php
004032  1  C5 0F                cmp adrl        ;check result
004034  1  F0 03 20 FF          trap_ne         ;bad result
004038  1  42           
004039  1  68                   pla             ;check flags
00403A  1  29 C3                and #$c3        ;mask NV----ZC
00403C  1  C5 11                cmp adrf
00403E  1  F0 03 20 FF          trap_ne         ;bad flags
004042  1  42           
004043  1  28                   plp
004044  1               ; binary ADC / SBC zp,x
004044  1  08                   php             ;save carry for subtract
004045  1  A5 0D                lda ad1
004047  1  75 00                adc 0,x         ;perform add
004049  1  08                   php
00404A  1  C5 0F                cmp adrl        ;check result
00404C  1  F0 03 20 FF          trap_ne         ;bad result
004050  1  42           
004051  1  68                   pla             ;check flags
004052  1  29 C3                and #$c3        ;mask NV----ZC
004054  1  C5 11                cmp adrf
004056  1  F0 03 20 FF          trap_ne         ;bad flags
00405A  1  42           
00405B  1  28                   plp
00405C  1  08                   php             ;save carry for next add
00405D  1  A5 0D                lda ad1
00405F  1  F5 04                sbc sb2-ad2,x   ;perform subtract
004061  1  08                   php
004062  1  C5 0F                cmp adrl        ;check result
004064  1  F0 03 20 FF          trap_ne         ;bad result
004068  1  42           
004069  1  68                   pla             ;check flags
00406A  1  29 C3                and #$c3        ;mask NV----ZC
00406C  1  C5 11                cmp adrf
00406E  1  F0 03 20 FF          trap_ne         ;bad flags
004072  1  42           
004073  1  28                   plp
004074  1               ; binary ADC / SBC abs,x
004074  1  08                   php             ;save carry for subtract
004075  1  A5 0D                lda ad1
004077  1  7D F5 01             adc ada2-ad2,x  ;perform add
00407A  1  08                   php
00407B  1  C5 0F                cmp adrl        ;check result
00407D  1  F0 03 20 FF          trap_ne         ;bad result
004081  1  42           
004082  1  68                   pla             ;check flags
004083  1  29 C3                and #$c3        ;mask NV----ZC
004085  1  C5 11                cmp adrf
004087  1  F0 03 20 FF          trap_ne         ;bad flags
00408B  1  42           
00408C  1  28                   plp
00408D  1  08                   php             ;save carry for next add
00408E  1  A5 0D                lda ad1
004090  1  FD F6 01             sbc sba2-ad2,x  ;perform subtract
004093  1  08                   php
004094  1  C5 0F                cmp adrl        ;check result
004096  1  F0 03 20 FF          trap_ne         ;bad result
00409A  1  42           
00409B  1  68                   pla             ;check flags
00409C  1  29 C3                and #$c3        ;mask NV----ZC
00409E  1  C5 11                cmp adrf
0040A0  1  F0 03 20 FF          trap_ne         ;bad flags
0040A4  1  42           
0040A5  1  28                   plp
0040A6  1               ; binary ADC / SBC abs,y
0040A6  1  08                   php             ;save carry for subtract
0040A7  1  A5 0D                lda ad1
0040A9  1  79 04 01             adc ada2-$ff,y  ;perform add
0040AC  1  08                   php
0040AD  1  C5 0F                cmp adrl        ;check result
0040AF  1  F0 03 20 FF          trap_ne         ;bad result
0040B3  1  42           
0040B4  1  68                   pla             ;check flags
0040B5  1  29 C3                and #$c3        ;mask NV----ZC
0040B7  1  C5 11                cmp adrf
0040B9  1  F0 03 20 FF          trap_ne         ;bad flags
0040BD  1  42           
0040BE  1  28                   plp
0040BF  1  08                   php             ;save carry for next add
0040C0  1  A5 0D                lda ad1
0040C2  1  F9 05 01             sbc sba2-$ff,y  ;perform subtract
0040C5  1  08                   php
0040C6  1  C5 0F                cmp adrl        ;check result
0040C8  1  F0 03 20 FF          trap_ne         ;bad result
0040CC  1  42           
0040CD  1  68                   pla             ;check flags
0040CE  1  29 C3                and #$c3        ;mask NV----ZC
0040D0  1  C5 11                cmp adrf
0040D2  1  F0 03 20 FF          trap_ne         ;bad flags
0040D6  1  42           
0040D7  1  28                   plp
0040D8  1               ; binary ADC / SBC (zp,x)
0040D8  1  08                   php             ;save carry for subtract
0040D9  1  A5 0D                lda ad1
0040DB  1  61 46                adc (<adi2-ad2,x) ;perform add
0040DD  1  08                   php
0040DE  1  C5 0F                cmp adrl        ;check result
0040E0  1  F0 03 20 FF          trap_ne         ;bad result
0040E4  1  42           
0040E5  1  68                   pla             ;check flags
0040E6  1  29 C3                and #$c3        ;mask NV----ZC
0040E8  1  C5 11                cmp adrf
0040EA  1  F0 03 20 FF          trap_ne         ;bad flags
0040EE  1  42           
0040EF  1  28                   plp
0040F0  1  08                   php             ;save carry for next add
0040F1  1  A5 0D                lda ad1
0040F3  1  E1 48                sbc (<sbi2-ad2,x) ;perform subtract
0040F5  1  08                   php
0040F6  1  C5 0F                cmp adrl        ;check result
0040F8  1  F0 03 20 FF          trap_ne         ;bad result
0040FC  1  42           
0040FD  1  68                   pla             ;check flags
0040FE  1  29 C3                and #$c3        ;mask NV----ZC
004100  1  C5 11                cmp adrf
004102  1  F0 03 20 FF          trap_ne         ;bad flags
004106  1  42           
004107  1  28                   plp
004108  1               ; binary ADC / SBC (abs),y
004108  1  08                   php             ;save carry for subtract
004109  1  A5 0D                lda ad1
00410B  1  71 58                adc (adiy2),y   ;perform add
00410D  1  08                   php
00410E  1  C5 0F                cmp adrl        ;check result
004110  1  F0 03 20 FF          trap_ne         ;bad result
004114  1  42           
004115  1  68                   pla             ;check flags
004116  1  29 C3                and #$c3        ;mask NV----ZC
004118  1  C5 11                cmp adrf
00411A  1  F0 03 20 FF          trap_ne         ;bad flags
00411E  1  42           
00411F  1  28                   plp
004120  1  08                   php             ;save carry for next add
004121  1  A5 0D                lda ad1
004123  1  F1 5A                sbc (sbiy2),y   ;perform subtract
004125  1  08                   php
004126  1  C5 0F                cmp adrl        ;check result
004128  1  F0 03 20 FF          trap_ne         ;bad result
00412C  1  42           
00412D  1  68                   pla             ;check flags
00412E  1  29 C3                and #$c3        ;mask NV----ZC
004130  1  C5 11                cmp adrf
004132  1  F0 03 20 FF          trap_ne         ;bad flags
004136  1  42           
004137  1  28                   plp
004138  1  60                   rts
004139  1               
004139  1               ; target for the jump absolute test
004139  1  88                   dey
00413A  1  88                   dey
00413B  1               test_far:
00413B  1  08                   php             ;either SP or Y count will fail, if we do not hit
00413C  1  88                   dey
00413D  1  88                   dey
00413E  1  88                   dey
00413F  1  28                   plp
004140  1  90 03 20 FF          trap_cs         ;flags loaded?
004144  1  42           
004145  1  50 03 20 FF          trap_vs
004149  1  42           
00414A  1  10 03 20 FF          trap_mi
00414E  1  42           
00414F  1  D0 03 20 FF          trap_eq
004153  1  42           
004154  1  C9 46                cmp #'F'        ;registers loaded?
004156  1  F0 03 20 FF          trap_ne
00415A  1  42           
00415B  1  E0 41                cpx #'A'
00415D  1  F0 03 20 FF          trap_ne
004161  1  42           
004162  1  C0 4F                cpy #('R'-3)
004164  1  F0 03 20 FF          trap_ne
004168  1  42           
004169  1  48                   pha             ;save a,x
00416A  1  8A                   txa
00416B  1  48                   pha
00416C  1  BA                   tsx
00416D  1  E0 FD                cpx #$fd        ;check SP
00416F  1  F0 03 20 FF          trap_ne
004173  1  42           
004174  1  68                   pla             ;restore x
004175  1  AA                   tax
004176  1  A9 FF 48 28          set_stat $ff
00417A  1  68                   pla             ;restore a
00417B  1  E8                   inx             ;return registers with modifications
00417C  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
00417E  1  4C B6 08             jmp far_ret
004181  1               
004181  1               ; target for the jump indirect test
004181  1               ;       .align 2
004181  1                       .if * & 1       ; workaround for problems with .align 2
004181  1  00                       .byte 0     ;
004182  1                       .endif          ;
004182  1               ptr_tst_ind:
004182  1  8B 41                .word   test_ind
004184  1               ptr_ind_ret:
004184  1  3E 09                .word   ind_ret
004186  1  20 FF 42             trap            ;runover protection
004189  1  88                   dey
00418A  1  88                   dey
00418B  1               test_ind:
00418B  1  08                   php             ;either SP or Y count will fail, if we do not hit
00418C  1  88                   dey
00418D  1  88                   dey
00418E  1  88                   dey
00418F  1  28                   plp
004190  1  90 03 20 FF          trap_cs         ;flags loaded?
004194  1  42           
004195  1  50 03 20 FF          trap_vs
004199  1  42           
00419A  1  10 03 20 FF          trap_mi
00419E  1  42           
00419F  1  D0 03 20 FF          trap_eq
0041A3  1  42           
0041A4  1  C9 49                cmp #'I'        ;registers loaded?
0041A6  1  F0 03 20 FF          trap_ne
0041AA  1  42           
0041AB  1  E0 4E                cpx #'N'
0041AD  1  F0 03 20 FF          trap_ne
0041B1  1  42           
0041B2  1  C0 41                cpy #('D'-3)
0041B4  1  F0 03 20 FF          trap_ne
0041B8  1  42           
0041B9  1  48                   pha             ;save a,x
0041BA  1  8A                   txa
0041BB  1  48                   pha
0041BC  1  BA                   tsx
0041BD  1  E0 FD                cpx #$fd        ;check SP
0041BF  1  F0 03 20 FF          trap_ne
0041C3  1  42           
0041C4  1  68                   pla             ;restore x
0041C5  1  AA                   tax
0041C6  1  A9 FF 48 28          set_stat $ff
0041CA  1  68                   pla             ;restore a
0041CB  1  E8                   inx             ;return registers with modifications
0041CC  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
0041CE  1  6C 84 41             jmp (ptr_ind_ret)
0041D1  1  20 FF 42             trap            ;runover protection
0041D4  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
0041D7  1               
0041D7  1               ; target for the jump subroutine test
0041D7  1  88                   dey
0041D8  1  88                   dey
0041D9  1               test_jsr:
0041D9  1  08                   php             ;either SP or Y count will fail, if we do not hit
0041DA  1  88                   dey
0041DB  1  88                   dey
0041DC  1  88                   dey
0041DD  1  28                   plp
0041DE  1  90 03 20 FF          trap_cs         ;flags loaded?
0041E2  1  42           
0041E3  1  50 03 20 FF          trap_vs
0041E7  1  42           
0041E8  1  10 03 20 FF          trap_mi
0041EC  1  42           
0041ED  1  D0 03 20 FF          trap_eq
0041F1  1  42           
0041F2  1  C9 4A                cmp #'J'        ;registers loaded?
0041F4  1  F0 03 20 FF          trap_ne
0041F8  1  42           
0041F9  1  E0 53                cpx #'S'
0041FB  1  F0 03 20 FF          trap_ne
0041FF  1  42           
004200  1  C0 4F                cpy #('R'-3)
004202  1  F0 03 20 FF          trap_ne
004206  1  42           
004207  1  48                   pha             ;save a,x
004208  1  8A                   txa
004209  1  48                   pha
00420A  1  BA                   tsx             ;sp -4? (return addr,a,x)
00420B  1  E0 FB                cpx #$fb
00420D  1  F0 03 20 FF          trap_ne
004211  1  42           
004212  1  AD FF 01             lda $1ff        ;propper return on stack
004215  1  C9 09                cmp #>jsr_ret
004217  1  F0 03 20 FF          trap_ne
00421B  1  42           
00421C  1  AD FE 01             lda $1fe
00421F  1  C9 8F                cmp #<jsr_ret
004221  1  F0 03 20 FF          trap_ne
004225  1  42           
004226  1  A9 FF 48 28          set_stat $ff
00422A  1  68                   pla             ;pull x,a
00422B  1  AA                   tax
00422C  1  68                   pla
00422D  1  E8                   inx             ;return registers with modifications
00422E  1  49 AA                eor #$aa        ;N=1, V=1, Z=0, C=1
004230  1  60                   rts
004231  1  20 FF 42             trap            ;runover protection
004234  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
004237  1               
004237  1               ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
004237  1               nmi_trap:
004237  1  20 FF 42             trap            ;check stack for conditions at NMI
00423A  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
00423D  1               res_trap:
00423D  1  20 FF 42             trap            ;unexpected RESET
004240  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
004243  1               
004243  1  88                   dey
004244  1  88                   dey
004245  1               irq_trap:               ;BRK test or unextpected BRK or IRQ
004245  1  08                   php             ;either SP or Y count will fail, if we do not hit
004246  1  88                   dey		; BRK (from test brk) jumps here
004247  1  88                   dey		; $4252...
004248  1  88                   dey
004249  1                       ;next traps could be caused by unexpected BRK or IRQ
004249  1                       ;check stack for BREAK and originating location
004249  1                       ;possible jump/branch into weeds (uninitialized space)
004249  1  C9 BD                cmp #$ff-'B'    ;BRK pass 2 registers loaded?
00424B  1  F0 55                beq break2
00424D  1  C9 42                cmp #'B'        ;BRK pass 1 registers loaded?
00424F  1  F0 03 20 FF          trap_ne
004253  1  42           
004254  1  E0 52                cpx #'R'
004256  1  F0 03 20 FF          trap_ne
00425A  1  42           
00425B  1  C0 48                cpy #'K'-3
00425D  1  F0 03 20 FF          trap_ne
004261  1  42           
004262  1  85 0A                sta irq_a       ;save registers during break test
004264  1  86 0B                stx irq_x
004266  1  BA                   tsx             ;test break on stack
004267  1  BD 02 01             lda $102,x
00426A  1  C9 30                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
00426C  1                       ; trap_ne         ; - no break flag on stack
00426C  1  68                   pla
00426D  1  C9 34                cmp_flag intdis ;should have added interrupt disable
00426F  1  F0 03 20 FF          trap_ne
004273  1  42           
004274  1  BA                   tsx
004275  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
004277  1  F0 03 20 FF          trap_ne
00427B  1  42           
00427C  1  AD FF 01             lda $1ff        ;propper return on stack
00427F  1  C9 09                cmp #>brk_ret0
004281  1  F0 03 20 FF          trap_ne
004285  1  42           
004286  1  AD FE 01             lda $1fe
004289  1  C9 E1                cmp #<brk_ret0
00428B  1  F0 03 20 FF          trap_ne
00428F  1  42           
004290  1  A9 FF                load_flag $ff
004292  1  48                   pha
004293  1  A6 0B                ldx irq_x
004295  1  E8                   inx             ;return registers with modifications
004296  1  A5 0A                lda irq_a
004298  1  49 AA                eor #$aa
00429A  1  28                   plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
00429B  1  40                   rti
00429C  1  20 FF 42             trap            ;runover protection
00429F  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
0042A2  1               
0042A2  1               break2:                 ;BRK pass 2
0042A2  1  E0 AD                cpx #$ff-'R'	; $42b6
0042A4  1  F0 03 20 FF          trap_ne
0042A8  1  42           
0042A9  1  C0 B1                cpy #$ff-'K'-3
0042AB  1  F0 03 20 FF          trap_ne
0042AF  1  42           
0042B0  1  85 0A                sta irq_a       ;save registers during break test
0042B2  1  86 0B                stx irq_x
0042B4  1  BA                   tsx             ;test break on stack
0042B5  1  BD 02 01             lda $102,x	; X
0042B8  1                       ;cmp_flag $ff    ;break test should have B=1
0042B8  1                       ; trap_ne         ; - no break flag on stack
0042B8  1  68                   pla
0042B9  1  09 08                ora #decmode    ;ignore decmode cleared if 65c02
0042BB  1  C9 FF                cmp_flag $ff    ;actual passed flags
0042BD  1  F0 03 20 FF          trap_ne
0042C1  1  42           
0042C2  1  BA                   tsx
0042C3  1  E0 FC                cpx #$fc        ;sp -3? (return addr, flags)
0042C5  1  F0 03 20 FF          trap_ne
0042C9  1  42           
0042CA  1  AD FF 01             lda $1ff        ;propper return on stack
0042CD  1  C9 0A                cmp #>brk_ret1
0042CF  1  F0 03 20 FF          trap_ne
0042D3  1  42           
0042D4  1  AD FE 01             lda $1fe
0042D7  1  C9 16                cmp #<brk_ret1
0042D9  1  F0 03 20 FF          trap_ne
0042DD  1  42           
0042DE  1  A9 04                load_flag intdis
0042E0  1  48                   pha
0042E1  1  A6 0B                ldx irq_x
0042E3  1  E8                   inx             ;return registers with modifications
0042E4  1  A5 0A                lda irq_a
0042E6  1  49 AA                eor #$aa
0042E8  1  28                   plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
0042E9  1  40                   rti
0042EA  1  20 FF 42             trap            ;runover protection
0042ED  1  4C 00 04             jmp start       ;catastrophic error - cannot continue
0042F0  1               
0042F0  1                   .if report = 1
0042F0  1                       .include "report.i65"
0042F0  2               ;**** report 6502 funtional test errors to standard I/O ****
0042F0  2               ;
0042F0  2               ;this include file is part of the 6502 functional tests
0042F0  2               ;it is used when you configure report = 1 in the tests
0042F0  2               ;
0042F0  2               ;to adopt the standard output vectors of your test environment
0042F0  2               ;you must modify the rchar and rget subroutines in this include
0042F0  2               ;
0042F0  2               ;I/O hardware may have to be initialized in report_init
0042F0  2               
0042F0  2               ;print message .macro - \1 = message location
0042F0  2               
0042F0  2               .macro  rprt   addr
0042F0  2               	.local   loop
0042F0  2                       ldx #0
0042F0  2                       lda addr
0042F0  2               loop:
0042F0  2                       jsr rchar
0042F0  2                       inx
0042F0  2                       lda addr,x
0042F0  2                       bne loop
0042F0  2               .endmacro
0042F0  2               
0042F0  2               ;initialize I/O as required (example: configure & enable ACIA)
0042F0  2               report_init:
0042F0  2                       ;nothing to initialize
0042F0  2  A2 00 AD 21          rprt rmsg_start
0042F4  2  44 20 1D 44  
0042F8  2  E8 BD 21 44  
0042FE  2  60                   rts
0042FF  2               
0042FF  2               ;show stack (with saved registers), zeropage and absolute memory workspace
0042FF  2               ;after an error was trapped in the test program
0042FF  2               report_error:
0042FF  2               ;save registers
0042FF  2  08                   php
004300  2  48                   pha
004301  2  8A                   txa
004302  2  48                   pha
004303  2  98                   tya
004304  2  48                   pha
004305  2  D8                   cld
004306  2               ;show stack with index to registers at error
004306  2  A2 00 AD 35          rprt rmsg_stack
00430A  2  44 20 1D 44  
00430E  2  E8 BD 35 44  
004314  2  BA                   tsx
004315  2  E8                   inx
004316  2  A9 3E        	lda #'>' 	; XXX
004318  2  20 1D 44     	jsr rchar
00431B  2  A9 01                lda #1      ;address high
00431D  2  20 09 44             jsr rhex
004320  2  8A                   txa         ;address low
004321  2  20 09 44             jsr rhex
004324  2  20 05 44     rstack:  jsr rspace
004327  2  A9 53        	lda #'S' 	; XXX
004329  2  20 1D 44     	jsr rchar
00432C  2  BD 00 01             lda $100,x  ;stack data
00432F  2  20 09 44             jsr rhex
004332  2  E8                   inx
004333  2  D0 EF                bne rstack
004335  2  20 FC 43             jsr rcrlf   ;new line
004338  2               ;show zero page workspace
004338  2  A9 00                lda #0
00433A  2  20 09 44             jsr rhex
00433D  2  A9 0C                lda #zpt
00433F  2  AA                   tax
004340  2  20 09 44             jsr rhex
004343  2  20 05 44     rzp:     jsr rspace
004346  2  A9 5A        	lda #'Z' 	; XXX
004348  2  20 1D 44     	jsr rchar
00434B  2  B5 00                lda 0,x
00434D  2  20 09 44             jsr rhex
004350  2  E8                   inx
004351  2  E0 13                cpx #zp_bss
004353  2  D0 EE                bne rzp
004355  2  20 FC 43             jsr rcrlf
004358  2               ;show absolute workspace
004358  2  A9 02                lda #>data_segment
00435A  2  20 09 44             jsr rhex
00435D  2  A9 00                lda #<data_segment
00435F  2  20 09 44             jsr rhex
004362  2  A2 00                ldx #0
004364  2  20 05 44     rabs:    jsr rspace
004367  2  A9 40        	lda #'@' 	; XXX
004369  2  20 1D 44     	jsr rchar
00436C  2  BD 00 02             lda data_segment,x
00436F  2  20 09 44             jsr rhex
004372  2  E8                   inx
004373  2  E0 09                cpx #(data_bss-data_segment)
004375  2  D0 ED                bne rabs
004377  2               ;ask to continue
004377  2  A2 00 AD 51          rprt rmsg_cont
00437B  2  44 20 1D 44  
00437F  2  E8 BD 51 44  
004385  2  20 F2 43     rerr1:   jsr rget
004388  2  C9 53                cmp #'S'
00438A  2  F0 0B                beq rskip
00438C  2  C9 43                cmp #'C'
00438E  2  D0 F5                bne rerr1
004390  2               ;restore registers
004390  2  68                   pla
004391  2  A8                   tay
004392  2  68                   pla
004393  2  AA                   tax
004394  2  68                   pla
004395  2  28                   plp
004396  2  60                   rts
004397  2               ;skip the current test
004397  2  A9 F0        rskip:   lda #$f0            ;already end of tests?
004399  2  CD 00 02             cmp test_case
00439C  2  F0 E7                beq rerr1           ;skip is not available
00439E  2  A2 FF                ldx #$ff            ;clear stack
0043A0  2  9A                   txs
0043A1  2  EE 00 02             inc test_case       ;next test
0043A4  2  A9 00                lda #<start      ;find begin of test
0043A6  2  85 0C                sta zpt
0043A8  2  A9 04                lda #>start
0043AA  2  85 0D                sta zpt+1
0043AC  2  A0 04        rskipl1: ldy #4              ;search pattern
0043AE  2  B1 0C        rskipl2: lda (zpt),y         ;next byte
0043B0  2  D9 D7 43             cmp rmark,y
0043B3  2  D0 0A                bne rskipnx         ;no match
0043B5  2  88                   dey
0043B6  2  30 0F                bmi rskipf          ;found pattern
0043B8  2  C0 01                cpy #1              ;skip immediate value
0043BA  2  D0 F2                bne rskipl2
0043BC  2  88                   dey
0043BD  2  F0 EF                beq rskipl2
0043BF  2               
0043BF  2  E6 0C        rskipnx: inc zpt             ;next RAM location
0043C1  2  D0 E9                bne rskipl1
0043C3  2  E6 0D                inc zpt+1
0043C5  2  D0 E5                bne rskipl1
0043C7  2               
0043C7  2  A0 01        rskipf:  ldy #1              ;pattern found - check test number
0043C9  2  B1 0C                lda (zpt),y         ;test number
0043CB  2  C9 F0                cmp #$f0            ;end of last test?
0043CD  2  F0 05                beq rskipe          ;ask to rerun all
0043CF  2  CD 00 02             cmp test_case       ;is next test?
0043D2  2  D0 EB                bne rskipnx         ;continue searching
0043D4  2  6C 0C 00     rskipe:  jmp (zpt)           ;start next test or rerun at end of tests
0043D7  2               
0043D7  2  A9 00        rmark:   lda #0              ;begin of test search pattern
0043D9  2  8D 00 02             sta test_case
0043DC  2               
0043DC  2               ;show test has ended, ask to repeat
0043DC  2               report_success:
0043DC  2  A2 00 AD 83          rprt rmsg_success
0043E0  2  44 20 1D 44  
0043E4  2  E8 BD 83 44  
0043EA  2  20 F2 43     rsuc1:   jsr rget
0043ED  2  C9 52                cmp #'R'
0043EF  2  D0 F9                bne rsuc1
0043F1  2  60                   rts
0043F2  2               
0043F2  2               ;input subroutine
0043F2  2               ;get a character from standard input
0043F2  2               ;adjust according to the needs in your test environment
0043F2  2               rget:                ;get character in A
0043F2  2               ;rget1
0043F2  2               ;        lda $bff1   ;wait RDRF
0043F2  2               ;        and #8
0043F2  2               ;        beq rget1
0043F2  2               ;not a real ACIA - so RDRF is not checked
0043F2  2               ;        lda $bff0   ;read acia rx reg
0043F2  2  AD 04 F0             lda $f004   ;Kowalski simulator default
0043F5  2               ;the load can be replaced by a call to a kernal routine
0043F5  2               ;        jsr $ffcf   ;example: CHRIN for a C64
0043F5  2  C9 61                cmp #'a'    ;lower case
0043F7  2  90 02                bcc rget1
0043F9  2  29 5F                and #$5f    ;convert to upper case
0043FB  2  60           rget1:   rts
0043FC  2               
0043FC  2               ;output subroutines
0043FC  2  A9 0A        rcrlf:   lda #10
0043FE  2  20 1D 44             jsr rchar
004401  2  A9 0D                lda #13
004403  2  D0 18                bne rchar
004405  2               
004405  2  A9 20        rspace:  lda #' '
004407  2  D0 14                bne rchar
004409  2               
004409  2  48           rhex:    pha         ;report hex byte in A
00440A  2  4A                   lsr a       ;high nibble first
00440B  2  4A                   lsr a
00440C  2  4A                   lsr a
00440D  2  4A                   lsr a
00440E  2  20 14 44             jsr rnib
004411  2  68                   pla         ;now low nibble
004412  2  29 0F                and #$f
004414  2               
004414  2  18           rnib:    clc         ;report nibble in A
004415  2  69 30                adc #'0'    ;make printable 0-9
004417  2  C9 3A                cmp #'9'+1
004419  2  90 02                bcc rchar
00441B  2  69 06                adc #6      ;make printable A-F
00441D  2               
00441D  2               ;send a character to standard output
00441D  2               ;adjust according to the needs in your test environment
00441D  2               ;register X needs to be preserved!
00441D  2               rchar:               ;report character in A
00441D  2               ;        pha         ;wait TDRF
00441D  2               ;rchar1  lda $bff1
00441D  2               ;        and #$10
00441D  2               ;        beq rchar1
00441D  2               ;        pla
00441D  2               ;not a real ACIA - so TDRF is not checked
00441D  2               ;        sta $bff0   ;write acia tx reg
00441D  2  8D 01 F0             sta $f001   ;Kowalski simulator default
004420  2               ;the store can be replaced by a call to a kernal routine
004420  2               ;        jsr $ffd2   ;example: CHROUT for a C64
004420  2  60                   rts
004421  2               
004421  2               rmsg_start:
004421  2  0A 0D 53 74          .byt  10,13,"Started testing",10,13,0
004425  2  61 72 74 65  
004429  2  64 20 74 65  
004435  2               rmsg_stack:
004435  2  0A 0D 72 65          .byt  10,13,"regs Y  X  A  PS PCLPCH",10,13,0
004439  2  67 73 20 59  
00443D  2  20 20 58 20  
004451  2               rmsg_cont:
004451  2  0A 0D 70 72          .byt  10,13,"press C to continue or S to skip current test",10,13,0
004455  2  65 73 73 20  
004459  2  43 20 74 6F  
004483  2               rmsg_success:
004483  2  0A 0D 41 6C          .byt  10,13,"All tests completed, press R to repeat",10,13,0
004487  2  6C 20 74 65  
00448B  2  73 74 73 20  
0044AE  2               
0044AE  2               
0044AE  1                   .endif
0044AE  1               
0044AE  1               ;copy of data to initialize BSS segment
0044AE  1                   .if load_data_direct <> 1
0044AE  1               zp_init:
0044AE  1               zps_:   .byte   $80,1           ;additional shift pattern to test zero result & flag
0044AE  1               zp1_:   .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0044AE  1               zp7f_:  .byte   $7f             ;test pattern for compare
0044AE  1               ;logical zeropage operands
0044AE  1               zpOR_:  .byte   0,$1f,$71,$80   ;test pattern for OR
0044AE  1               zpAN_:  .byte   $0f,$ff,$7f,$80 ;test pattern for AND
0044AE  1               zpEO_:  .byte   $ff,$0f,$8f,$8f ;test pattern for EOR
0044AE  1               ;indirect addressing pointers
0044AE  1               ind1_:  .word   abs1            ;indirect pointer to pattern in absolute memory
0044AE  1                       .word   abs1+1
0044AE  1                       .word   abs1+2
0044AE  1                       .word   abs1+3
0044AE  1                       .word   abs7f
0044AE  1               inw1_:  .word   abs1-$f8        ;indirect pointer for wrap-test pattern
0044AE  1               indt_:  .word   abst            ;indirect pointer to store area in absolute memory
0044AE  1                       .word   abst+1
0044AE  1                       .word   abst+2
0044AE  1                       .word   abst+3
0044AE  1               inwt_:  .word   abst-$f8        ;indirect pointer for wrap-test store
0044AE  1               indAN_: .word   absAN           ;indirect pointer to AND pattern in absolute memory
0044AE  1                       .word   absAN+1
0044AE  1                       .word   absAN+2
0044AE  1                       .word   absAN+3
0044AE  1               indEO_: .word   absEO           ;indirect pointer to EOR pattern in absolute memory
0044AE  1                       .word   absEO+1
0044AE  1                       .word   absEO+2
0044AE  1                       .word   absEO+3
0044AE  1               indOR_: .word   absOR           ;indirect pointer to OR pattern in absolute memory
0044AE  1                       .word   absOR+1
0044AE  1                       .word   absOR+2
0044AE  1                       .word   absOR+3
0044AE  1               ;add/subtract indirect pointers
0044AE  1               adi2_:  .word   ada2            ;indirect pointer to operand 2 in absolute memory
0044AE  1               sbi2_:  .word   sba2            ;indirect pointer to complemented operand 2 (SBC)
0044AE  1               adiy2_: .word   ada2-$ff        ;with offset for indirect indexed
0044AE  1               sbiy2_: .word   sba2-$ff
0044AE  1               zp_end:
0044AE  1                   .if (zp_end - zp_init) <> (zp_bss_end - zp_bss)
0044AE  1                       ;force assembler error if size is different
0044AE  1                       .error "mismatch between bss and zeropage data"
0044AE  1                   .endif
0044AE  1               data_init:
0044AE  1               ex_and_:and #0              ;execute immediate opcodes
0044AE  1                       rts
0044AE  1               ex_eor_:eor #0              ;execute immediate opcodes
0044AE  1                       rts
0044AE  1               ex_ora_:ora #0              ;execute immediate opcodes
0044AE  1                       rts
0044AE  1               ex_adc_:adc #0              ;execute immediate opcodes
0044AE  1                       rts
0044AE  1               ex_sbc_:sbc #0              ;execute immediate opcodes
0044AE  1                       rts
0044AE  1               ;zps:   .byte   $80,1           ;additional shift patterns test zero result & flag
0044AE  1               abs1_:  .byte   $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0044AE  1               abs7f_: .byte   $7f             ;test pattern for compare
0044AE  1               ;loads
0044AE  1               fLDx_:  .byte   fn,fn,0,fz              ;expected flags for load
0044AE  1               ;shifts
0044AE  1               rASL_:                                  ;expected result ASL & ROL -carry
0044AE  1               rROL_:  .byte   0,2,$86,$04,$82,0
0044AE  1               rROLc_: .byte   1,3,$87,$05,$83,1       ;expected result ROL +carry
0044AE  1               rLSR_:                                  ;expected result LSR & ROR -carry
0044AE  1               rROR_:  .byte   $40,0,$61,$41,$20,0
0044AE  1               rRORc_: .byte   $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0044AE  1               fASL_:                                  ;expected flags for shifts
0044AE  1               fROL_:  .byte   fzc,0,fnc,fc,fn,fz      ;no carry in
0044AE  1               fROLc_: .byte   fc,0,fnc,fc,fn,0        ;carry in
0044AE  1               fLSR_:
0044AE  1               fROR_:  .byte   0,fzc,fc,0,fc,fz        ;no carry in
0044AE  1               fRORc_: .byte   fn,fnc,fnc,fn,fnc,fn    ;carry in
0044AE  1               ;increments (decrements)
0044AE  1               rINC_:  .byte   $7f,$80,$ff,0,1         ;expected result for INC/DEC
0044AE  1               fINC_:  .byte   0,fn,fn,fz,0            ;expected flags for INC/DEC
0044AE  1               ;logical memory operand
0044AE  1               absOR_: .byte   0,$1f,$71,$80           ;test pattern for OR
0044AE  1               absAN_: .byte   $0f,$ff,$7f,$80         ;test pattern for AND
0044AE  1               absEO_: .byte   $ff,$0f,$8f,$8f         ;test pattern for EOR
0044AE  1               ;logical accu operand
0044AE  1               absORa_:.byte   0,$f1,$1f,0             ;test pattern for OR
0044AE  1               absANa_:.byte   $f0,$ff,$ff,$ff         ;test pattern for AND
0044AE  1               absEOa_:.byte   $ff,$f0,$f0,$0f         ;test pattern for EOR
0044AE  1               ;logical results
0044AE  1               absrlo_:.byte   0,$ff,$7f,$80
0044AE  1               absflo_:.byte   fz,fn,0,fn
0044AE  1               data_end
0044AE  1                   .if (data_end - data_init) <> (data_bss_end - data_bss)
0044AE  1                       ;force assembler error if size is different
0044AE  1                       .error "mismatch between bss and data"
0044AE  1                   .endif
0044AE  1               
0044AE  1               vec_init
0044AE  1                       .word   nmi_trap
0044AE  1                       .word   res_trap
0044AE  1                       .word   irq_trap
0044AE  1               vec_bss equ $fffa
0044AE  1                   .endif                   ;end of RAM init data
0044AE  1               
0044AE  1                   .if (load_data_direct = 1) & (ROM_vectors = 1)
0044AE  1                       .segment "VECTORS"
0044AE  1                       .org $fffa       ;vectors
00FFFA  1  37 42                .word   nmi_trap
00FFFC  1  3D 42                .word   res_trap
00FFFE  1  45 42                .word   irq_trap
010000  1                   .endif
010000  1               
